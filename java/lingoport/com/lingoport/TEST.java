//{{COMPONENT_BASE_IMPORT_STMTS
package advantage;
import java.util.Enumeration;
import java.util.Vector;
import versata.common.*;
import versata.common.vstrace.*;
import versata.common.Parameter;
import versata.vls.*;
import java.util.*;
import java.text.*;
import java.math.*;
import com.amsinc.gems.adv.common.*;
import com.versata.util.logging.*;
import org.apache.commons.logging.*;

//END_COMPONENT_BASE_IMPORT_STMTS}}
//Import statements from custom implementation class.
import  versata.vls.cache.*;


public abstract class R_DEPTBaseImpl extends  AMSCOADataObject
{
	public static Logger logger = Logger.getLogger("advantage.R_DEPT");
	public R_DEPTBaseImpl () 
	{
		super();
		addListeners();
		loadBRDParents();
		myInitializations();
		
                if ( isBehaviorEnabled( AMSBEHAVIOR_TIMELINE ) )
                {
                    setTimeline( new AMSTimelineMaintenance( this ) ) ;
                }
	}

	//{{COMPONENT_META_QRY
	
	private final static String deployedFromRepository = "advantage";
	/**
	Cache support
	*/
	public static int cacheSize = 0;
	public static long expires = -1;
	public static boolean initialized = false;
	
	
	public String getPackageName() {
		return deployedFromRepository;
	}
	protected static int miDEPT_CD;
	protected static int miDEPT_NM;
	protected static int miDEPT_NM_UP;
	protected static int miDEPT_SH_NM;
	protected static int miDEPT_DSCR;
	protected static int miCNTAC_CD;
	protected static int miCNTAC_PERSN;
	protected static int miCNTAC_EMAIL;
	protected static int miCNTAC_PH_NO;
	protected static int miCNTAC_PH_EXT;
	protected static int miACT_FL;
	protected static int miALW_BUD_FL;
	protected static int miEFBGN_DT;
	protected static int miEFEND_DT;
	protected static int miBUYR_ID;
	protected static int miTEAM_ID;
	protected static int miBUYR_NM;
	protected static int miTEAM_NM;
	protected static int miAMS_ROW_VERS_NO;
	protected static int miDLGTD_BUYR_ID;
	protected static int miDLGTD_TEAM_ID;
	protected static int miDLGTD_TEAM_NM;
	protected static int miDLGTD_BUYR_NM;
	protected static int miAR_UNIT_INFR;
	protected static int miDEPT_SH_NM_UP;
	protected static int miDEPT_DSCR_UP;
	protected static int miREST_BUYR_UNIT;
	protected static int miDISB_CNTAC_CD;
	protected static int miDISB_CNTAC_NM;
	protected static int miTBL_LAST_DT;
	protected static int miDSCR_EXT;
	protected static int miBASE_DEPT_FL;
	protected static int miTRVL_POL;
	public  static Vector myRequired = new Vector();
	public static Hashtable mhtCodeTable = new Hashtable( 25, (float)0.80);
	private static Vector mvAggregateColsNameList = new Vector( 25 ) ;
	private static Hashtable mhtMySums       = null;
	private static BitSet myBehavior = new BitSet();
	private static char inMrt = ' ';
	private static Mrt moMRTObject = null;
	private static char useCustom = ' ' ;
	private static final String defaultSQLXDA = "versata.vls.XDASQLConnector" ;
	private static boolean mboolMrtLkupForRowSecurityFlag = false ;
	private static boolean mboolRowSecFlgValue = false ;
	private static boolean mboolParentsSorted  = false ;
	private static boolean mboolAllowMRTUpdate = false ;
	private static String  msSortedParents [];
	private static String msSortParentsSync = "sortParents";
	private static Hashtable moUpperCaseTextAttrsList = new Hashtable( 16, (float)0.80 ) ;
	private static Hashtable moMixedCaseTextAttrsList = new Hashtable( 16, (float)0.80 ) ;
	public boolean mboolCustomDataObjectSave = false ;
	public static VSQueryDefinition  q= null;    
	private static String msEffDtAttr = null;
	private static String msExpDtAttr = null;
	private static String msObjAttType = null ;
	private static char mcOrgLvlSecType = AMSSecurity.getOrgLevelSecurityType( "R_DEPT" ) ;
	private static AppObjectImpl appObject;
	protected static final Log moAMSLog ;
	
	static {
	   if (!initialized)  
	   {
	      initCache(); //inits the SDO cache properties
	   }
	   
	   // Clone default behavior from closes parent class having 
	   // default behaviors.
	   myBehavior = (BitSet)defaultBehavior.clone();
		q= new VSQueryDefinition( "R_DEPT" );	
		q.setPackageName(deployedFromRepository);
		q.addProperty("PreventMaintNonPersRepl", "true");
		
		VSMetaColumn c = null;
		VSMetaTable t = new VSMetaTable("R_DEPT");
		//{{META_QUERY_COLUMN_CTOR
		c = new VSMetaColumn("DEPT_CD", DataConst.VARCHAR);
		c.setSize(4);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
		myRequired.addElement("DEPT_CD");
	    c.setCaption("Department");
		t.addColumn( c );
		miDEPT_CD = t.getColumnIndex("DEPT_CD");
	c.addProperty("Sortable", "Y");
		
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("DEPT_NM", DataConst.VARCHAR);
		c.setSize(60);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
		myRequired.addElement("DEPT_NM");
	    c.setCaption("Name");
		t.addColumn( c );
		miDEPT_NM = t.getColumnIndex("DEPT_NM");
	c.addProperty("SortAttribute", "DEPT_NM_UP");
		c.addProperty("Sortable", "Y");
		c.addProperty("PreventMaintNonPersRepl", "true");
		c.addProperty("AllowMixedCase", "Y");
		
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("DEPT_NM_UP", DataConst.VARCHAR);
		c.setSize(60);
		c.setAlterability(false);
		c.setNullability(VSMetaColumn.columnNullable);
		c.setComputed (true);
	    c.setCaption("Name");
		t.addColumn( c );
		miDEPT_NM_UP = t.getColumnIndex("DEPT_NM_UP");
	
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("DEPT_SH_NM", DataConst.VARCHAR);
		c.setSize(15);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
		myRequired.addElement("DEPT_SH_NM");
	    c.setCaption("Short Name");
		t.addColumn( c );
		miDEPT_SH_NM = t.getColumnIndex("DEPT_SH_NM");
	c.addProperty("PreventMaintNonPersRepl", "true");
		c.addProperty("AllowMixedCase", "Y");
		
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("DEPT_DSCR", DataConst.VARCHAR);
		c.setSize(100);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
	    c.setCaption("Description");
		t.addColumn( c );
		miDEPT_DSCR = t.getColumnIndex("DEPT_DSCR");
	c.addProperty("AllowMixedCase", "Y");
		
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("CNTAC_CD", DataConst.BIGINT);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
	    c.setCaption("Contact Code");
		t.addColumn( c );
		miCNTAC_CD = t.getColumnIndex("CNTAC_CD");
	
		c = new VSMetaColumn("CNTAC_PERSN", DataConst.VARCHAR);
		c.setSize(60);
		c.setAlterability(false);
		c.setNullability(VSMetaColumn.columnNullable);
		c.setComputed (true);
	    c.setCaption("Contact Person");
		t.addColumn( c );
		miCNTAC_PERSN = t.getColumnIndex("CNTAC_PERSN");
	
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("CNTAC_EMAIL", DataConst.VARCHAR);
		c.setSize(100);
		c.setAlterability(false);
		c.setNullability(VSMetaColumn.columnNullable);
		c.setComputed (true);
	    c.setCaption("Email Address");
		t.addColumn( c );
		miCNTAC_EMAIL = t.getColumnIndex("CNTAC_EMAIL");
	
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("CNTAC_PH_NO", DataConst.VARCHAR);
		c.setSize(30);
		c.setAlterability(false);
		c.setNullability(VSMetaColumn.columnNullable);
		c.setComputed (true);
	    c.setCaption("Phone Number");
		t.addColumn( c );
		miCNTAC_PH_NO = t.getColumnIndex("CNTAC_PH_NO");
	
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("CNTAC_PH_EXT", DataConst.VARCHAR);
		c.setSize(6);
		c.setAlterability(false);
		c.setNullability(VSMetaColumn.columnNullable);
		c.setComputed (true);
	    c.setCaption("Phone Extension");
		t.addColumn( c );
		miCNTAC_PH_EXT = t.getColumnIndex("CNTAC_PH_EXT");
	
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("ACT_FL", DataConst.BIT);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
		myRequired.addElement("ACT_FL");
		c.setDefaultValue(" True ");
	    c.setCaption("Active");
		t.addColumn( c );
		miACT_FL = t.getColumnIndex("ACT_FL");
	
		c = new VSMetaColumn("ALW_BUD_FL", DataConst.BIT);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
		myRequired.addElement("ALW_BUD_FL");
		c.setDefaultValue(" True ");
	    c.setCaption("Budgeting");
		t.addColumn( c );
		miALW_BUD_FL = t.getColumnIndex("ALW_BUD_FL");
	
		c = new VSMetaColumn("EFBGN_DT", DataConst.DATE);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
	    c.setCaption("Effective From");
		t.addColumn( c );
		miEFBGN_DT = t.getColumnIndex("EFBGN_DT");
	c.addProperty("DateValidation", "Y");
		
		c = new VSMetaColumn("EFEND_DT", DataConst.DATE);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
	    c.setCaption("Effective To");
		t.addColumn( c );
		miEFEND_DT = t.getColumnIndex("EFEND_DT");
	c.addProperty("DateValidation", "Y");
		
		c = new VSMetaColumn("BUYR_ID", DataConst.VARCHAR);
		c.setSize(16);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
	    c.setCaption("Central Buyer");
		t.addColumn( c );
		miBUYR_ID = t.getColumnIndex("BUYR_ID");
	c.addProperty("AllowMixedCase", "Y");
		
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("TEAM_ID", DataConst.VARCHAR);
		c.setSize(16);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
	    c.setCaption("Central Buyer Team");
		t.addColumn( c );
		miTEAM_ID = t.getColumnIndex("TEAM_ID");
	c.addProperty("AllowMixedCase", "Y");
		
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("BUYR_NM", DataConst.VARCHAR);
		c.setSize(61);
		c.setAlterability(false);
		c.setNullability(VSMetaColumn.columnNullable);
		c.setComputed (true);
	    c.setCaption("Central Buyer Name");
		t.addColumn( c );
		miBUYR_NM = t.getColumnIndex("BUYR_NM");
	
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("TEAM_NM", DataConst.VARCHAR);
		c.setSize(40);
		c.setAlterability(false);
		c.setNullability(VSMetaColumn.columnNullable);
		c.setComputed (true);
	    c.setCaption("Central Buyer Team Name");
		t.addColumn( c );
		miTEAM_NM = t.getColumnIndex("TEAM_NM");
	
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("AMS_ROW_VERS_NO", DataConst.BIGINT);
		c.setAlterability(false);
		c.setNullability(VSMetaColumn.columnNullable);
	    c.setCaption("");
		t.addColumn( c );
		miAMS_ROW_VERS_NO = t.getColumnIndex("AMS_ROW_VERS_NO");
	
		c = new VSMetaColumn("DLGTD_BUYR_ID", DataConst.VARCHAR);
		c.setSize(16);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
	    c.setCaption("Decentralized Buyer");
		t.addColumn( c );
		miDLGTD_BUYR_ID = t.getColumnIndex("DLGTD_BUYR_ID");
	c.addProperty("AllowMixedCase", "Y");
		
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("DLGTD_TEAM_ID", DataConst.VARCHAR);
		c.setSize(16);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
	    c.setCaption("Decentralized Buyer Team");
		t.addColumn( c );
		miDLGTD_TEAM_ID = t.getColumnIndex("DLGTD_TEAM_ID");
	c.addProperty("AllowMixedCase", "Y");
		
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("DLGTD_TEAM_NM", DataConst.VARCHAR);
		c.setSize(40);
		c.setAlterability(false);
		c.setNullability(VSMetaColumn.columnNullable);
		c.setComputed (true);
	    c.setCaption("Decentralized Buyer Team Name");
		t.addColumn( c );
		miDLGTD_TEAM_NM = t.getColumnIndex("DLGTD_TEAM_NM");
	
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("DLGTD_BUYR_NM", DataConst.VARCHAR);
		c.setSize(61);
		c.setAlterability(false);
		c.setNullability(VSMetaColumn.columnNullable);
		c.setComputed (true);
	    c.setCaption("Decentralized Buyer Name");
		t.addColumn( c );
		miDLGTD_BUYR_NM = t.getColumnIndex("DLGTD_BUYR_NM");
	
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("AR_UNIT_INFR", DataConst.INTEGER);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
		myRequired.addElement("AR_UNIT_INFR");
	    c.setCaption("AR Unit Inference");
		c.setCodeTable("CVL_INFR_DP_UN");
		t.addColumn( c );
		miAR_UNIT_INFR = t.getColumnIndex("AR_UNIT_INFR");
	
		c = new VSMetaColumn("DEPT_SH_NM_UP", DataConst.VARCHAR);
		c.setSize(15);
		c.setAlterability(false);
		c.setNullability(VSMetaColumn.columnNullable);
		c.setComputed (true);
	    c.setCaption("Short Name");
		t.addColumn( c );
		miDEPT_SH_NM_UP = t.getColumnIndex("DEPT_SH_NM_UP");
	
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("DEPT_DSCR_UP", DataConst.VARCHAR);
		c.setSize(100);
		c.setAlterability(false);
		c.setNullability(VSMetaColumn.columnNullable);
		c.setComputed (true);
	    c.setCaption("Description");
		t.addColumn( c );
		miDEPT_DSCR_UP = t.getColumnIndex("DEPT_DSCR_UP");
	
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("REST_BUYR_UNIT", DataConst.INTEGER);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
	    c.setCaption("Reset Unit Buyer");
		c.setCodeTable("CVL_REST_BUYR_UNIT");
		t.addColumn( c );
		miREST_BUYR_UNIT = t.getColumnIndex("REST_BUYR_UNIT");
	
		c = new VSMetaColumn("DISB_CNTAC_CD", DataConst.BIGINT);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
	    c.setCaption("Disbursement Contact Code");
		t.addColumn( c );
		miDISB_CNTAC_CD = t.getColumnIndex("DISB_CNTAC_CD");
	
		c = new VSMetaColumn("DISB_CNTAC_NM", DataConst.VARCHAR);
		c.setSize(60);
		c.setAlterability(false);
		c.setNullability(VSMetaColumn.columnNullable);
		c.setComputed (true);
	    c.setCaption("Disbursement Contact Name");
		t.addColumn( c );
		miDISB_CNTAC_NM = t.getColumnIndex("DISB_CNTAC_NM");
	c.addProperty("AllowMixedCase", "Y");
		
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
		c = new VSMetaColumn("TBL_LAST_DT", DataConst.TIMESTAMP);
		c.setAlterability(false);
		c.setNullability(VSMetaColumn.columnNullable);
	    c.setCaption("Last Modified Date");
		t.addColumn( c );
		miTBL_LAST_DT = t.getColumnIndex("TBL_LAST_DT");
	
		c = new VSMetaColumn("DSCR_EXT", DataConst.LONGVARCHAR);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
	    c.setCaption("Extended Description");
		t.addColumn( c );
		miDSCR_EXT = t.getColumnIndex("DSCR_EXT");
	c.addProperty("AllowMixedCase", "Y");
		
		c = new VSMetaColumn("BASE_DEPT_FL", DataConst.BIT);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
		c.setDefaultValue("false");
	    c.setCaption("Base Department");
		t.addColumn( c );
		miBASE_DEPT_FL = t.getColumnIndex("BASE_DEPT_FL");
	
		c = new VSMetaColumn("TRVL_POL", DataConst.VARCHAR);
		c.setSize(5);
		c.setAlterability(true);
		c.setNullability(VSMetaColumn.columnNullable);
	    c.setCaption("Travel Policy");
		t.addColumn( c );
		miTRVL_POL = t.getColumnIndex("TRVL_POL");
	
		if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.PLS_CASE_LOGIC_ENABLED ||
		     AMSCommonConstants.VLS_TRIM_SPACE_ENABLED ||
		     AMSCommonConstants.PLS_TRIM_SPACE_ENABLED )
		{
			AMSDataObject.initAttrCaseAndTrimProperties( c,
					      moMixedCaseTextAttrsList,
					      moUpperCaseTextAttrsList ) ;
		}
	
		t.addUniqueKeyColumn( "R_DEPT Unique Key", "DEPT_CD" );
	
		// Register a foreign key from  to R_BUYR.
		t.addForeignKeyColumn( "Foreign Key To R_BUYR", "DLGTD_BUYR_ID" );
	
		// Register a foreign key from  to R_WRKLD_TEAMS.
		t.addForeignKeyColumn( "Foreign Key To R_WRKLD_TEAMS", "DLGTD_TEAM_ID" );
	
		// Register a foreign key from  to R_TRVL_POL.
		t.addForeignKeyColumn( "Foreign Key To R_TRVL_POL", "TRVL_POL" );
	
		// Register a foreign key from  to R_CNTAC.
		t.addForeignKeyColumn( "Foreign Key To R_CNTAC", "DISB_CNTAC_CD" );
	
		// Register a foreign key from  to R_WRKLD_TEAMS.
		t.addForeignKeyColumn( "Foreign Key To R_WRKLD_TEAMS", "TEAM_ID" );
	
		// Register a foreign key from  to R_CNTAC.
		t.addForeignKeyColumn( "Foreign Key To R_CNTAC", "CNTAC_CD" );
	
		// Register a foreign key from  to R_BUYR.
		t.addForeignKeyColumn( "Foreign Key To R_BUYR", "BUYR_ID" );
	
	
	
		t.setSchema(" ");
	
		t.useQuotedIdentifier(false);
		t.setOptLock( DataConst.NoOptLocking );
	
	
	      t.setXDAConnectorClassName("advantage.XDASQLCustom");
	
	//END_META_QUERY_COLUMN_CTOR}}
		q.addTable( t );
		q.populateQCArray();
		VSQueryDefinition qTemp = (VSQueryDefinition)getMetaQuery( "R_DEPT",deployedFromRepository ); 
		if ( qTemp == null ) {			
			addMetaQuery(q, deployedFromRepository);
		}					
		else
	   {
			q = qTemp;	// Keep the old query as it has cached object
	   }
		  
	   appObject = AppObjectImpl.getBusinessObject( deployedFromRepository, "R_DEPT", (Session)ServerEnvironment.getServer().getInternalSession());
	   mboolAllowMRTUpdate = new Boolean( appObject.getProperties().getProperty( "AllowMRTUpdate", "false" ) ).booleanValue() ;
	   
	   if( ! AMSDocComponent.class.isAssignableFrom( R_DEPTBaseImpl.class )
	   &&  ! AMSDocHeader   .class.isAssignableFrom( R_DEPTBaseImpl.class )
	   &&  ! AMSDocCatalog  .class.isAssignableFrom( R_DEPTBaseImpl.class ))
	   {
	      /*
	       * DataObject not associated with document and has at least one of two 
	       * effective dating columns defined
	       */       
	      if(getMetaQuery().getMetaColumn( AMSDataObject.EFFECTIVE_DT  ) != null
	      || getMetaQuery().getMetaColumn( AMSDataObject.EXPIRATION_DT ) != null)
	      {
	         enableBehavior(AMSDataObject.AMSBEHAVIOR_EFFECTIVE_DATED);        
	      }
	      else
	      {
	         disableBehavior(AMSDataObject.AMSBEHAVIOR_EFFECTIVE_DATED);            
	      }
	   }
	   else
	   {
	      // DataObject associated with documents
	      disableBehavior(AMSDataObject.AMSBEHAVIOR_EFFECTIVE_DATED);
	   }
	
	   String lsTimeline = getMetaQuery().getProperty( AMSTimelineMaintenance.TIMELINE_DATA ) ;
	
	   if ( ( lsTimeline != null ) && ( lsTimeline.equals( "Y" ) ) )
	   {
	      enableBehavior(AMSDataObject.AMSBEHAVIOR_TIMELINE);
	      msEffDtAttr = getMetaQuery().getProperty( AMSTimelineMaintenance.EFF_DT_ATTR_EXT_PROP ) ;
	      if( msEffDtAttr == null )
	      {
	         msEffDtAttr = AMSTimelineMaintenance.EFFECTIVE_DT_ATTR ;
	      }
	      msExpDtAttr = getMetaQuery().getProperty( AMSTimelineMaintenance.EXP_DT_ATTR_EXT_PROP ) ;
	      if( msExpDtAttr == null )
	      {
	         msExpDtAttr = AMSTimelineMaintenance.EXPIRATION_DT_ATTR ;
	      }
	   }
	   else
	   {
	      disableBehavior(AMSDataObject.AMSBEHAVIOR_TIMELINE);
	   }
	   
	   // Object Attachment type extended property.
	   msObjAttType = getMetaQuery().getProperty( AMSCommonConstants.EXT_PROP_OBJ_ATT_TYPE ) ;
	   
	   // Initialize the log object for this data object
	   moAMSLog = AMSLogger.getLogForBusObj( R_DEPTImpl.class, getMetaQuery() ) ;
	
	
	//END_COMPONENT_META_QRY}}

	//{{COMPONENT_RULES
	
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   


   t.setDerivationType("DEPT_SH_NM_UP", VSMetaColumn.derivationFormula);
   t.setDerivationType("DISB_CNTAC_NM", VSMetaColumn.derivationReplicate);
      t.setIsVirtual("DISB_CNTAC_NM", true);
   t.setDerivationType("ACT_FL", VSMetaColumn.derivationDefault);
   t.setDerivationType("DLGTD_TEAM_NM", VSMetaColumn.derivationReplicate);
      t.setIsVirtual("DLGTD_TEAM_NM", true);
   t.setDerivationType("TEAM_NM", VSMetaColumn.derivationReplicate);
      t.setIsVirtual("TEAM_NM", true);
   t.setDerivationType("BASE_DEPT_FL", VSMetaColumn.derivationDefault);
   t.setDerivationType("DEPT_DSCR_UP", VSMetaColumn.derivationFormula);
   t.setDerivationType("CNTAC_PH_NO", VSMetaColumn.derivationReplicate);
      t.setIsVirtual("CNTAC_PH_NO", true);
   t.setDerivationType("DLGTD_BUYR_NM", VSMetaColumn.derivationReplicate);
      t.setIsVirtual("DLGTD_BUYR_NM", true);
   t.setDerivationType("CNTAC_PERSN", VSMetaColumn.derivationReplicate);
      t.setIsVirtual("CNTAC_PERSN", true);
   t.setDerivationType("BUYR_NM", VSMetaColumn.derivationReplicate);
      t.setIsVirtual("BUYR_NM", true);
   t.setDerivationType("ALW_BUD_FL", VSMetaColumn.derivationDefault);
   t.setDerivationType("CNTAC_PH_EXT", VSMetaColumn.derivationReplicate);
      t.setIsVirtual("CNTAC_PH_EXT", true);
   t.setDerivationType("DEPT_NM_UP", VSMetaColumn.derivationFormula);
   t.setDerivationType("CNTAC_EMAIL", VSMetaColumn.derivationReplicate);
      t.setIsVirtual("CNTAC_EMAIL", true);
String dpndsOn = "";
   dpndsOn = "DEPT_NM_UP";
      t.addDependency(dpndsOn, "DEPT_NM");
   dpndsOn = "DEPT_SH_NM_UP";
      t.addDependency(dpndsOn, "DEPT_SH_NM");
   dpndsOn = "DEPT_DSCR_UP";
      t.addDependency(dpndsOn, "DEPT_DSCR");


   
// Generate static list of code table attribute on this data object
// and the name of the code table being tied to the attribute.
      mhtCodeTable.put( "REST_BUYR_UNIT", "CVL_REST_BUYR_UNIT");
      mhtCodeTable.put( "AR_UNIT_INFR", "CVL_INFR_DP_UN");
 
   
// add default listener for factory events 

// Generate static list of sums on this data object
// and the name of the child attribute being summed.



}

private Vector mvFailedComboExcludeParents = null;
private static boolean mboolInferenceValidationActive = false;
private static boolean mboolInferenceValidationLookup = false;
  

/**     
* <br>
* This method returns a code table that ties to the attribute
* @return String : Returns the code table name.
*/
public String getCodeTableByAttribute( String fsAttribute )
{
   return (String)mhtCodeTable.get( fsAttribute ) ;
}

/**     
* <br>
* This method returns a list of aggregates attributes in this data object
* @return Vector : aggregate column names
*/

public Vector getAggregateColsNameList()
{
   return mvAggregateColsNameList ;
}

/**     
* <br>
* This method returns an object which contains the name of the sum
* field and the name of the field which is being summed. Example
* from budgets would be: Sum field is CHILD_SUM_1; field being
* summed up is ADPT_AM.
*
* @return Hashtable : keyed by name of sum field, value is the field
*                                   being summed up.
*/
public Hashtable getMySums()
{
   return mhtMySums;
}




private boolean _cascade_deleted_in_db = false;
   
public boolean isCascadeDeletedInDB() { return _cascade_deleted_in_db; }
   
public void setCascadeDeletedInDB(boolean val) { _cascade_deleted_in_db = val; }

/**
* Returns the component name for this object, excluding the package
* (see getPackageName()).  For example, it returns 'CUSTOMERS' for the
* Sample Database CUSTOMERS Data Object.
* @return String : Returns the component name.
*/

public String getComponentName() {
   return "R_DEPT";
}

/**     
* <br>
* MetaQuery on the component. This method returns a class defining
* the meta information of the component.
* @return VSMetaQuery : Meta data info class for the component.
*/
public static VSMetaQuery getMetaQuery() 
{
   return q;
}  

/**     
* <br>
* Constructor for the class R_DEPTBaseImpl.
* @param Session session object on which the Business object is created.
* @param boolean if true sets the default values in the data elements
*        as defined in the meta data.
*/
public   R_DEPTBaseImpl(Session session, boolean makeDefaults)
{
   super(session, R_DEPTBaseImpl.getMetaQuery(), makeDefaults);
   addListeners();
   loadBRDParents();
   myInitializations();
   
   // AMS BEGIN : TIMELINE
   if ( isBehaviorEnabled( AMSBEHAVIOR_TIMELINE ) )
   {
       setTimeline( new AMSTimelineMaintenance( this ) ) ;
   }
   // AMS END : TIMELINE
}

/**
*  Read DataObject extended property, set the cache size and expiration time for a perticular Object type
*  This should only be done once per class type, use "initialized" as flag.
*/
public static void initCache() {
   if ( initialized ) return ;
      
   AppObjectImpl appObject = AppObjectImpl.getBusinessObject( deployedFromRepository, "R_DEPT", (Session)ServerEnvironment.getServer().getInternalSession());
   String cSize = appObject.getProperties().getProperty("CacheSize");
   if ( cSize!=null && cSize.trim().length()!=0 )
      cacheSize = Integer.parseInt( cSize );
      
   String expire = appObject.getProperties().getProperty("ExpirationMillis");
   if ( expire!=null && expire.trim().length()!=0 )
      expires = Long.parseLong(expire);

   if ( cacheSize !=0) {
      CacheManager cm = CacheAgent.getCacheAgent().getCache( q );
      cm.setMaxSize( cacheSize );

   }
   //System.err.println( "######:"+ cacheSize+"ex:"+expires);
   initialized = true;
}


/**     
* <br>
* Factory method to get objects based on the filter (SeachRequest), which returns
* an enumeration of objects matching the filter.
* @param searchReq as SearchRequest : the filter as a SearchRequest object.
* @param aSession as Session : object to be associated with the objects.
* @return Enumeration of objects matching the filter criteria.
*/
public static Enumeration getObjects( SearchRequest searchReq, Session aSession )
   throws ServerException
{
   if ( aSession.getSecurityCheck() ) 
   {
      try 
      {
         if (!aSession.getMyPrivilegeToObjectName(DataConst.AppObjectPrivilegeImpl_READ, "R_DEPT", DataConst.AppObjectTypeCodeImpl_BUSINESS_OBJECT)) 
         {
			throw new ServerException("", VSErrors.VSMSG_SecurityNoReadAccess, "business", "R_DEPT","", (String)null);
         }
      }
      catch( VSORBException e ) 
      {
         Util.logWarning(logger, e);         
      }
   }

   raiseBeforeQueryEvent( searchReq, aSession );


   XDAConnector xdac = createXDAConnector(aSession);
   
   if ( !initialized ) 
      initCache();
     
	
   if (aSession.isTransactionInProgress()) 
   {
      Enumeration e = aSession.getTransactionInfo().getObjects(R_DEPTBaseImpl.getMetaQuery(), xdac, searchReq);

      // ******************* cache support
      if ( cacheSize!=0 && e.hasMoreElements()) 
      {
         Vector boList = new Vector();
         while ( e.hasMoreElements()) 
         {
            boList.addElement( e.nextElement());
         }

         CacheAgent.getCacheAgent().setObjects( R_DEPTBaseImpl.getMetaQuery(), boList, expires );
      
         return boList.elements();

      } else
         return e;  
   } 
   else 
   {
      Vector boList = new Vector();
      Connection con = aSession.getConnection( xdac, true );
      ResultSet rs = new VSORBResultSetImpl( R_DEPTBaseImpl.getMetaQuery(), searchReq, null, -1 ,DataConst.NONE_LOB, xdac, con );
      raiseAfterQueryEvent( rs );

      DataRow row  = null ;
      while (  ( row =  rs.fetch() ) != null )
      {   
         DataObject bo = row.getComponent();
         boList.addElement( bo );

      }
      rs.close();
      
      //**************************** cache support
      if ( cacheSize != 0 )
         CacheAgent.getCacheAgent().setObjects( R_DEPTBaseImpl.getMetaQuery(), boList, expires );    

      return boList.elements();
   }
}

/**     
* <br>
* AMS Factory method to get objects sorted based on the filter (SeachRequest), 
* which returns an enumeration of objects matching the filter, attribute(s) to 
* sort by (Vector),
* and sort mode (ASC or DSC).
* @param searchReq as SearchRequest : the filter as a SearchRequest object.
* @param aSession as Session : object to be associated with the objects.
* @param fvAttributes as Vector : list of attribute names to sort on, must be in desired sort order
* @param fiAscDscMode as int : sort mode -> AMSDataObject.SORT_ASC or AMSDataObject.SORT_DSC
* @return Enumeration of sorted objects matching the filter criteria.
*/
public static Enumeration getObjectsSorted( SearchRequest searchReq, 
                                            Session aSession,
                                            Vector fvAttributes, 
                                            int fiAscDscMode  )
                          throws ServerException
{
   Enumeration loEnum       = getObjects( searchReq, aSession ) ;
        Enumeration loSortedEnum = null ;
   
   try
   {
      loSortedEnum = AMSDataObject.sort( loEnum,
               ( fvAttributes == null ) ? new Vector() : fvAttributes,
               fiAscDscMode ) ;
   }
   catch ( Exception ex )
   {
      throw new ServerException( "error in getObjectsSorted() " + 
                                 ex.getMessage() ) ;
    }
   
   return loSortedEnum ;
}


public static void raiseBeforeQueryEvent( SearchRequest searchReq, 
                                          Session aSession )   
{
   beforeQuery( "R_DEPT", searchReq, null , aSession );
}

public static void raiseAfterQueryEvent( ResultSet rs)   
{
   afterQuery( rs );
}

/**     
* <br>
* Factory method to get objects based on the filter (String), which returns
* an enumeration of objects matching the filter.
* @param searchReq as SearchRequest : the filter as a String. (e.g. State = 'NY').
* @param aSession as Session : object to be associated with the objects.
* @return Enumeration of objects matching the filter criteria.
*/
public static Enumeration getObjects(String filter, Session s) 
{
   SearchRequest searchReq = new SearchRequest();
   searchReq.add(filter);
   return getObjects(searchReq, s);
}

/**     
* <br>
* AMS Factory method to get objects sorted based on the filter (String), which returns
* an enumeration of objects matching the filter, attribute names to sort by (Vector),
* and sort mode (ASC or DSC).
* @param filter as String : the filter as a String object.
* @param aSession as Session : object to be associated with the objects.
* @param fvAttributes as Vector : list of attribute names to sort on, must be in desired sort order
* @param fiAscDscMode as int : sort mode -> AMSDataObject.SORT_ASC or AMSDataObject.SORT_DSC
* @return Enumeration of sorted objects matching the filter criteria.
*/
public static Enumeration getObjectsSorted( String filter, Session s,
                                            Vector fvAttributes, 
                                            int fiAscDscMode ) 
{
   SearchRequest searchReq = new SearchRequest();
   searchReq.add(filter);
   return getObjectsSorted(searchReq, s, fvAttributes, fiAscDscMode);
}

/**
* <br>
* Factory method to create an object based on the unique key value which
* returns an object matching the key value.
* @param searchReq as SearchRequest : the key value as a SearchRequest object.
* @param aSession as Session : object to be associated with the objects.
* @return the object matching the Unique key.
*/

public static DataObject getObjectByKey( SearchRequest key, Session aSession )
   throws ServerException
{
   if ( aSession.getSecurityCheck() )
   {
      try
      {
         if (!aSession.getMyPrivilegeToObjectName(DataConst.AppObjectPrivilegeImpl_READ, "R_DEPT", DataConst.AppObjectTypeCodeImpl_BUSINESS_OBJECT))
         {
	     throw new ServerException("", VSErrors.VSMSG_SecurityNoReadAccess, "business", "R_DEPT","", (String)null);
         }
      }

      catch( VSORBException e ) 
      {
         Util.logWarning(logger, e);
      }
   }

   raiseBeforeQueryEvent( key, aSession );
   
   
   if ( !initialized ) 
      initCache();
   
   DataObject anObject = null;
   
   //**************************** cache support
   if ( cacheSize != 0 )    {
      anObject = CacheAgent.getCacheAgent().getObject( R_DEPTBaseImpl.getMetaQuery(),key.parameterList, aSession);
      
      logger.fine(" Cache :"+ anObject);
   // AMS BEGIN : SDO
      //System.err.println( " Cache :"+ anObject );
      if (anObject!=null)  {
         //set current session to this cached object, ensure that object has a active session
         if ( anObject == DataObject.dummy )
         {
            return null;
         }
         anObject.setSession( aSession );
         return anObject;
      }
   // AMS END : SDO
      
      // AMS BEGIN: TIMELINE
      else if ( isBehaviorEnabled( AMSBEHAVIOR_TIMELINE ) )
      {
         return AMSTimelineMaintenance.getObjectByAsOfDate(
                  "R_DEPT", msEffDtAttr, msExpDtAttr, key, aSession) ;
      }
      // AMS END: TIMELINE      
   }
   
   // AMS BEGIN: TIMELINE
   else if ( isBehaviorEnabled( AMSBEHAVIOR_TIMELINE ) )
   {
        return AMSTimelineMaintenance.getObjectByAsOfDate(
                  "R_DEPT", msEffDtAttr, msExpDtAttr, key, aSession) ;
   }
   // AMS END: TIMELINE


   if (aSession.isTransactionInProgress())
   {
      anObject = aSession.getTransactionInfo().getObjectByKey(R_DEPTBaseImpl.getMetaQuery(),key);
   }
   else
   {
      anObject = aSession.getObjectByKey(R_DEPTBaseImpl.getMetaQuery(),key);
   }


   // AMS BEGIN : SDO
   if ( cacheSize != 0 )
   {
      if ( anObject == null )
      {
         CacheAgent.getCacheAgent().addObject(R_DEPTBaseImpl.getMetaQuery(),DataObject.dummy, key.parameterList, expires );
      }
      else
      {
         CacheAgent.getCacheAgent().addObject(R_DEPTBaseImpl.getMetaQuery(),anObject, expires );
      }
   }
   // AMS END : SDO
    
   return anObject;
}

public Hashtable getMixedCaseTextAttrsList()
{
   return moMixedCaseTextAttrsList ;
}

public Hashtable getUpperCaseTextAttrsList()
{
   return moUpperCaseTextAttrsList ;
}

public void save() throws ServerException
{
   // Check if the upper case and trim space logic
   // has to be applied.
   if ( AMSCommonConstants.VLS_CASE_LOGIC_ENABLED ||
        AMSCommonConstants.VLS_TRIM_SPACE_ENABLED )
   {
      applyCaseAndTrimLogicToDataObject(
         getMixedCaseTextAttrsList(),
         getUpperCaseTextAttrsList() ) ;
   }

   if ( mboolCustomDataObjectSave )
   {
      if (myDataObjectSave()) 
      {
         super.save();
      } 
   }
   else
   {
      // AMS BEGIN : TIMELINE
      if ( (isBehaviorEnabled( AMSBEHAVIOR_TIMELINE )) && (getProcessWithBusinessLogic()) )
      {
         getTimeline().maintainTimeline() ;
      }
      // AMS END : TIMELINE
      super.save() ;
   }
}


                  
// Factored out duplicate code passage - Val/Paul 03-17-03
protected void tableConditionActions() {
}


/**
 * Generate a sortable string given a data object name, its AMS Parent Type,
 * and its priority.
 * @param fiType An AMSPARENTTYPE_xxx value.
 * @param fiOrder Parent's priority.
 * @param fsParent Name of parent data object.
 */
private static String generateSortString( int fiType, int fiOrder, String fsParent )
{
   NumberFormat lnf = NumberFormat.getInstance();
   lnf.setMinimumIntegerDigits(2);
   lnf.setMaximumIntegerDigits(2);
   String lsOrder = lnf.format(fiOrder);

   switch(fiType)
   {
      case AMSPARENTTYPE_INFERENCE: 
         return( PRIORITY_INFERENCE + lsOrder + fsParent );
      case AMSPARENTTYPE_REQUIRED_ELEMENTS:
         return( PRIORITY_REQUIRED  + lsOrder + fsParent );
      case AMSPARENTTYPE_COMBO_IN:
         return( PRIORITY_COMBO_IN  + lsOrder + fsParent );
      case AMSPARENTTYPE_COMBO_EX:
         return( PRIORITY_COMBO_EX  + lsOrder + fsParent );
      default:
         return( PRIORITY_OTHER     + lsOrder + fsParent );
   }
} 


private void sortParents()
{
   //
   // Prevent queued threads from resorting if they're waiting
   // during a sort.  Set mboolParentsSorted to false to
   // force a new sort.
   //
   synchronized (msSortParentsSync)
   {
      if(mboolParentsSorted == true)
      {
         return;
      }

      //
      // Generate array of "sort strings" -- concatenation of 
      // order and parent name.  For example, inferences will
      // be generated as "1nnInfParentName" where nn is the 
      // parent's order within inferences.
      //
      msSortedParents = new String [myParents.size()];
      Enumeration lenumParents = this.myParents.elements();
      ParentExtension lpeParent;
      int liCurrIdx = 0;
      while(lenumParents.hasMoreElements())
      {
         lpeParent = (ParentExtension)lenumParents.nextElement();
         msSortedParents[liCurrIdx] = generateSortString( 
            lpeParent.getType(), 
            lpeParent.getPriority(), 
            lpeParent.getParent() );
         ++liCurrIdx;
      }

      if(AMS_DEBUG)
      {   
         String lsTemp = "";
         for(int li = 0; li<msSortedParents.length; ++li) lsTemp += (msSortedParents[li] + ":");
         addTrace("DBG: parents sort array just before sort", lsTemp, Session.INFO_EVENT );
      }

      //
      // Sort array
      // - positions 0-2     descending order (priority prefix)
      // - positions 3-end   ascending  order (parent name)
      //
      int liLen = msSortedParents.length;
      String lsSwap;
      for(int li = 0; li < (liLen - 1); ++li)
      {
         for(int lj = li+1; lj < liLen; ++lj)
         {
            if((msSortedParents[li].substring(0,3).compareTo(msSortedParents[lj].substring(0,3)) <  0)
            || (msSortedParents[li].substring(0,3).compareTo(msSortedParents[lj].substring(0,3)) == 0
            &&  msSortedParents[li].substring(3  ).compareTo(msSortedParents[lj].substring(3  )) >  0))
            {
               lsSwap = msSortedParents[li];
               msSortedParents[li] = msSortedParents[lj];
               msSortedParents[lj] = lsSwap;
            }
         }
      }

      if(AMS_DEBUG)
      {   
         String lsTemp ="";
         for(int li = 0; li<msSortedParents.length; ++li) lsTemp += (msSortedParents[li] + ":");
         addTrace("DBG: parents sort array after sort", lsTemp, Session.INFO_EVENT );
      }

      mboolParentsSorted = true;
   }
}

public void loadBRDParents()
{
      this.registerBRDParent( "R_WRKLD_TEAMS", R_WRKLD_TEAMSImpl.getType() );
      this.registerBRDParent( "R_WRKLD_TEAMS", R_WRKLD_TEAMSImpl.getType() );
      this.registerBRDParent( "R_CNTAC", R_CNTACImpl.getType() );
      this.registerBRDParent( "R_BUYR", R_BUYRImpl.getType() );
      this.registerBRDParent( "R_BUYR", R_BUYRImpl.getType() );
      this.registerBRDParent( "R_TRVL_POL", R_TRVL_POLImpl.getType() );
      this.registerBRDParent( "R_CNTAC", R_CNTACImpl.getType() );
}

private void fireBRDParent( String fsParent ) throws ServerException
{
   if ( isParentCheckEnabled() )
   {
        if(fsParent.compareTo("R_WRKLD_TEAMS") == 0)
        {
           this.parentCheckFor_DelegatedTeam();
        }
        if(fsParent.compareTo("R_WRKLD_TEAMS") == 0)
        {
           this.parentCheckFor_BuyerTeam();
        }
        if(fsParent.compareTo("R_CNTAC") == 0)
        {
           this.parentCheckFor_R_CNTAC28();
        }
        if(fsParent.compareTo("R_BUYR") == 0)
        {
           this.parentCheckFor_DelegatedBuyer();
        }
        if(fsParent.compareTo("R_BUYR") == 0)
        {
           this.parentCheckFor_Buyer();
        }
        if(fsParent.compareTo("R_TRVL_POL") == 0)
        {
           this.parentCheckFor_RdeptToRtrvlPol();
        }
        if(fsParent.compareTo("R_CNTAC") == 0)
        {
           this.parentCheckFor_ContactToDepartment();
        }
   }
}

public void fireIndirectParent( String fsParent )
{
    ParentExtension lpe = (ParentExtension)(this.myParents.get(fsParent));
    if(lpe.isIndirect())
    {
        try
        {
            AMSDataObject loParent    = null;
            SearchRequest lsr         = new SearchRequest();
            Enumeration   lenumKeys   = lpe.getKeyPairs();
            AttributePair lap         = null;
            String        lsParentAttr;
            String        lsChildAttr;

            //
            // Build SearchRequest
            //
            while(lenumKeys.hasMoreElements())
            {
                lap          = (AttributePair)lenumKeys.nextElement();
                lsParentAttr = lap.getAttribute1();
                lsChildAttr  = lap.getAttribute2();
                if(!lap.isSecondConstant() && isNull(lsChildAttr))
                {
                    if(lsr.stringList.size() > 0)
                    {
                        lsr.add( " AND " + lsParentAttr + " IS NULL ");
                    }
                    else
                    {
                        lsr.add( lsParentAttr + " IS NULL ");
                    }
                }
                else
                {
                    Parameter lparam = new Parameter();
                    lparam.objName   = fsParent;
                    lparam.fieldName = lsParentAttr;
                    if(lap.isSecondConstant())
                    {
                        lparam.value = lsChildAttr;
                    }
                    else
                    {
                        lparam.value = getData(lsChildAttr).getString().trim();
                    }
                    lsr.add(lparam);
                }
            }

            //
            // Get parent. We cannot do a getObjectByKey as this is a
            // string based search request. So we will perform a getObjects
            // and then retrieve the first element
            //
            Enumeration loEnum = AMSDataObject.getObjects(fsParent, lsr , this.getSession());
            if (loEnum.hasMoreElements())
            {
               loParent = (AMSDataObject) loEnum.nextElement();
            }
            else
            {
               loParent = null;
            }

            //
            // Replicate
            //
            if(loParent != null)
            {
                Enumeration lenumReplicates = lpe.getReplicates();
                if(lenumReplicates != null)
                {
                    AttributePair lapCurrent;
                    while(lenumReplicates.hasMoreElements())
                    {
                        lapCurrent = (AttributePair)lenumReplicates.nextElement();
                        Data ldataFrom = loParent.getData(lapCurrent.getAttribute1());
                        Data ldataTo   = this.    getData(lapCurrent.getAttribute2());
                        String lsCurrentValue = ldataTo.getString();
                        if(lsCurrentValue == null) lsCurrentValue = "";
                        if((lsCurrentValue.trim()).length() == 0)
                        {
                            ldataTo.setData(ldataFrom);
                            ldataTo.setInitialized(true);
                        }   
                    }
                }
            }
        }
        catch (Exception fex)
        {
            System.err.println(fex.getMessage());
            fex.printStackTrace();    
            this.raiseException( 
                "Error while enforcing custom parent (" 
                + fsParent 
                + "): " 
                + fex.getMessage());
        }
    }
}



private void fireParents() throws ServerException
{
   if(this.myParents.size() <= 0)
   {
      return;
   }

   if(!mboolParentsSorted)
   {
      this.sortParents();
   }

   //
   // Fire enforcements
   //
   String lsCurrentParent;
   
   this.mvFailedComboExcludeParents = null;
   
   
   for(int li = 0; li < msSortedParents.length; ++li)
   {
      lsCurrentParent = msSortedParents[li].substring(3);
      if(isIndirect(lsCurrentParent))
      {
         addTrace( "Firing Indirect Parent: " + lsCurrentParent, "", Session.INFO_EVENT);
         this.fireIndirectParent(lsCurrentParent);
      }
      else
      {
         addTrace( "Firing BRD Parent: " + lsCurrentParent, "", Session.INFO_EVENT);
         this.fireBRDParent(lsCurrentParent);
      }
   }
}

protected void insert() throws ServerException
{
   // AMS BEGIN : SDO
   if ( cacheSize != 0 )
   {
      throw new ServerException( "R_DEPT is cached.  Insert not permitted." ) ; 
   }
   // AMS END : SDO

   if ( isBehaviorEnabled( AMSBEHAVIOR_PROCESS_SENSITIVE ) )
   {
      processInProgressCheck( VLSEvent.BEFORE_INSERT ) ;
   }

   // Process insert with business rules?
   if ( !getProcessWithBusinessLogic() )
   {
      // No, so just save the component and exit
      this.updateRowImmediate() ;
      return ;
   }

   // Post Rule Event
   postRuleEvent(VLSEvent.BEFORE_INSERT, response.reset());
   
   if (response.rejected()) 
   {
      return;
   }
   
      // Generate Columns Default code here.
         if ( isNull("ACT_FL") ) 
            setACT_FL((boolean)( true ));
         if ( isNull("BASE_DEPT_FL") ) 
            setBASE_DEPT_FL((boolean)( false ));
         if ( isNull("ALW_BUD_FL") ) 
            setALW_BUD_FL((boolean)( true ));

   if (isParentReplicationRequired())
   {
      this.fireParents();
      this.notifyAfterFireParents();
   }


      if (isFormulaRequired())
      {
         // Set the formulae values at this point
         this.setFormulaValues();
      }

   
   // AMS BEGIN : TIMELINE
   //Generate error messages if persistent counts/sums are being used. 
   if(isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))
   {
            
            
            
            
            
            
            
            
            
   }
   // AMS END : TIMELINE

   
   if(isValidationRequired())
    {
   
         // At this point do code table constraint validation.
            if (!( isNull("REST_BUYR_UNIT") ))
            {
               this.codeTableCheck("REST_BUYR_UNIT");
            }
            if (!( isNull("AR_UNIT_INFR") ))
            {
               this.codeTableCheck("AR_UNIT_INFR");
            }
   
      //
      // Any required attributes missing?
      //
      if(this.columnRequiredCheck())
      {
         //
         // Cut directly to the commit attempt and don't do any more validations.  
         //
         this.updateRowImmediate();
         return;
      }
   
      // Do Column Validation Checks
      this.columnValidationCheck();

      // Do TableConstraintChecks
         this.tableConstraintCheck();
   

      // Now verify that not nullable columns are not null.


            if ( isNull("ACT_FL") )
            {
            // Raise the exception here.
            raiseException("Attribute 'R_DEPT.ACT_FL' does not allow Null Values.","R_DEPT","ACT_FL");

            }








            if ( isNull("ALW_BUD_FL") )
            {
            // Raise the exception here.
            raiseException("Attribute 'R_DEPT.ALW_BUD_FL' does not allow Null Values.","R_DEPT","ALW_BUD_FL");

            }



   }

   // Check insert security for this data object
   if( mboolCheckInsertSecurity )
   {
      checkInsertSecurity() ;
   }

   // Adds the data object to the write cache so any queries for it
   // will return the current instance of the data object
   getSession().getTransactionInfo().save(this);

   if(isMediatorRequired())
   {
      invokeMediator();
   }
   if(isSecondaryMediatorRequired())
   {
      invokeSecondaryMediator();
   }
   // Factored out duplicate code passage - Val/Paul 03-17-03
   this.tableConditionActions();
   
   // At this point all the computations for the object attributes have been made,
   // therefore save the object.   
   this.updateRowImmediate();


   notifyBeforeChildAdjustments() ;


   if ( mboolPerformCascade )
   {
      // Do Child Cascades.
      
         // Child Cascade for Role prgoingToDeptCA(R_DEPT)-DeptCAToARRADocOngoing(ARRA_DOC_ONGOING): R_DEPT->>ARRA_DOC_ONGOING
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ARRA_DOC_ONGOINGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ARRA_DOC_ONGOINGImpl.class ) )
         {
            this.childCascadeFor_DeptCAToARRADocOngoing();
         }
         // Child Cascade for Role prgDocToDept(R_DEPT)-DeptToCAMMjrProgDoc(CAM_DOC_MJRPROG): R_DEPT->>CAM_DOC_MJRPROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CAM_DOC_MJRPROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CAM_DOC_MJRPROGImpl.class ) )
         {
            this.childCascadeFor_DeptToCAMMjrProgDoc();
         }
         // Child Cascade for Role prgDocToDept(R_DEPT)-DeptToCASMjrProgDoc(CAS_DOC_MJRPROG): R_DEPT->>CAS_DOC_MJRPROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CAS_DOC_MJRPROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CAS_DOC_MJRPROGImpl.class ) )
         {
            this.childCascadeFor_DeptToCASMjrProgDoc();
         }
         // Child Cascade for Role pr_DEPT)-CVEX_FUND_DEPTs(CVEX_FUND_DEPT): R_DEPT->>CVEX_FUND_DEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CVEX_FUND_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CVEX_FUND_DEPTImpl.class ) )
         {
            this.childCascadeFor_CVEX_FUND_DEPTs();
         }
         // Child Cascade for Role pr_DEPT)-CVIN_FUND_DEPTs(CVIN_FUND_DEPT): R_DEPT->>CVIN_FUND_DEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CVIN_FUND_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CVIN_FUND_DEPTImpl.class ) )
         {
            this.childCascadeFor_CVIN_FUND_DEPTs();
         }
         // Child Cascade for Role pr4L3ReqToRDept(R_DEPT)-RDeptToCvinStru44L3Req(CVIN_STRU44L3_REQ): R_DEPT->>CVIN_STRU44L3_REQ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CVIN_STRU44L3_REQImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CVIN_STRU44L3_REQImpl.class ) )
         {
            this.childCascadeFor_RDeptToCvinStru44L3Req();
         }
         // Child Cascade for Role pr5L3ReqToDept(R_DEPT)-DeptToCvinStru45L3Req(CVIN_STRU45L3_REQ): R_DEPT->>CVIN_STRU45L3_REQ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CVIN_STRU45L3_REQImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CVIN_STRU45L3_REQImpl.class ) )
         {
            this.childCascadeFor_DeptToCvinStru45L3Req();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToUnitProg(CVIN_UNIT_PROG): R_DEPT->>CVIN_UNIT_PROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CVIN_UNIT_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CVIN_UNIT_PROGImpl.class ) )
         {
            this.childCascadeFor_DeptToUnitProg();
         }
         // Child Cascade for Role pr_DEPT)-DOC_COAs28(DOC_COA): R_DEPT->>DOC_COA
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(DOC_COAImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( DOC_COAImpl.class ) )
         {
            this.childCascadeFor_DOC_COAs28();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptDocIntCoa(DOC_INT_COA): R_DEPT->>DOC_INT_COA
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(DOC_INT_COAImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( DOC_INT_COAImpl.class ) )
         {
            this.childCascadeFor_DeptDocIntCoa();
         }
         // Child Cascade for Role prToRDept(R_DEPT)-RDeptToGtDocComn(GT_DOC_COMN): R_DEPT->>GT_DOC_COMN
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_COMNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_COMNImpl.class ) )
         {
            this.childCascadeFor_RDeptToGtDocComn();
         }
         // Child Cascade for Role prfUsrToDept(R_DEPT)-DeptToGtDocNotifUsr(GT_DOC_NOTIFUSR): R_DEPT->>GT_DOC_NOTIFUSR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_NOTIFUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_NOTIFUSRImpl.class ) )
         {
            this.childCascadeFor_DeptToGtDocNotifUsr();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToGtDocOpty(GT_DOC_OPTY): R_DEPT->>GT_DOC_OPTY
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_OPTYImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_OPTYImpl.class ) )
         {
            this.childCascadeFor_DeptToGtDocOpty();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToGtDocResp(GT_DOC_RESP): R_DEPT->>GT_DOC_RESP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_RESPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_RESPImpl.class ) )
         {
            this.childCascadeFor_DeptToGtDocResp();
         }
         // Child Cascade for Role prncOtypToDept(R_DEPT)-DeptToInfApprFuncOtyp(INF_APPR_FUNC_OTYP): R_DEPT->>INF_APPR_FUNC_OTYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_APPR_FUNC_OTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_APPR_FUNC_OTYPImpl.class ) )
         {
            this.childCascadeFor_DeptToInfApprFuncOtyp();
         }
         // Child Cascade for Role prcApprInf(R_DEPT)-RsrcApprInfRecs(INF_APPR_RSRC): R_DEPT->>INF_APPR_RSRC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_APPR_RSRCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_APPR_RSRCImpl.class ) )
         {
            this.childCascadeFor_RsrcApprInfRecs();
         }
         // Child Cascade for Role pr_DEPT)-INF_BFYs1(INF_BFY): R_DEPT->>INF_BFY
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_BFYImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_BFYImpl.class ) )
         {
            this.childCascadeFor_INF_BFYs1();
         }
         // Child Cascade for Role prDeptUnit(R_DEPT)-InfDeptUnitToDept(INF_DEPT_UNIT): R_DEPT->>INF_DEPT_UNIT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_DEPT_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_DEPT_UNITImpl.class ) )
         {
            this.childCascadeFor_InfDeptUnitToDept();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToInfFpi6(INF_FPI_6): R_DEPT->>INF_FPI_6
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPI_6Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPI_6Impl.class ) )
         {
            this.childCascadeFor_DeptToInfFpi6();
         }
         // Child Cascade for Role pr_DEPT)-INF_FPRL_12(INF_FPRL_1): R_DEPT->>INF_FPRL_1
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPRL_1Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPRL_1Impl.class ) )
         {
            this.childCascadeFor_INF_FPRL_12();
         }
         // Child Cascade for Role prR_DEPT)-INF_FPRL_21(INF_FPRL_2): R_DEPT->>INF_FPRL_2
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPRL_2Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPRL_2Impl.class ) )
         {
            this.childCascadeFor_INF_FPRL_21();
         }
         // Child Cascade for Role prR_DEPT)-INF_FPRL_32(INF_FPRL_3): R_DEPT->>INF_FPRL_3
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPRL_3Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPRL_3Impl.class ) )
         {
            this.childCascadeFor_INF_FPRL_32();
         }
         // Child Cascade for Role prFprfl4(R_DEPT)-InfFprfl4Recs(INF_FPRL_4): R_DEPT->>INF_FPRL_4
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPRL_4Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPRL_4Impl.class ) )
         {
            this.childCascadeFor_InfFprfl4Recs();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToInfFprl5(INF_FPRL_5): R_DEPT->>INF_FPRL_5
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPRL_5Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPRL_5Impl.class ) )
         {
            this.childCascadeFor_DeptToInfFprl5();
         }
         // Child Cascade for Role proRDept(R_DEPT)-RDeptToInfFprlO(INF_FPRL_O): R_DEPT->>INF_FPRL_O
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPRL_OImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPRL_OImpl.class ) )
         {
            this.childCascadeFor_RDeptToInfFprlO();
         }
         // Child Cascade for Role prtToLcnToDept(R_DEPT)-DeptToInfFprlActToLcn(INF_FPRL_ACTV_LOC): R_DEPT->>INF_FPRL_ACTV_LOC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPRL_ACTV_LOCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPRL_ACTV_LOCImpl.class ) )
         {
            this.childCascadeFor_DeptToInfFprlActToLcn();
         }
         // Child Cascade for Role prndProgToDept(R_DEPT)-DeptToInfFuncFundProg(INF_FUNC_FUND_PROG): R_DEPT->>INF_FUNC_FUND_PROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FUNC_FUND_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FUNC_FUND_PROGImpl.class ) )
         {
            this.childCascadeFor_DeptToInfFuncFundProg();
         }
         // Child Cascade for Role prR_DEPT)-INF_FUND_FUNC_ACTVs1(INF_FUND_FUNC_ACTV): R_DEPT->>INF_FUND_FUNC_ACTV
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FUND_FUNC_ACTVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FUND_FUNC_ACTVImpl.class ) )
         {
            this.childCascadeFor_INF_FUND_FUNC_ACTVs1();
         }
         // Child Cascade for Role prI(R_DEPT)-GFPIToDept(INF_GRNT_FP): R_DEPT->>INF_GRNT_FP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_GRNT_FPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_GRNT_FPImpl.class ) )
         {
            this.childCascadeFor_GFPIToDept();
         }
         // Child Cascade for Role prObjOtyp(R_DEPT)-InfObjOtypToDept(INF_OBJ_OTYP): R_DEPT->>INF_OBJ_OTYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_OBJ_OTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_OBJ_OTYPImpl.class ) )
         {
            this.childCascadeFor_InfObjOtypToDept();
         }
         // Child Cascade for Role prR_DEPT)-INF_PHASE_PROGs(INF_PHASE_PROG): R_DEPT->>INF_PHASE_PROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_PHASE_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_PHASE_PROGImpl.class ) )
         {
            this.childCascadeFor_INF_PHASE_PROGs();
         }
         // Child Cascade for Role prI(R_DEPT)-PFPIToDept(INF_PROJ_FP): R_DEPT->>INF_PROJ_FP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_PROJ_FPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_PROJ_FPImpl.class ) )
         {
            this.childCascadeFor_PFPIToDept();
         }
         // Child Cascade for Role prSrcInf(R_DEPT)-RevSrcInfToDept(INF_REV_SRC): R_DEPT->>INF_REV_SRC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_REV_SRCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_REV_SRCImpl.class ) )
         {
            this.childCascadeFor_RevSrcInfToDept();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToInfUnit(INF_UNIT): R_DEPT->>INF_UNIT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_UNITImpl.class ) )
         {
            this.childCascadeFor_DeptToInfUnit();
         }
         // Child Cascade for Role prtDept(R_DEPT)-DeptMaAuthDept(MA_DOC_AUTHDEPT): R_DEPT->>MA_DOC_AUTHDEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(MA_DOC_AUTHDEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( MA_DOC_AUTHDEPTImpl.class ) )
         {
            this.childCascadeFor_DeptMaAuthDept();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToActgPrfl(R_ACTG_PRFL): R_DEPT->>R_ACTG_PRFL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ACTG_PRFLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ACTG_PRFLImpl.class ) )
         {
            this.childCascadeFor_DeptToActgPrfl();
         }
         // Child Cascade for Role prR_DEPT)-R_ACTG_TMPLs(R_ACTG_TMPL): R_DEPT->>R_ACTG_TMPL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ACTG_TMPLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ACTG_TMPLImpl.class ) )
         {
            this.childCascadeFor_R_ACTG_TMPLs();
         }
         // Child Cascade for Role prtToDept(R_DEPT)-DeptToStructDept(R_ALT_ORG_STRUCT): R_DEPT->>R_ALT_ORG_STRUCT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ALT_ORG_STRUCTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ALT_ORG_STRUCTImpl.class ) )
         {
            this.childCascadeFor_DeptToStructDept();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToApCwHdr(R_AP_CW_HDR): R_DEPT->>R_AP_CW_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_CW_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_CW_HDRImpl.class ) )
         {
            this.childCascadeFor_DeptToApCwHdr();
         }
         // Child Cascade for Role prR_DEPT)-R_AP_INCT_RQSTs2(R_AP_INCT_RQST): R_DEPT->>R_AP_INCT_RQST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_INCT_RQSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_INCT_RQSTImpl.class ) )
         {
            this.childCascadeFor_R_AP_INCT_RQSTs2();
         }
         // Child Cascade for Role proRDept(R_DEPT)-RDeptToRApdDept(R_APD_DEPT): R_DEPT->>R_APD_DEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_APD_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_APD_DEPTImpl.class ) )
         {
            this.childCascadeFor_RDeptToRApdDept();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToCitedAuth(R_CITED_AUTH): R_DEPT->>R_CITED_AUTH
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CITED_AUTHImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CITED_AUTHImpl.class ) )
         {
            this.childCascadeFor_DeptToCitedAuth();
         }
         // Child Cascade for Role prpt(R_DEPT)-DeptToCntac(R_CNTAC): R_DEPT->>R_CNTAC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CNTACImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CNTACImpl.class ) )
         {
            this.childCascadeFor_DeptToCntac();
         }
         // Child Cascade for Role prR_DEPT)-R_COMM_FA_THLDs1(R_COMM_FA_THLD): R_DEPT->>R_COMM_FA_THLD
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_COMM_FA_THLDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_COMM_FA_THLDImpl.class ) )
         {
            this.childCascadeFor_R_COMM_FA_THLDs1();
         }
         // Child Cascade for Role prR_DEPT)-R_COMM_OBJs1(R_COMM_OBJ): R_DEPT->>R_COMM_OBJ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_COMM_OBJImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_COMM_OBJImpl.class ) )
         {
            this.childCascadeFor_R_COMM_OBJs1();
         }
         // Child Cascade for Role prept(R_DEPT)-DeptToDeptFY(R_DEPT_FY): R_DEPT->>R_DEPT_FY
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DEPT_FYImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DEPT_FYImpl.class ) )
         {
            this.childCascadeFor_DeptToDeptFY();
         }
         // Child Cascade for Role prymtCtrlToRDept(R_DEPT)-RDeptToRDeptObjPymtCtrl(R_DEPT_OBJ_PYCTRL): R_DEPT->>R_DEPT_OBJ_PYCTRL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DEPT_OBJ_PYCTRLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DEPT_OBJ_PYCTRLImpl.class ) )
         {
            this.childCascadeFor_RDeptToRDeptObjPymtCtrl();
         }
         // Child Cascade for Role prept(R_DEPT)-DeptToDISCIV(R_DISCIV): R_DEPT->>R_DISCIV
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DISCIVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DISCIVImpl.class ) )
         {
            this.childCascadeFor_DeptToDISCIV();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToDrwdwnGrp(R_DRWDWN_GRP): R_DEPT->>R_DRWDWN_GRP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DRWDWN_GRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DRWDWN_GRPImpl.class ) )
         {
            this.childCascadeFor_DeptToDrwdwnGrp();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToEscrowDef(R_ESCROW_DEF): R_DEPT->>R_ESCROW_DEF
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ESCROW_DEFImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ESCROW_DEFImpl.class ) )
         {
            this.childCascadeFor_DeptToEscrowDef();
         }
         // Child Cascade for Role prRDept(R_DEPT)-RDeptToRFesReq(R_FESREQ): R_DEPT->>R_FESREQ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FESREQImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FESREQImpl.class ) )
         {
            this.childCascadeFor_RDeptToRFesReq();
         }
         // Child Cascade for Role prcToRDept(R_DEPT)-RDeptToRFndgAlloc(R_FNDG_ALLOC): R_DEPT->>R_FNDG_ALLOC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FNDG_ALLOCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FNDG_ALLOCImpl.class ) )
         {
            this.childCascadeFor_RDeptToRFndgAlloc();
         }
         // Child Cascade for Role prRDept(R_DEPT)-RDeptToRFyDept(R_FY_DEPT): R_DEPT->>R_FY_DEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FY_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FY_DEPTImpl.class ) )
         {
            this.childCascadeFor_RDeptToRFyDept();
         }
         // Child Cascade for Role prToRDept(R_DEPT)-RDeptToRGrntAppl(R_GRNT_APPL): R_DEPT->>R_GRNT_APPL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_APPLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_APPLImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntAppl();
         }
         // Child Cascade for Role prplToRDept(R_DEPT)-RDeptToRGrntDtTmpl(R_GRNT_DT_TMPL): R_DEPT->>R_GRNT_DT_TMPL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_DT_TMPLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_DT_TMPLImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntDtTmpl();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToGrntOpty(R_GRNT_OPTY): R_DEPT->>R_GRNT_OPTY
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_OPTYImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_OPTYImpl.class ) )
         {
            this.childCascadeFor_DeptToGrntOpty();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToGrntResp(R_GRNT_RESP): R_DEPT->>R_GRNT_RESP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_RESPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_RESPImpl.class ) )
         {
            this.childCascadeFor_DeptToGrntResp();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToGrntUser(R_GRNT_USER): R_DEPT->>R_GRNT_USER
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_USERImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_USERImpl.class ) )
         {
            this.childCascadeFor_DeptToGrntUser();
         }
         // Child Cascade for Role prDEPT)-R_INTG_CTRL(R_INTG_CTRL): R_DEPT->>R_INTG_CTRL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_INTG_CTRLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_INTG_CTRLImpl.class ) )
         {
            this.childCascadeFor_R_INTG_CTRL();
         }
         // Child Cascade for Role prR_DEPT)-R_MJR_PROGs3(R_MJR_PROG): R_DEPT->>R_MJR_PROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_MJR_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_MJR_PROGImpl.class ) )
         {
            this.childCascadeFor_R_MJR_PROGs3();
         }
         // Child Cascade for Role prardInfoToDepartment(R_DEPT)-DepartmentToOnGoingAwardInfo(R_ONGOING_AWD_INFO): R_DEPT->>R_ONGOING_AWD_INFO
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ONGOING_AWD_INFOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ONGOING_AWD_INFOImpl.class ) )
         {
            this.childCascadeFor_DepartmentToOnGoingAwardInfo();
         }
         // Child Cascade for Role prt(R_DEPT)-PerfEvalEvaluator(R_PE_EVALR): R_DEPT->>R_PE_EVALR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PE_EVALRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PE_EVALRImpl.class ) )
         {
            this.childCascadeFor_PerfEvalEvaluator();
         }
         // Child Cascade for Role prt(R_DEPT)-StateInstances(R_PRCU_ST): R_DEPT->>R_PRCU_ST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PRCU_STImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PRCU_STImpl.class ) )
         {
            this.childCascadeFor_StateInstances();
         }
         // Child Cascade for Role prDeptToRDept(R_DEPT)-RDeptToRPayHldByDept(R_PYMT_HLD_TYP_DPT): R_DEPT->>R_PYMT_HLD_TYP_DPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PYMT_HLD_TYP_DPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PYMT_HLD_TYP_DPTImpl.class ) )
         {
            this.childCascadeFor_RDeptToRPayHldByDept();
         }
         // Child Cascade for Role prR_DEPT)-R_STPF(R_STPF): R_DEPT->>R_STPF
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_STPFImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_STPFImpl.class ) )
         {
            this.childCascadeFor_R_STPF();
         }
         // Child Cascade for Role prt(R_DEPT)-UniversalRequestorControls(R_UR_CTRL): R_DEPT->>R_UR_CTRL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_UR_CTRLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_UR_CTRLImpl.class ) )
         {
            this.childCascadeFor_UniversalRequestorControls();
         }
         // Child Cascade for Role prrGrpTmpl(R_DEPT)-UserGrpTmplToDept(R_USER_GRP_TMPL): R_DEPT->>R_USER_GRP_TMPL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_USER_GRP_TMPLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_USER_GRP_TMPLImpl.class ) )
         {
            this.childCascadeFor_UserGrpTmplToDept();
         }
         // Child Cascade for Role prR_DEPT)-R_VEND_LSTs2(R_VEND_LST): R_DEPT->>R_VEND_LST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_VEND_LSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_VEND_LSTImpl.class ) )
         {
            this.childCascadeFor_R_VEND_LSTs2();
         }
         // Child Cascade for Role prR_DEPT)-REQ_ACTV_SACTVs(REQ_ACTV_SACTV): R_DEPT->>REQ_ACTV_SACTV
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_ACTV_SACTVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_ACTV_SACTVImpl.class ) )
         {
            this.childCascadeFor_REQ_ACTV_SACTVs();
         }
         // Child Cascade for Role prR_DEPT)-REQ_DEPT_OBJ_REVs(REQ_DEPT_OBJ_REV): R_DEPT->>REQ_DEPT_OBJ_REV
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_DEPT_OBJ_REVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_DEPT_OBJ_REVImpl.class ) )
         {
            this.childCascadeFor_REQ_DEPT_OBJ_REVs();
         }
         // Child Cascade for Role prqFundDept(R_DEPT)-ReqFundDeptToRDept(REQ_FUND_DEPT): R_DEPT->>REQ_FUND_DEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_FUND_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_FUND_DEPTImpl.class ) )
         {
            this.childCascadeFor_ReqFundDeptToRDept();
         }
         // Child Cascade for Role prR_DEPT)-REQ_FUND_UNIT_OBJs(REQ_FUND_UNIT_OBJ): R_DEPT->>REQ_FUND_UNIT_OBJ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_FUND_UNIT_OBJImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_FUND_UNIT_OBJImpl.class ) )
         {
            this.childCascadeFor_REQ_FUND_UNIT_OBJs();
         }
         // Child Cascade for Role prR_DEPT)-REQ_FUND_UNIT_RSRCs(REQ_FUND_UNIT_RSRC): R_DEPT->>REQ_FUND_UNIT_RSRC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_FUND_UNIT_RSRCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_FUND_UNIT_RSRCImpl.class ) )
         {
            this.childCascadeFor_REQ_FUND_UNIT_RSRCs();
         }
         // Child Cascade for Role prR_DEPT)-REQ_UNITs(REQ_UNIT): R_DEPT->>REQ_UNIT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_UNITImpl.class ) )
         {
            this.childCascadeFor_REQ_UNITs();
         }
         // Child Cascade for Role progToDept(R_DEPT)-DeptToReqUnitProg(REQ_UNIT_PROG): R_DEPT->>REQ_UNIT_PROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_UNIT_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_UNIT_PROGImpl.class ) )
         {
            this.childCascadeFor_DeptToReqUnitProg();
         }
         // Child Cascade for Role prR_DEPT)-REQ_UNIT_SUNITs(REQ_UNIT_SUNIT): R_DEPT->>REQ_UNIT_SUNIT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_UNIT_SUNITImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_UNIT_SUNITImpl.class ) )
         {
            this.childCascadeFor_REQ_UNIT_SUNITs();
         }
         // Child Cascade for Role prtParm(R_DEPT)-R_OTPT_PARM_DETs3(R_OTPT_PARM_DET): R_DEPT->>R_OTPT_PARM_DET
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_OTPT_PARM_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_OTPT_PARM_DETImpl.class ) )
         {
            this.childCascadeFor_R_OTPT_PARM_DETs3();
         }
         // Child Cascade for Role prtSchedToRDept2(R_DEPT)-RDeptToRGrntrEvntSched2(R_GRNTR_EVNT_SCHED): R_DEPT->>R_GRNTR_EVNT_SCHED
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNTR_EVNT_SCHEDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNTR_EVNT_SCHEDImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntrEvntSched2();
         }
         // Child Cascade for Role prFaroParm(R_DEPT)-R_FARO_PARMs3(R_FARO_PARM): R_DEPT->>R_FARO_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FARO_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FARO_PARMImpl.class ) )
         {
            this.childCascadeFor_R_FARO_PARMs3();
         }
         // Child Cascade for Role prept1(R_DEPT)-DeptToClmtrk1(R_CLMTRK): R_DEPT->>R_CLMTRK
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CLMTRKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CLMTRKImpl.class ) )
         {
            this.childCascadeFor_DeptToClmtrk1();
         }
         // Child Cascade for Role prMgmtUsrToRDept(R_DEPT)-RDeptToGtDocProgMgmtUsr(GT_DOC_PMGMTUSR): R_DEPT->>GT_DOC_PMGMTUSR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_PMGMTUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_PMGMTUSRImpl.class ) )
         {
            this.childCascadeFor_RDeptToGtDocProgMgmtUsr();
         }
         // Child Cascade for Role prDEPT)-ACRL_CLR_EXCL(ACRL_CLR_EXCL): R_DEPT->>ACRL_CLR_EXCL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ACRL_CLR_EXCLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ACRL_CLR_EXCLImpl.class ) )
         {
            this.childCascadeFor_ACRL_CLR_EXCL();
         }
         // Child Cascade for Role prDEPT)-RQ_DOC_CMPSHT(RQ_DOC_CMPSHT): R_DEPT->>RQ_DOC_CMPSHT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(RQ_DOC_CMPSHTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( RQ_DOC_CMPSHTImpl.class ) )
         {
            this.childCascadeFor_RQ_DOC_CMPSHT();
         }
         // Child Cascade for Role prR_DEPT)-R_MJR_PGRPs1(R_MJR_PGRP): R_DEPT->>R_MJR_PGRP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_MJR_PGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_MJR_PGRPImpl.class ) )
         {
            this.childCascadeFor_R_MJR_PGRPs1();
         }
         // Child Cascade for Role prIntrActg(R_DEPT)-IntrActgToDocDept(R_INTR_ACTG_CRSWLK): R_DEPT->>R_INTR_ACTG_CRSWLK
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_INTR_ACTG_CRSWLKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_INTR_ACTG_CRSWLKImpl.class ) )
         {
            this.childCascadeFor_IntrActgToDocDept();
         }
         // Child Cascade for Role prpat(R_DEPT)-FacpatToDept(R_FACPAT): R_DEPT->>R_FACPAT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FACPATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FACPATImpl.class ) )
         {
            this.childCascadeFor_FacpatToDept();
         }
         // Child Cascade for Role prpad(R_DEPT)-FacpadToDept(R_FACPAD): R_DEPT->>R_FACPAD
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FACPADImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FACPADImpl.class ) )
         {
            this.childCascadeFor_FacpadToDept();
         }
         // Child Cascade for Role prR_DEPT)-R_DOCATs1(R_DOCAT): R_DEPT->>R_DOCAT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DOCATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DOCATImpl.class ) )
         {
            this.childCascadeFor_R_DOCATs1();
         }
         // Child Cascade for Role prpnd_RDept(R_DEPT)-RDept_RBfyStpfSpnd(R_BFY_STPF_SPND): R_DEPT->>R_BFY_STPF_SPND
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_BFY_STPF_SPNDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_BFY_STPF_SPNDImpl.class ) )
         {
            this.childCascadeFor_RDept_RBfyStpfSpnd();
         }
         // Child Cascade for Role prR_DEPT)-R_AP_DISB_PARMs3(R_AP_DISB_PARM): R_DEPT->>R_AP_DISB_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_DISB_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_DISB_PARMImpl.class ) )
         {
            this.childCascadeFor_R_AP_DISB_PARMs3();
         }
         // Child Cascade for Role prcHdr(R_DEPT)-MMRDocHdrDept(MMR_DOC_HDR): R_DEPT->>MMR_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(MMR_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( MMR_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_MMRDocHdrDept();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToMaSrtyIns(MA_DOC_SRTYINS): R_DEPT->>MA_DOC_SRTYINS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(MA_DOC_SRTYINSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( MA_DOC_SRTYINSImpl.class ) )
         {
            this.childCascadeFor_DeptToMaSrtyIns();
         }
         // Child Cascade for Role prdCToDept(R_DEPT)-DeptToFndCDocFndC(FNDC_DOC_FNDC): R_DEPT->>FNDC_DOC_FNDC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(FNDC_DOC_FNDCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( FNDC_DOC_FNDCImpl.class ) )
         {
            this.childCascadeFor_DeptToFndCDocFndC();
         }
         // Child Cascade for Role prToRqstDept(R_DEPT)-RqstDeptToCMRDocHdr(CMR_DOC_HDR): R_DEPT->>CMR_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CMR_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CMR_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_RqstDeptToCMRDocHdr();
         }
         // Child Cascade for Role prR_DEPT)-R_TASKs1(R_TASK): R_DEPT->>R_TASK
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_TASKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_TASKImpl.class ) )
         {
            this.childCascadeFor_R_TASKs1();
         }
         // Child Cascade for Role prnToRDept(R_DEPT)-RDeptToRPayHldTin(R_PYMT_HLD_TIN): R_DEPT->>R_PYMT_HLD_TIN
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PYMT_HLD_TINImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PYMT_HLD_TINImpl.class ) )
         {
            this.childCascadeFor_RDeptToRPayHldTin();
         }
         // Child Cascade for Role prpt(R_DEPT)-RDeptToRFsc(R_FSC): R_DEPT->>R_FSC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FSCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FSCImpl.class ) )
         {
            this.childCascadeFor_RDeptToRFsc();
         }
         // Child Cascade for Role prDEPT)-R_FIN_CHRG_SETP(R_FIN_CHRG_SETP): R_DEPT->>R_FIN_CHRG_SETP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FIN_CHRG_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FIN_CHRG_SETPImpl.class ) )
         {
            this.childCascadeFor_R_FIN_CHRG_SETP();
         }
         // Child Cascade for Role prFaroParm(R_DEPT)-R_FARO_PARMs2(R_FARO_PARM): R_DEPT->>R_FARO_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FARO_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FARO_PARMImpl.class ) )
         {
            this.childCascadeFor_R_FARO_PARMs2();
         }
         // Child Cascade for Role prnToRDept1(R_DEPT)-RDeptToRCntrcGlln1(R_CNTRC_GOAL_LN): R_DEPT->>R_CNTRC_GOAL_LN
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CNTRC_GOAL_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CNTRC_GOAL_LNImpl.class ) )
         {
            this.childCascadeFor_RDeptToRCntrcGlln1();
         }
         // Child Cascade for Role prsa_RDept(R_DEPT)-RDept_RBfyStpfBsa(R_BFY_STPF_BSA): R_DEPT->>R_BFY_STPF_BSA
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_BFY_STPF_BSAImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_BFY_STPF_BSAImpl.class ) )
         {
            this.childCascadeFor_RDept_RBfyStpfBsa();
         }
         // Child Cascade for Role proRDept(R_DEPT)-RDeptToRAdcParm(R_ADC_PARM): R_DEPT->>R_ADC_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ADC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ADC_PARMImpl.class ) )
         {
            this.childCascadeFor_RDeptToRAdcParm();
         }
         // Child Cascade for Role prrUsrToRDept(R_DEPT)-RDeptToGtDocPrtnrUsr(GT_DOC_PRTNRUSR): R_DEPT->>GT_DOC_PRTNRUSR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_PRTNRUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_PRTNRUSRImpl.class ) )
         {
            this.childCascadeFor_RDeptToGtDocPrtnrUsr();
         }
         // Child Cascade for Role prarmToRdept(R_DEPT)-RdeptToCsalProcParm(CSAL_PROC_PARM): R_DEPT->>CSAL_PROC_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CSAL_PROC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CSAL_PROC_PARMImpl.class ) )
         {
            this.childCascadeFor_RdeptToCsalProcParm();
         }
         // Child Cascade for Role prnt(R_DEPT)-VmPrvntDept(VCM_DOC_PRVNT): R_DEPT->>VCM_DOC_PRVNT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(VCM_DOC_PRVNTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( VCM_DOC_PRVNTImpl.class ) )
         {
            this.childCascadeFor_VmPrvntDept();
         }
         // Child Cascade for Role prPrflToRDept(R_DEPT)-RDeptToRUtlyActgPrfl(R_UTLY_ACTG_PRFL): R_DEPT->>R_UTLY_ACTG_PRFL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_UTLY_ACTG_PRFLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_UTLY_ACTG_PRFLImpl.class ) )
         {
            this.childCascadeFor_RDeptToRUtlyActgPrfl();
         }
         // Child Cascade for Role prR_DEPT)-R_UNITs2(R_UNIT): R_DEPT->>R_UNIT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_UNITImpl.class ) )
         {
            this.childCascadeFor_R_UNITs2();
         }
         // Child Cascade for Role prR_DEPT)-R_TASK_ORDs1(R_TASK_ORD): R_DEPT->>R_TASK_ORD
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_TASK_ORDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_TASK_ORDImpl.class ) )
         {
            this.childCascadeFor_R_TASK_ORDs1();
         }
         // Child Cascade for Role prpt(R_DEPT)-RDeptToRRgn(R_RGN): R_DEPT->>R_RGN
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_RGNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_RGNImpl.class ) )
         {
            this.childCascadeFor_RDeptToRRgn();
         }
         // Child Cascade for Role prR_DEPT)-R_PGRPs1(R_PGRP): R_DEPT->>R_PGRP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PGRPImpl.class ) )
         {
            this.childCascadeFor_R_PGRPs1();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToPartUsg(R_PART_USG): R_DEPT->>R_PART_USG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PART_USGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PART_USGImpl.class ) )
         {
            this.childCascadeFor_DeptToPartUsg();
         }
         // Child Cascade for Role prR_DEPT)-R_MJR_PTYPs1(R_MJR_PTYP): R_DEPT->>R_MJR_PTYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_MJR_PTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_MJR_PTYPImpl.class ) )
         {
            this.childCascadeFor_R_MJR_PTYPs1();
         }
         // Child Cascade for Role prR_DEPT)-R_DSTCs1(R_DSTC): R_DEPT->>R_DSTC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DSTCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DSTCImpl.class ) )
         {
            this.childCascadeFor_R_DSTCs1();
         }
         // Child Cascade for Role prnToRDept(R_DEPT)-RDeptToRCntrcGlln(R_CNTRC_GOAL_LN): R_DEPT->>R_CNTRC_GOAL_LN
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CNTRC_GOAL_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CNTRC_GOAL_LNImpl.class ) )
         {
            this.childCascadeFor_RDeptToRCntrcGlln();
         }
         // Child Cascade for Role prshSweep(R_DEPT)-RCashSweepToRDept(R_CASH_SW_SETP): R_DEPT->>R_CASH_SW_SETP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CASH_SW_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CASH_SW_SETPImpl.class ) )
         {
            this.childCascadeFor_RCashSweepToRDept();
         }
         // Child Cascade for Role prR_DEPT)-R_AP_CLM_ACCTs1(R_AP_CLM_ACCT): R_DEPT->>R_AP_CLM_ACCT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_CLM_ACCTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_CLM_ACCTImpl.class ) )
         {
            this.childCascadeFor_R_AP_CLM_ACCTs1();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToAltDept(R_ALT_ORG_STRUCT): R_DEPT->>R_ALT_ORG_STRUCT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ALT_ORG_STRUCTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ALT_ORG_STRUCTImpl.class ) )
         {
            this.childCascadeFor_DeptToAltDept();
         }
         // Child Cascade for Role prR_DEPT)-ONLN_PRN_BAT_PARM1(ONLN_PRN_BAT_PARM): R_DEPT->>ONLN_PRN_BAT_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ONLN_PRN_BAT_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ONLN_PRN_BAT_PARMImpl.class ) )
         {
            this.childCascadeFor_ONLN_PRN_BAT_PARM1();
         }
         // Child Cascade for Role pr_DEPT)-INF_APPRs1(INF_APPR): R_DEPT->>INF_APPR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_APPRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_APPRImpl.class ) )
         {
            this.childCascadeFor_INF_APPRs1();
         }
         // Child Cascade for Role prserToRDept(R_DEPT)-RDeptToGtDocRptuser(GT_DOC_RPTUSER): R_DEPT->>GT_DOC_RPTUSER
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_RPTUSERImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_RPTUSERImpl.class ) )
         {
            this.childCascadeFor_RDeptToGtDocRptuser();
         }
         // Child Cascade for Role pr_DEPT)-DOC_HDRs(DOC_HDR): R_DEPT->>DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_DOC_HDRs();
         }
         // Child Cascade for Role prhDept(R_DEPT)-VmAuthDeptDept(VCM_DOC_AUTHDEPT): R_DEPT->>VCM_DOC_AUTHDEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(VCM_DOC_AUTHDEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( VCM_DOC_AUTHDEPTImpl.class ) )
         {
            this.childCascadeFor_VmAuthDeptDept();
         }
         // Child Cascade for Role prR_DEPT)-R_PRVNT_SPNDs(R_PRVNT_SPND): R_DEPT->>R_PRVNT_SPND
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PRVNT_SPNDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PRVNT_SPNDImpl.class ) )
         {
            this.childCascadeFor_R_PRVNT_SPNDs();
         }
         // Child Cascade for Role prept(R_DEPT)-DeptToPartRf(R_PART_RF): R_DEPT->>R_PART_RF
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PART_RFImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PART_RFImpl.class ) )
         {
            this.childCascadeFor_DeptToPartRf();
         }
         // Child Cascade for Role prToRDept(R_DEPT)-RDeptToRGrntrRpt(R_GRNTR_RPT): R_DEPT->>R_GRNTR_RPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNTR_RPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNTR_RPTImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntrRpt();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToDebtAuth(R_DEBT_AUTH): R_DEPT->>R_DEBT_AUTH
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DEBT_AUTHImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DEBT_AUTHImpl.class ) )
         {
            this.childCascadeFor_DeptToDebtAuth();
         }
         // Child Cascade for Role prrSetpToRdept(R_DEPT)-RdeptToRcsalSrctrSetp(R_CSAL_SRCTR_SETP): R_DEPT->>R_CSAL_SRCTR_SETP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CSAL_SRCTR_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CSAL_SRCTR_SETPImpl.class ) )
         {
            this.childCascadeFor_RdeptToRcsalSrctrSetp();
         }
         // Child Cascade for Role prrcuAlToRDept(R_DEPT)-RDeptToRApUprocPrcuAl(R_AP_UPROC_PRCU_AL): R_DEPT->>R_AP_UPROC_PRCU_AL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_UPROC_PRCU_ALImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_UPROC_PRCU_ALImpl.class ) )
         {
            this.childCascadeFor_RDeptToRApUprocPrcuAl();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToApCwChk(R_AP_CW_CHK_NO): R_DEPT->>R_AP_CW_CHK_NO
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_CW_CHK_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_CW_CHK_NOImpl.class ) )
         {
            this.childCascadeFor_DeptToApCwChk();
         }
         // Child Cascade for Role prToRDept1(R_DEPT)-RDept1ToRAdcParm1(R_ADC_PARM): R_DEPT->>R_ADC_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ADC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ADC_PARMImpl.class ) )
         {
            this.childCascadeFor_RDept1ToRAdcParm1();
         }
         // Child Cascade for Role prpt(R_DEPT)-DeptToMDHdr(MD_DOC_HDR): R_DEPT->>MD_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(MD_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( MD_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_DeptToMDHdr();
         }
         // Child Cascade for Role prrmToDept(R_DEPT)-DeptToCamProcParm(CAM_PROC_PARM): R_DEPT->>CAM_PROC_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CAM_PROC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CAM_PROC_PARMImpl.class ) )
         {
            this.childCascadeFor_DeptToCamProcParm();
         }
         // Child Cascade for Role prSetpToRdept(R_DEPT)-RdeptToRstatUnitSetp(R_STAT_UNIT_SETP): R_DEPT->>R_STAT_UNIT_SETP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_STAT_UNIT_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_STAT_UNIT_SETPImpl.class ) )
         {
            this.childCascadeFor_RdeptToRstatUnitSetp();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToProgSta(R_PROG_STA): R_DEPT->>R_PROG_STA
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PROG_STAImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PROG_STAImpl.class ) )
         {
            this.childCascadeFor_DeptToProgSta();
         }
         // Child Cascade for Role prR_DEPT)-R_PROGs2(R_PROG): R_DEPT->>R_PROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PROGImpl.class ) )
         {
            this.childCascadeFor_R_PROGs2();
         }
         // Child Cascade for Role prardInfoToDept(R_DEPT)-DeptToOnGoingAwardInfo(R_ONGOING_AWD_INFO): R_DEPT->>R_ONGOING_AWD_INFO
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ONGOING_AWD_INFOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ONGOING_AWD_INFOImpl.class ) )
         {
            this.childCascadeFor_DeptToOnGoingAwardInfo();
         }
         // Child Cascade for Role prDrawExcpDtl(R_DEPT)-NegDrawExcpDtlRecs(R_NEG_DRW_EXCP_DTL): R_DEPT->>R_NEG_DRW_EXCP_DTL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_NEG_DRW_EXCP_DTLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_NEG_DRW_EXCP_DTLImpl.class ) )
         {
            this.childCascadeFor_NegDrawExcpDtlRecs();
         }
         // Child Cascade for Role prR_DEPT)-R_LCLSs1(R_LCLS): R_DEPT->>R_LCLS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_LCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_LCLSImpl.class ) )
         {
            this.childCascadeFor_R_LCLSs1();
         }
         // Child Cascade for Role prUsrToDept(R_DEPT)-DeptToGrntNotifUsr(R_GRNT_NOTIFUSR): R_DEPT->>R_GRNT_NOTIFUSR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_NOTIFUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_NOTIFUSRImpl.class ) )
         {
            this.childCascadeFor_DeptToGrntNotifUsr();
         }
         // Child Cascade for Role prToRDept2(R_DEPT)-RDept2ToRAdcParm2(R_ADC_PARM): R_DEPT->>R_ADC_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ADC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ADC_PARMImpl.class ) )
         {
            this.childCascadeFor_RDept2ToRAdcParm2();
         }
         // Child Cascade for Role prR_DEPT)-R_ACATs1(R_ACAT): R_DEPT->>R_ACAT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ACATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ACATImpl.class ) )
         {
            this.childCascadeFor_R_ACATs1();
         }
         // Child Cascade for Role prds(R_DEPT)-LrdsToDept1(LIC_RNEW_DT_STRG): R_DEPT->>LIC_RNEW_DT_STRG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(LIC_RNEW_DT_STRGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( LIC_RNEW_DT_STRGImpl.class ) )
         {
            this.childCascadeFor_LrdsToDept1();
         }
         // Child Cascade for Role prs(R_DEPT)-LrdsToDept(LIC_RNEW_DT_STRG): R_DEPT->>LIC_RNEW_DT_STRG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(LIC_RNEW_DT_STRGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( LIC_RNEW_DT_STRGImpl.class ) )
         {
            this.childCascadeFor_LrdsToDept();
         }
         // Child Cascade for Role prcpQtrToDept(R_DEPT)-DeptToARRADocSRcpQtr(ARRA_DOC_SRCPQTR): R_DEPT->>ARRA_DOC_SRCPQTR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ARRA_DOC_SRCPQTRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ARRA_DOC_SRCPQTRImpl.class ) )
         {
            this.childCascadeFor_DeptToARRADocSRcpQtr();
         }
         // Child Cascade for Role prR_DEPT)-ACRL_CLR_MGMT_2(ACRL_CLR_MGMT): R_DEPT->>ACRL_CLR_MGMT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ACRL_CLR_MGMTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ACRL_CLR_MGMTImpl.class ) )
         {
            this.childCascadeFor_ACRL_CLR_MGMT_2();
         }
         // Child Cascade for Role prVLCoaOVrd(R_DEPT)-TRVLCoaOVrdToRDept(TRVL_COA_OVRD): R_DEPT->>TRVL_COA_OVRD
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(TRVL_COA_OVRDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( TRVL_COA_OVRDImpl.class ) )
         {
            this.childCascadeFor_TRVLCoaOVrdToRDept();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToSrcOfFund(R_SRC_OF_FUND): R_DEPT->>R_SRC_OF_FUND
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_SRC_OF_FUNDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_SRC_OF_FUNDImpl.class ) )
         {
            this.childCascadeFor_DeptToSrcOfFund();
         }
         // Child Cascade for Role prR_DEPT)-R_REIM_GEN_PARAM(R_REIM_GEN_PARAM): R_DEPT->>R_REIM_GEN_PARAM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_REIM_GEN_PARAMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_REIM_GEN_PARAMImpl.class ) )
         {
            this.childCascadeFor_R_REIM_GEN_PARAM();
         }
         // Child Cascade for Role prjToDocDept(R_DEPT)-DocDeptToReimExpAdj(R_REIM_EXP_ADJ): R_DEPT->>R_REIM_EXP_ADJ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_REIM_EXP_ADJImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_REIM_EXP_ADJImpl.class ) )
         {
            this.childCascadeFor_DocDeptToReimExpAdj();
         }
         // Child Cascade for Role prAIntnExcep(R_DEPT)-RFAIntnExcepToRDept(R_FA_INTN_EXCEPT): R_DEPT->>R_FA_INTN_EXCEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FA_INTN_EXCEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FA_INTN_EXCEPTImpl.class ) )
         {
            this.childCascadeFor_RFAIntnExcepToRDept();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToDebtHist1(R_DEBT_HIST): R_DEPT->>R_DEBT_HIST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DEBT_HISTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DEBT_HISTImpl.class ) )
         {
            this.childCascadeFor_DeptToDebtHist1();
         }
         // Child Cascade for Role prR_DEPT)-R_CORSPDs1(R_CORSPD): R_DEPT->>R_CORSPD
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CORSPDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CORSPDImpl.class ) )
         {
            this.childCascadeFor_R_CORSPDs1();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToCWCanParm(R_AP_CWCAN_PARM): R_DEPT->>R_AP_CWCAN_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_CWCAN_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_CWCAN_PARMImpl.class ) )
         {
            this.childCascadeFor_DeptToCWCanParm();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToAutoCano(AUTO_CA_NO): R_DEPT->>AUTO_CA_NO
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(AUTO_CA_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( AUTO_CA_NOImpl.class ) )
         {
            this.childCascadeFor_DeptToAutoCano();
         }
         // Child Cascade for Role prLCoaOvrd(R_DEPT)-TRVLCoaOvrdToDept(TRVL_COA_OVRD): R_DEPT->>TRVL_COA_OVRD
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(TRVL_COA_OVRDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( TRVL_COA_OVRDImpl.class ) )
         {
            this.childCascadeFor_TRVLCoaOvrdToDept();
         }
         // Child Cascade for Role pryrLn1ToDept1(R_DEPT)-Dept1ToTaskOrdBuyrLn1(R_TASK_ORD_BUYR_LN): R_DEPT->>R_TASK_ORD_BUYR_LN
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_TASK_ORD_BUYR_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_TASK_ORD_BUYR_LNImpl.class ) )
         {
            this.childCascadeFor_Dept1ToTaskOrdBuyrLn1();
         }
         // Child Cascade for Role pryrLnToDept(R_DEPT)-DeptToTaskOrdBuyrLn(R_TASK_ORD_BUYR_LN): R_DEPT->>R_TASK_ORD_BUYR_LN
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_TASK_ORD_BUYR_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_TASK_ORD_BUYR_LNImpl.class ) )
         {
            this.childCascadeFor_DeptToTaskOrdBuyrLn();
         }
         // Child Cascade for Role prR_DEPT)-R_SYS_CROSWALKs(R_SYS_CROSWALK): R_DEPT->>R_SYS_CROSWALK
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_SYS_CROSWALKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_SYS_CROSWALKImpl.class ) )
         {
            this.childCascadeFor_R_SYS_CROSWALKs();
         }
         // Child Cascade for Role prR_DEPT)-R_PTYPs1(R_PTYP): R_DEPT->>R_PTYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PTYPImpl.class ) )
         {
            this.childCascadeFor_R_PTYPs1();
         }
         // Child Cascade for Role prReqToRdept(R_DEPT)-RdeptToRplbsOfstReq(R_PLBS_OFST_REQ): R_DEPT->>R_PLBS_OFST_REQ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PLBS_OFST_REQImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PLBS_OFST_REQImpl.class ) )
         {
            this.childCascadeFor_RdeptToRplbsOfstReq();
         }
         // Child Cascade for Role prToRdept(R_DEPT)-RdeptToRplbsDist(R_PLBS_DIST): R_DEPT->>R_PLBS_DIST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PLBS_DISTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PLBS_DISTImpl.class ) )
         {
            this.childCascadeFor_RdeptToRplbsDist();
         }
         // Child Cascade for Role prToRDept1(R_DEPT)-RDeptToRGrntrRpt1(R_GRNTR_RPT): R_DEPT->>R_GRNTR_RPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNTR_RPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNTR_RPTImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntrRpt1();
         }
         // Child Cascade for Role prR_DEPT)-R_FNCATs1(R_FNCAT): R_DEPT->>R_FNCAT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FNCATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FNCATImpl.class ) )
         {
            this.childCascadeFor_R_FNCATs1();
         }
         // Child Cascade for Role prtrSetpToRdept(R_DEPT)-RdeptToRcsalStpctrSetp(R_CSAL_STPCTR_SETP): R_DEPT->>R_CSAL_STPCTR_SETP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CSAL_STPCTR_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CSAL_STPCTR_SETPImpl.class ) )
         {
            this.childCascadeFor_RdeptToRcsalStpctrSetp();
         }
         // Child Cascade for Role prR_DEPT)-R_BURs1(R_BUR): R_DEPT->>R_BUR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_BURImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_BURImpl.class ) )
         {
            this.childCascadeFor_R_BURs1();
         }
         // Child Cascade for Role practg_RDept(R_DEPT)-RDept_RBfyStpfNactg(R_BFY_STPF_NACTG): R_DEPT->>R_BFY_STPF_NACTG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_BFY_STPF_NACTGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_BFY_STPF_NACTGImpl.class ) )
         {
            this.childCascadeFor_RDept_RBfyStpfNactg();
         }
         // Child Cascade for Role prDEPT)-AUTO_DOC_NOs(AUTO_DOC_NO): R_DEPT->>AUTO_DOC_NO
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(AUTO_DOC_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( AUTO_DOC_NOImpl.class ) )
         {
            this.childCascadeFor_AUTO_DOC_NOs();
         }
         // Child Cascade for Role prept(R_DEPT)-RDeptVcVcust(VCC_DOC_VCUST): R_DEPT->>VCC_DOC_VCUST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(VCC_DOC_VCUSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( VCC_DOC_VCUSTImpl.class ) )
         {
            this.childCascadeFor_RDeptVcVcust();
         }
         // Child Cascade for Role prtRDept(R_DEPT)-RDeptVcAuthDept(VCC_DOC_AUTHDEPT): R_DEPT->>VCC_DOC_AUTHDEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(VCC_DOC_AUTHDEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( VCC_DOC_AUTHDEPTImpl.class ) )
         {
            this.childCascadeFor_RDeptVcAuthDept();
         }
         // Child Cascade for Role prDEPT)-RQ_DOC_HDR(RQ_DOC_HDR): R_DEPT->>RQ_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(RQ_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( RQ_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_RQ_DOC_HDR();
         }
         // Child Cascade for Role prmReqRcycSel(R_DEPT)-ReimReqRcycSelToDept(R_REIMRQD_RCYCSEL): R_DEPT->>R_REIMRQD_RCYCSEL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_REIMRQD_RCYCSELImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_REIMRQD_RCYCSELImpl.class ) )
         {
            this.childCascadeFor_ReimReqRcycSelToDept();
         }
         // Child Cascade for Role prDept(R_DEPT)-RDeptToRPrtst(R_PRTST): R_DEPT->>R_PRTST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PRTSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PRTSTImpl.class ) )
         {
            this.childCascadeFor_RDeptToRPrtst();
         }
         // Child Cascade for Role prR_DEPT)-R_LOC_TBLs1(R_LOC_TBL): R_DEPT->>R_LOC_TBL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_LOC_TBLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_LOC_TBLImpl.class ) )
         {
            this.childCascadeFor_R_LOC_TBLs1();
         }
         // Child Cascade for Role prRDept1(R_DEPT)-RDept1ToRIntCst(R_INT_CST_PARM): R_DEPT->>R_INT_CST_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_INT_CST_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_INT_CST_PARMImpl.class ) )
         {
            this.childCascadeFor_RDept1ToRIntCst();
         }
         // Child Cascade for Role prtSchedToRDept(R_DEPT)-RDeptToRGrntrEvntSched(R_GRNTR_EVNT_SCHED): R_DEPT->>R_GRNTR_EVNT_SCHED
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNTR_EVNT_SCHEDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNTR_EVNT_SCHEDImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntrEvntSched();
         }
         // Child Cascade for Role prtToDept(R_DEPT)-DeptToEscrowHist(R_ESCROW_HIST): R_DEPT->>R_ESCROW_HIST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ESCROW_HISTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ESCROW_HISTImpl.class ) )
         {
            this.childCascadeFor_DeptToEscrowHist();
         }
         // Child Cascade for Role prR_DEPT)-R_DISB_MGMT_RSTRs2(R_DISB_MGMT_RSTR): R_DEPT->>R_DISB_MGMT_RSTR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DISB_MGMT_RSTRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DISB_MGMT_RSTRImpl.class ) )
         {
            this.childCascadeFor_R_DISB_MGMT_RSTRs2();
         }
         // Child Cascade for Role prbtInstToDept(R_DEPT)-DeptToDebtDocDebtInst(DEBT_DOC_DEBTINST): R_DEPT->>DEBT_DOC_DEBTINST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(DEBT_DOC_DEBTINSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( DEBT_DOC_DEBTINSTImpl.class ) )
         {
            this.childCascadeFor_DeptToDebtDocDebtInst();
         }
         // Child Cascade for Role prR_DEPT)-SO_DOC_HDRs2(SO_DOC_HDR): R_DEPT->>SO_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(SO_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( SO_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_SO_DOC_HDRs2();
         }
         // Child Cascade for Role prDept(R_DEPT)-RDeptToREquip(R_EQUIP): R_DEPT->>R_EQUIP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_EQUIPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_EQUIPImpl.class ) )
         {
            this.childCascadeFor_RDeptToREquip();
         }
         // Child Cascade for Role prR_DEPT)-R_DRSCLSs1(R_DRSCLS): R_DEPT->>R_DRSCLS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DRSCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DRSCLSImpl.class ) )
         {
            this.childCascadeFor_R_DRSCLSs1();
         }
         // Child Cascade for Role prR_DEPT)-R_DIVs1(R_DIV): R_DEPT->>R_DIV
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DIVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DIVImpl.class ) )
         {
            this.childCascadeFor_R_DIVs1();
         }
         // Child Cascade for Role proRDept(R_DEPT)-RDeptToPHMDocLn(PHM_DOC_LINE): R_DEPT->>PHM_DOC_LINE
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(PHM_DOC_LINEImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( PHM_DOC_LINEImpl.class ) )
         {
            this.childCascadeFor_RDeptToPHMDocLn();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToInfApBY2(INF_APBY2): R_DEPT->>INF_APBY2
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_APBY2Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_APBY2Impl.class ) )
         {
            this.childCascadeFor_DeptToInfApBY2();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToApEdiHdr(AP_EDI_HDR): R_DEPT->>AP_EDI_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(AP_EDI_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( AP_EDI_HDRImpl.class ) )
         {
            this.childCascadeFor_DeptToApEdiHdr();
         }
         // Child Cascade for Role prjToDept(R_DEPT)-DeptToReimExpAdj(R_REIM_EXP_ADJ): R_DEPT->>R_REIM_EXP_ADJ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_REIM_EXP_ADJImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_REIM_EXP_ADJImpl.class ) )
         {
            this.childCascadeFor_DeptToReimExpAdj();
         }
         // Child Cascade for Role prDocCrsRef(R_DEPT)-PrgDocCrsRefToDept(R_PROG_DOC_CRSREF): R_DEPT->>R_PROG_DOC_CRSREF
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PROG_DOC_CRSREFImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PROG_DOC_CRSREFImpl.class ) )
         {
            this.childCascadeFor_PrgDocCrsRefToDept();
         }
         // Child Cascade for Role prR_DEPT)-R_PHASEs(R_PHASE): R_DEPT->>R_PHASE
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PHASEImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PHASEImpl.class ) )
         {
            this.childCascadeFor_R_PHASEs();
         }
         // Child Cascade for Role prR_DEPT)-R_LOCs2(R_LOC): R_DEPT->>R_LOC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_LOCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_LOCImpl.class ) )
         {
            this.childCascadeFor_R_LOCs2();
         }
         // Child Cascade for Role prtToRDept(R_DEPT)-RDeptToRGrntDtDet(R_GRNT_DT_DET): R_DEPT->>R_GRNT_DT_DET
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_DT_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_DT_DETImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntDtDet();
         }
         // Child Cascade for Role prtSchedToRDept1(R_DEPT)-RDeptToRGrntrEvntSched1(R_GRNTR_EVNT_SCHED): R_DEPT->>R_GRNTR_EVNT_SCHED
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNTR_EVNT_SCHEDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNTR_EVNT_SCHEDImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntrEvntSched1();
         }
         // Child Cascade for Role prept(R_DEPT)-DeptToFDTOpt(R_FDT_OPT): R_DEPT->>R_FDT_OPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FDT_OPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FDT_OPTImpl.class ) )
         {
            this.childCascadeFor_DeptToFDTOpt();
         }
         // Child Cascade for Role prR_DEPT)-R_DRSRCs1(R_DRSRC): R_DEPT->>R_DRSRC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DRSRCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DRSRCImpl.class ) )
         {
            this.childCascadeFor_R_DRSRCs1();
         }
         // Child Cascade for Role prR_DEPT)-R_DOCLSs1(R_DOCLS): R_DEPT->>R_DOCLS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DOCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DOCLSImpl.class ) )
         {
            this.childCascadeFor_R_DOCLSs1();
         }
         // Child Cascade for Role prSetpToRdept(R_DEPT)-RdeptToRcsalCtrlSetp(R_CSAL_CTRL_SETP): R_DEPT->>R_CSAL_CTRL_SETP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CSAL_CTRL_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CSAL_CTRL_SETPImpl.class ) )
         {
            this.childCascadeFor_RdeptToRcsalCtrlSetp();
         }
         // Child Cascade for Role prR_DEPT)-R_BUYR_FLINEs2(R_BUYR_FLINE): R_DEPT->>R_BUYR_FLINE
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_BUYR_FLINEImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_BUYR_FLINEImpl.class ) )
         {
            this.childCascadeFor_R_BUYR_FLINEs2();
         }
         // Child Cascade for Role pryDebtToDept(R_DEPT)-DeptToAlwPymntByDebt(R_ALW_PYMT_DBTYP): R_DEPT->>R_ALW_PYMT_DBTYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ALW_PYMT_DBTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ALW_PYMT_DBTYPImpl.class ) )
         {
            this.childCascadeFor_DeptToAlwPymntByDebt();
         }
         // Child Cascade for Role prudRule(R_DEPT)-GnBudRuleToDept(GN_BUD_RULE): R_DEPT->>GN_BUD_RULE
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GN_BUD_RULEImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GN_BUD_RULEImpl.class ) )
         {
            this.childCascadeFor_GnBudRuleToDept();
         }
         // Child Cascade for Role prR_DEPT)-R_RSTR_USEs(R_RSTR_USE): R_DEPT->>R_RSTR_USE
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_RSTR_USEImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_RSTR_USEImpl.class ) )
         {
            this.childCascadeFor_R_RSTR_USEs();
         }
         // Child Cascade for Role prc(R_DEPT)-R_FACCs(R_FACC): R_DEPT->>R_FACC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FACCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FACCImpl.class ) )
         {
            this.childCascadeFor_R_FACCs();
         }
         // Child Cascade for Role prT(R_DEPT)-ECRTToDept(R_EXTR_CASH_RECT): R_DEPT->>R_EXTR_CASH_RECT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_EXTR_CASH_RECTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_EXTR_CASH_RECTImpl.class ) )
         {
            this.childCascadeFor_ECRTToDept();
         }
         // Child Cascade for Role prR_DEPT)-R_DOGRPs1(R_DOGRP): R_DEPT->>R_DOGRP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DOGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DOGRPImpl.class ) )
         {
            this.childCascadeFor_R_DOGRPs1();
         }
         // Child Cascade for Role prept(R_DEPT)-DeptToClmtrk(R_CLMTRK): R_DEPT->>R_CLMTRK
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CLMTRKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CLMTRKImpl.class ) )
         {
            this.childCascadeFor_DeptToClmtrk();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToCADocHist(R_CA_DOC_HIST): R_DEPT->>R_CA_DOC_HIST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CA_DOC_HISTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CA_DOC_HISTImpl.class ) )
         {
            this.childCascadeFor_DeptToCADocHist();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToDisbExcp(R_AP_DISB_EXCP): R_DEPT->>R_AP_DISB_EXCP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_DISB_EXCPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_DISB_EXCPImpl.class ) )
         {
            this.childCascadeFor_DeptToDisbExcp();
         }
         // Child Cascade for Role prR_DEPT)-R_ACLSs1(R_ACLS): R_DEPT->>R_ACLS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ACLSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ACLSImpl.class ) )
         {
            this.childCascadeFor_R_ACLSs1();
         }
         // Child Cascade for Role prcFederalTaxPaymentSystemToDepartment(R_DEPT)-DepartmentToElectronicFederalTaxPaymentSystem(ELEC_FED_TAXP_SYS): R_DEPT->>ELEC_FED_TAXP_SYS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ELEC_FED_TAXP_SYSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ELEC_FED_TAXP_SYSImpl.class ) )
         {
            this.childCascadeFor_DepartmentToElectronicFederalTaxPaymentSystem();
         }
         // Child Cascade for Role prR_DEPT)-ACRL_CLR_MGMT_1(ACRL_CLR_MGMT): R_DEPT->>ACRL_CLR_MGMT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ACRL_CLR_MGMTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ACRL_CLR_MGMTImpl.class ) )
         {
            this.childCascadeFor_ACRL_CLR_MGMT_1();
         }
         // Child Cascade for Role prR_DEPT)-R_SECTs1(R_SECT): R_DEPT->>R_SECT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_SECTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_SECTImpl.class ) )
         {
            this.childCascadeFor_R_SECTs1();
         }
         // Child Cascade for Role prDocCrsRef1_1(R_DEPT)-PrgDocCrsRef1ToDept_1(R_PROG_DOC_CRSREF): R_DEPT->>R_PROG_DOC_CRSREF
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PROG_DOC_CRSREFImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PROG_DOC_CRSREFImpl.class ) )
         {
            this.childCascadeFor_PrgDocCrsRef1ToDept_1();
         }
         // Child Cascade for Role prrActg(R_DEPT)-IntrActgToDept(R_INTR_ACTG_CRSWLK): R_DEPT->>R_INTR_ACTG_CRSWLK
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_INTR_ACTG_CRSWLKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_INTR_ACTG_CRSWLKImpl.class ) )
         {
            this.childCascadeFor_IntrActgToDept();
         }
         // Child Cascade for Role prR_DEPT)-R_DOTYPs1(R_DOTYP): R_DEPT->>R_DOTYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DOTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DOTYPImpl.class ) )
         {
            this.childCascadeFor_R_DOTYPs1();
         }
         // Child Cascade for Role proRqstDept(R_DEPT)-RqstDeptToMaDocHdr(MA_DOC_HDR): R_DEPT->>MA_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(MA_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( MA_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_RqstDeptToMaDocHdr();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToInfAppr2(INF_APPR2): R_DEPT->>INF_APPR2
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_APPR2Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_APPR2Impl.class ) )
         {
            this.childCascadeFor_DeptToInfAppr2();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToGRDocHdr(GR_DOC_HDR): R_DEPT->>GR_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GR_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GR_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_DeptToGRDocHdr();
         }
         // Child Cascade for Role prthToDept(R_DEPT)-DeptToDebtDocAuth(DEBT_DOC_AUTH): R_DEPT->>DEBT_DOC_AUTH
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(DEBT_DOC_AUTHImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( DEBT_DOC_AUTHImpl.class ) )
         {
            this.childCascadeFor_DeptToDebtDocAuth();
         }
         // Child Cascade for Role proToDept(R_DEPT)-DeptToAutoPartNo(AUTO_PART_NO): R_DEPT->>AUTO_PART_NO
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(AUTO_PART_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( AUTO_PART_NOImpl.class ) )
         {
            this.childCascadeFor_DeptToAutoPartNo();
         }
         // Child Cascade for Role prpt(R_DEPT)-DeptToADHdr(AD_DOC_HDR): R_DEPT->>AD_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(AD_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( AD_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_DeptToADHdr();
         }
         // Child Cascade for Role prR_DEPT)-RCLS_PARM_DTL1(RCLS_PARM_DTL): R_DEPT->>RCLS_PARM_DTL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(RCLS_PARM_DTLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( RCLS_PARM_DTLImpl.class ) )
         {
            this.childCascadeFor_RCLS_PARM_DTL1();
         }
         // Child Cascade for Role prpt(R_DEPT)-DeptToVcust(R_VEND_CUST): R_DEPT->>R_VEND_CUST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_VEND_CUSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_VEND_CUSTImpl.class ) )
         {
            this.childCascadeFor_DeptToVcust();
         }
         // Child Cascade for Role prept(R_DEPT)-DeptToMsmals(R_MSMALS): R_DEPT->>R_MSMALS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_MSMALSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_MSMALSImpl.class ) )
         {
            this.childCascadeFor_DeptToMsmals();
         }
         // Child Cascade for Role prRDept(R_DEPT)-RDeptToRIntCst(R_INT_CST_PARM): R_DEPT->>R_INT_CST_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_INT_CST_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_INT_CST_PARMImpl.class ) )
         {
            this.childCascadeFor_RDeptToRIntCst();
         }
         // Child Cascade for Role prR_DEPT)-R_FUNCs1(R_FUNC): R_DEPT->>R_FUNC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FUNCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FUNCImpl.class ) )
         {
            this.childCascadeFor_R_FUNCs1();
         }
         // Child Cascade for Role prpt(R_DEPT)-RDeptToRFac(R_FAC): R_DEPT->>R_FAC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FACImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FACImpl.class ) )
         {
            this.childCascadeFor_RDeptToRFac();
         }
         // Child Cascade for Role proRDept(R_DEPT)-RDeptToREmpInfo(R_EMP_INFO): R_DEPT->>R_EMP_INFO
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_EMP_INFOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_EMP_INFOImpl.class ) )
         {
            this.childCascadeFor_RDeptToREmpInfo();
         }
         // Child Cascade for Role prpPolToDept(R_DEPT)-DeptToDeptTrvlxpPol(R_DEPT_TRVLXP_POL): R_DEPT->>R_DEPT_TRVLXP_POL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DEPT_TRVLXP_POLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DEPT_TRVLXP_POLImpl.class ) )
         {
            this.childCascadeFor_DeptToDeptTrvlxpPol();
         }
         // Child Cascade for Role prnstToDept(R_DEPT)-DeptToDebtDebtInst(R_DEBT_DEBTINST): R_DEPT->>R_DEBT_DEBTINST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DEBT_DEBTINSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DEBT_DEBTINSTImpl.class ) )
         {
            this.childCascadeFor_DeptToDebtDebtInst();
         }
         // Child Cascade for Role prdToRDept(R_DEPT)-RDeptToRCntrcGlhd(R_CNTRC_GOAL_HDR): R_DEPT->>R_CNTRC_GOAL_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CNTRC_GOAL_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CNTRC_GOAL_HDRImpl.class ) )
         {
            this.childCascadeFor_RDeptToRCntrcGlhd();
         }
         // Child Cascade for Role prDEPT)-ACRL_CLR_MGMT(ACRL_CLR_MGMT): R_DEPT->>ACRL_CLR_MGMT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ACRL_CLR_MGMTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ACRL_CLR_MGMTImpl.class ) )
         {
            this.childCascadeFor_ACRL_CLR_MGMT();
         }
         // Child Cascade for Role prept(R_DEPT)-DeptToABSHdr(ABS_DOC_HDR): R_DEPT->>ABS_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ABS_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ABS_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_DeptToABSHdr();
         }
         // Child Cascade for Role prndToDept(R_DEPT)-DeptToTrvlDocVend(TRVL_DOC_VEND): R_DEPT->>TRVL_DOC_VEND
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(TRVL_DOC_VENDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( TRVL_DOC_VENDImpl.class ) )
         {
            this.childCascadeFor_DeptToTrvlDocVend();
         }
         // Child Cascade for Role prR_DEPT)-R_REIM_FREQ_DTs1(R_REIM_FREQ_DT): R_DEPT->>R_REIM_FREQ_DT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_REIM_FREQ_DTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_REIM_FREQ_DTImpl.class ) )
         {
            this.childCascadeFor_R_REIM_FREQ_DTs1();
         }
         // Child Cascade for Role prR_DEPT)-R_OTPT_PARM_DETs5(R_OTPT_PARM_DET): R_DEPT->>R_OTPT_PARM_DET
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_OTPT_PARM_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_OTPT_PARM_DETImpl.class ) )
         {
            this.childCascadeFor_R_OTPT_PARM_DETs5();
         }
         // Child Cascade for Role prR_DEPT)-R_MGR(R_MGR): R_DEPT->>R_MGR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_MGRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_MGRImpl.class ) )
         {
            this.childCascadeFor_R_MGR();
         }
         // Child Cascade for Role prR_DEPT)-R_GPs1(R_GP): R_DEPT->>R_GP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GPImpl.class ) )
         {
            this.childCascadeFor_R_GPs1();
         }
         // Child Cascade for Role prultiToRDept(R_DEPT)-RDeptToREmplBenMulti(R_EMPL_BEN_MULTI): R_DEPT->>R_EMPL_BEN_MULTI
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_EMPL_BEN_MULTIImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_EMPL_BEN_MULTIImpl.class ) )
         {
            this.childCascadeFor_RDeptToREmplBenMulti();
         }
         // Child Cascade for Role prR_DEPT)-R_DRSGRPs1(R_DRSGRP): R_DEPT->>R_DRSGRP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DRSGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DRSGRPImpl.class ) )
         {
            this.childCascadeFor_R_DRSGRPs1();
         }
         // Child Cascade for Role prR_DEPT)-R_DOBJs1(R_DOBJ): R_DEPT->>R_DOBJ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DOBJImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DOBJImpl.class ) )
         {
            this.childCascadeFor_R_DOBJs1();
         }
         // Child Cascade for Role prDEPT)-PO_DOC_HDR(PO_DOC_HDR): R_DEPT->>PO_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(PO_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( PO_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_PO_DOC_HDR();
         }
         // Child Cascade for Role prept(R_DEPT)-RDeptVcPrvnt(VCC_DOC_PRVNT): R_DEPT->>VCC_DOC_PRVNT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(VCC_DOC_PRVNTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( VCC_DOC_PRVNTImpl.class ) )
         {
            this.childCascadeFor_RDeptVcPrvnt();
         }
         // Child Cascade for Role prDEPT)-R_PROG_GIS_LOC(R_PROG_GIS_LOC): R_DEPT->>R_PROG_GIS_LOC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PROG_GIS_LOCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PROG_GIS_LOCImpl.class ) )
         {
            this.childCascadeFor_R_PROG_GIS_LOC();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToPartTyp(R_PART_TYP): R_DEPT->>R_PART_TYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PART_TYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PART_TYPImpl.class ) )
         {
            this.childCascadeFor_DeptToPartTyp();
         }
         // Child Cascade for Role prR_DEPT)-R_LCATs1(R_LCAT): R_DEPT->>R_LCAT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_LCATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_LCATImpl.class ) )
         {
            this.childCascadeFor_R_LCATs1();
         }
         // Child Cascade for Role prUserToRDept(R_DEPT)-RDeptToRGrntAlrtUser(R_GRNT_ALRT_USER): R_DEPT->>R_GRNT_ALRT_USER
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_ALRT_USERImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_ALRT_USERImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntAlrtUser();
         }
         // Child Cascade for Role proRDept(R_DEPT)-RDeptToRFndgGrp(R_FNDG_GRP): R_DEPT->>R_FNDG_GRP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FNDG_GRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FNDG_GRPImpl.class ) )
         {
            this.childCascadeFor_RDeptToRFndgGrp();
         }
         // Child Cascade for Role prpt(R_DEPT)-RDeptToRFgc(R_FGC): R_DEPT->>R_FGC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FGCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FGCImpl.class ) )
         {
            this.childCascadeFor_RDeptToRFgc();
         }
         // Child Cascade for Role prDept(R_DEPT)-RDeptToFarHdr(R_FAR_HDR): R_DEPT->>R_FAR_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FAR_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FAR_HDRImpl.class ) )
         {
            this.childCascadeFor_RDeptToFarHdr();
         }
         // Child Cascade for Role prR_DEPT)-R_DRSTYPs1(R_DRSTYP): R_DEPT->>R_DRSTYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DRSTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DRSTYPImpl.class ) )
         {
            this.childCascadeFor_R_DRSTYPs1();
         }
         // Child Cascade for Role prR_DEPT)-R_DRSCATs1(R_DRSCAT): R_DEPT->>R_DRSCAT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DRSCATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DRSCATImpl.class ) )
         {
            this.childCascadeFor_R_DRSCATs1();
         }
         // Child Cascade for Role prR_DEPT)-R_ACTVs6(R_ACTV): R_DEPT->>R_ACTV
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ACTVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ACTVImpl.class ) )
         {
            this.childCascadeFor_R_ACTVs6();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToPoSrtyIns(PO_DOC_SRTYINS): R_DEPT->>PO_DOC_SRTYINS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(PO_DOC_SRTYINSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( PO_DOC_SRTYINSImpl.class ) )
         {
            this.childCascadeFor_DeptToPoSrtyIns();
         }
         // Child Cascade for Role prmDfltToRDpt(R_DEPT)-RDptToROnPrnParmDflt(ONLN_PRN_PARM_DFLT): R_DEPT->>ONLN_PRN_PARM_DFLT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ONLN_PRN_PARM_DFLTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ONLN_PRN_PARM_DFLTImpl.class ) )
         {
            this.childCascadeFor_RDptToROnPrnParmDflt();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToInfApBY(INF_APBY): R_DEPT->>INF_APBY
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_APBYImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_APBYImpl.class ) )
         {
            this.childCascadeFor_DeptToInfApBY();
         }
         // Child Cascade for Role pruserToRDept(R_DEPT)-RDeptToGtDocAlrtuser(GT_DOC_ALRTUSER): R_DEPT->>GT_DOC_ALRTUSER
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_ALRTUSERImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_ALRTUSERImpl.class ) )
         {
            this.childCascadeFor_RDeptToGtDocAlrtuser();
         }
         // Child Cascade for Role proFADocHdr(R_DEPT)-FA_DOC_HDRs1(FA_DOC_HDR): R_DEPT->>FA_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(FA_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( FA_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_FA_DOC_HDRs1();
         }
         // Child Cascade for Role prgoingToDept(R_DEPT)-DeptToARRADocOngoing(ARRA_DOC_ONGOING): R_DEPT->>ARRA_DOC_ONGOING
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ARRA_DOC_ONGOINGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ARRA_DOC_ONGOINGImpl.class ) )
         {
            this.childCascadeFor_DeptToARRADocOngoing();
         }
         // Child Cascade for Role prtrlyAwdToDepartment(R_DEPT)-DepartmentToSubRcpntQtrlyAwd(R_SRCPNT_QTRLY_AWD): R_DEPT->>R_SRCPNT_QTRLY_AWD
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_SRCPNT_QTRLY_AWDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_SRCPNT_QTRLY_AWDImpl.class ) )
         {
            this.childCascadeFor_DepartmentToSubRcpntQtrlyAwd();
         }
         // Child Cascade for Role prToRdept(R_DEPT)-RdeptToRplbsSetp(R_PLBS_SETP): R_DEPT->>R_PLBS_SETP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PLBS_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PLBS_SETPImpl.class ) )
         {
            this.childCascadeFor_RdeptToRplbsSetp();
         }
         // Child Cascade for Role prR_DEPT)-R_OTPT_PARM_DETs4(R_OTPT_PARM_DET): R_DEPT->>R_OTPT_PARM_DET
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_OTPT_PARM_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_OTPT_PARM_DETImpl.class ) )
         {
            this.childCascadeFor_R_OTPT_PARM_DETs4();
         }
         // Child Cascade for Role prntCstOtMulti1(R_DEPT)-RIntCstOtMultiToRDept1(R_INT_CST_OT_MULTI): R_DEPT->>R_INT_CST_OT_MULTI
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_INT_CST_OT_MULTIImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_INT_CST_OT_MULTIImpl.class ) )
         {
            this.childCascadeFor_RIntCstOtMultiToRDept1();
         }
         // Child Cascade for Role prR_DEPT)-R_FNCLSs1(R_FNCLS): R_DEPT->>R_FNCLS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FNCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FNCLSImpl.class ) )
         {
            this.childCascadeFor_R_FNCLSs1();
         }
         // Child Cascade for Role pr_DEPT)-R_DISB_MGMT_RSTR_1(R_DISB_MGMT_RSTR): R_DEPT->>R_DISB_MGMT_RSTR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DISB_MGMT_RSTRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DISB_MGMT_RSTRImpl.class ) )
         {
            this.childCascadeFor_R_DISB_MGMT_RSTR_1();
         }
         // Child Cascade for Role prDEPT)-R_DISB_MGMT_RSTR(R_DISB_MGMT_RSTR): R_DEPT->>R_DISB_MGMT_RSTR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DISB_MGMT_RSTRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DISB_MGMT_RSTRImpl.class ) )
         {
            this.childCascadeFor_R_DISB_MGMT_RSTR();
         }
         // Child Cascade for Role prDEPT)-R_CMIA_INTR_PARMs(R_CMIA_INTR_PARM): R_DEPT->>R_CMIA_INTR_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CMIA_INTR_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CMIA_INTR_PARMImpl.class ) )
         {
            this.childCascadeFor_R_CMIA_INTR_PARMs();
         }
         // Child Cascade for Role prev_RDept(R_DEPT)-RDept_RBfyStpfRev(R_BFY_STPF_REV): R_DEPT->>R_BFY_STPF_REV
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_BFY_STPF_REVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_BFY_STPF_REVImpl.class ) )
         {
            this.childCascadeFor_RDept_RBfyStpfRev();
         }
         // Child Cascade for Role prgToDept(R_DEPT)-DeptToIctDocActg(ICT_DOC_HDR): R_DEPT->>ICT_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ICT_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ICT_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_DeptToIctDocActg();
         }
   }
   else
   {
      //Bypassing child cascades this insert; reset this behavior for next time
      mboolPerformCascade = true ;
   }


   // Post Rule Event
   postRuleEvent(VLSEvent.AFTER_INSERT, null);
   // This concludes the insert procedure.   

}

protected void update() throws ServerException
{
   // AMS BEGIN : SDO
   if ( cacheSize != 0 )
   {
      throw new ServerException( "R_DEPT is cached.  Update not permitted." ) ; 
   }
   // AMS END : SDO

   if ( isBehaviorEnabled( AMSBEHAVIOR_PROCESS_SENSITIVE ) )
   {
      processInProgressCheck( VLSEvent.BEFORE_UPDATE ) ;
   }

   // Process update with business rules?
   if ( !getProcessWithBusinessLogic() )
   {
      // No, so just save the component and exit
      this.updateRowImmediate() ;
      return ;
   }


   // Post Rule Event
   postRuleEvent(VLSEvent.BEFORE_UPDATE, response.reset());
   if (response.rejected()) return;

   if(isUnAlterableRequired())
   {
      if(false)
      {
         // Column Non Alterability check
               if ( getGlobalNestLevel() == 1 && getData(miDEPT_SH_NM_UP).modified() && !isUpdatedAfterInsert() )
               {      
                  raiseException("Attribute 'DEPT_SH_NM_UP' in Object R_DEPT is not Alterable.","R_DEPT","DEPT_SH_NM_UP");
               }
               if ( getGlobalNestLevel() == 1 && getData(miAMS_ROW_VERS_NO).modified() && !isUpdatedAfterInsert() )
               {      
                  raiseException("Attribute 'AMS_ROW_VERS_NO' in Object R_DEPT is not Alterable.","R_DEPT","AMS_ROW_VERS_NO");
               }
       if ( getGlobalNestLevel() == 1 && isAltered("DISB_CNTAC_NM") && !isUpdatedAfterInsert() )
               {      
                  raiseException("Attribute 'DISB_CNTAC_NM' in Object R_DEPT is not Alterable.","R_DEPT","DISB_CNTAC_NM");
               }
       if ( getGlobalNestLevel() == 1 && isAltered("DLGTD_TEAM_NM") && !isUpdatedAfterInsert() )
               {      
                  raiseException("Attribute 'DLGTD_TEAM_NM' in Object R_DEPT is not Alterable.","R_DEPT","DLGTD_TEAM_NM");
               }
       if ( getGlobalNestLevel() == 1 && isAltered("TEAM_NM") && !isUpdatedAfterInsert() )
               {      
                  raiseException("Attribute 'TEAM_NM' in Object R_DEPT is not Alterable.","R_DEPT","TEAM_NM");
               }
               if ( getGlobalNestLevel() == 1 && getData(miTBL_LAST_DT).modified() && !isUpdatedAfterInsert() )
               {      
                  raiseException("Attribute 'TBL_LAST_DT' in Object R_DEPT is not Alterable.","R_DEPT","TBL_LAST_DT");
               }
               if ( getGlobalNestLevel() == 1 && getData(miDEPT_DSCR_UP).modified() && !isUpdatedAfterInsert() )
               {      
                  raiseException("Attribute 'DEPT_DSCR_UP' in Object R_DEPT is not Alterable.","R_DEPT","DEPT_DSCR_UP");
               }
       if ( getGlobalNestLevel() == 1 && isAltered("CNTAC_PH_NO") && !isUpdatedAfterInsert() )
               {      
                  raiseException("Attribute 'CNTAC_PH_NO' in Object R_DEPT is not Alterable.","R_DEPT","CNTAC_PH_NO");
               }
       if ( getGlobalNestLevel() == 1 && isAltered("DLGTD_BUYR_NM") && !isUpdatedAfterInsert() )
               {      
                  raiseException("Attribute 'DLGTD_BUYR_NM' in Object R_DEPT is not Alterable.","R_DEPT","DLGTD_BUYR_NM");
               }
       if ( getGlobalNestLevel() == 1 && isAltered("CNTAC_PERSN") && !isUpdatedAfterInsert() )
               {      
                  raiseException("Attribute 'CNTAC_PERSN' in Object R_DEPT is not Alterable.","R_DEPT","CNTAC_PERSN");
               }
       if ( getGlobalNestLevel() == 1 && isAltered("BUYR_NM") && !isUpdatedAfterInsert() )
               {      
                  raiseException("Attribute 'BUYR_NM' in Object R_DEPT is not Alterable.","R_DEPT","BUYR_NM");
               }
       if ( getGlobalNestLevel() == 1 && isAltered("CNTAC_PH_EXT") && !isUpdatedAfterInsert() )
               {      
                  raiseException("Attribute 'CNTAC_PH_EXT' in Object R_DEPT is not Alterable.","R_DEPT","CNTAC_PH_EXT");
               }
               if ( getGlobalNestLevel() == 1 && getData(miDEPT_NM_UP).modified() && !isUpdatedAfterInsert() )
               {      
                  raiseException("Attribute 'DEPT_NM_UP' in Object R_DEPT is not Alterable.","R_DEPT","DEPT_NM_UP");
               }
       if ( getGlobalNestLevel() == 1 && isAltered("CNTAC_EMAIL") && !isUpdatedAfterInsert() )
               {      
                  raiseException("Attribute 'CNTAC_EMAIL' in Object R_DEPT is not Alterable.","R_DEPT","CNTAC_EMAIL");
               }
   
      }
   }

   if (isParentReplicationRequired())
   {
      this.fireParents();
      this.notifyAfterFireParents();
   }

   if (isFormulaRequired())
   {
      // Set the formulae values at this point
      this.setFormulaValues();
   }

   if(isValidationRequired())
   {
         // At this point do code table constraint validation.
            if (!( isNull("REST_BUYR_UNIT") ))
            {
               this.codeTableCheck("REST_BUYR_UNIT");
            }
            if (!( isNull("AR_UNIT_INFR") ))
            {
               this.codeTableCheck("AR_UNIT_INFR");
            }

      //
      // Any required attributes missing?
      //
      if(this.columnRequiredCheck())
      {
         //
         // Cut directly to the commit attempt and don't do any more validations.  
         //
         this.updateRowImmediate();
         return;
      }

      // Do Column Validation Checks
      this.columnValidationCheck();

         // Do TableConstraintChecks
         this.tableConstraintCheck();
   

   // verify that not nullable columns are not null.


         if ( isNull("ACT_FL") )
         {
            // Raise the exception here.
            raiseException("Attribute 'R_DEPT.ACT_FL' does not allow Null Values.","R_DEPT","ACT_FL");

         }








         if ( isNull("ALW_BUD_FL") )
         {
            // Raise the exception here.
            raiseException("Attribute 'R_DEPT.ALW_BUD_FL' does not allow Null Values.","R_DEPT","ALW_BUD_FL");

         }



   }

   // Compute stored values if not already done
         if ( isChanged("DEPT_NM_UP") )
            getDEPT_NM_UP();
         if ( isChanged("DEPT_SH_NM_UP") )
            getDEPT_SH_NM_UP();
         if ( isChanged("DEPT_DSCR_UP") )
            getDEPT_DSCR_UP();
      
      
      
      
      
      
      
      
      

   if ( this.isCurrentEvent("RECOMPUTE_DERIVATIONS") && (getGlobalNestLevel() == 1) ) 
   {
      this.RecomputeDerivations();
   }
   // Check update security for this data object:
   if( mboolCheckUpdateSecurity )
   {
         checkUpdateSecurity() ;
   }
   // Adds the data object to the write cache so any queries for it
      // will return the current instance of the data object
      getSession().getTransactionInfo().save(this);

   if(isMediatorRequired())
   {
      invokeMediator();
   }
   if(isSecondaryMediatorRequired())
   {
      invokeSecondaryMediator();
   }   

   // Factored out duplicate code passage - Val/Paul 03-17-03
     this.tableConditionActions();



     this.updateRowImmediate();

     notifyBeforeChildAdjustments() ;

   if ( mboolPerformCascade )
   {
      // Do Child Cascades.
         // Child Cascade for Role prgoingToDeptCA(R_DEPT)-DeptCAToARRADocOngoing(ARRA_DOC_ONGOING): R_DEPT->>ARRA_DOC_ONGOING
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ARRA_DOC_ONGOINGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ARRA_DOC_ONGOINGImpl.class ) )
         {
            this.childCascadeFor_DeptCAToARRADocOngoing();
         }
         // Child Cascade for Role prgDocToDept(R_DEPT)-DeptToCAMMjrProgDoc(CAM_DOC_MJRPROG): R_DEPT->>CAM_DOC_MJRPROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CAM_DOC_MJRPROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CAM_DOC_MJRPROGImpl.class ) )
         {
            this.childCascadeFor_DeptToCAMMjrProgDoc();
         }
         // Child Cascade for Role prgDocToDept(R_DEPT)-DeptToCASMjrProgDoc(CAS_DOC_MJRPROG): R_DEPT->>CAS_DOC_MJRPROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CAS_DOC_MJRPROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CAS_DOC_MJRPROGImpl.class ) )
         {
            this.childCascadeFor_DeptToCASMjrProgDoc();
         }
         // Child Cascade for Role pr_DEPT)-CVEX_FUND_DEPTs(CVEX_FUND_DEPT): R_DEPT->>CVEX_FUND_DEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CVEX_FUND_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CVEX_FUND_DEPTImpl.class ) )
         {
            this.childCascadeFor_CVEX_FUND_DEPTs();
         }
         // Child Cascade for Role pr_DEPT)-CVIN_FUND_DEPTs(CVIN_FUND_DEPT): R_DEPT->>CVIN_FUND_DEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CVIN_FUND_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CVIN_FUND_DEPTImpl.class ) )
         {
            this.childCascadeFor_CVIN_FUND_DEPTs();
         }
         // Child Cascade for Role pr4L3ReqToRDept(R_DEPT)-RDeptToCvinStru44L3Req(CVIN_STRU44L3_REQ): R_DEPT->>CVIN_STRU44L3_REQ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CVIN_STRU44L3_REQImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CVIN_STRU44L3_REQImpl.class ) )
         {
            this.childCascadeFor_RDeptToCvinStru44L3Req();
         }
         // Child Cascade for Role pr5L3ReqToDept(R_DEPT)-DeptToCvinStru45L3Req(CVIN_STRU45L3_REQ): R_DEPT->>CVIN_STRU45L3_REQ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CVIN_STRU45L3_REQImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CVIN_STRU45L3_REQImpl.class ) )
         {
            this.childCascadeFor_DeptToCvinStru45L3Req();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToUnitProg(CVIN_UNIT_PROG): R_DEPT->>CVIN_UNIT_PROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CVIN_UNIT_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CVIN_UNIT_PROGImpl.class ) )
         {
            this.childCascadeFor_DeptToUnitProg();
         }
         // Child Cascade for Role pr_DEPT)-DOC_COAs28(DOC_COA): R_DEPT->>DOC_COA
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(DOC_COAImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( DOC_COAImpl.class ) )
         {
            this.childCascadeFor_DOC_COAs28();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptDocIntCoa(DOC_INT_COA): R_DEPT->>DOC_INT_COA
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(DOC_INT_COAImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( DOC_INT_COAImpl.class ) )
         {
            this.childCascadeFor_DeptDocIntCoa();
         }
         // Child Cascade for Role prToRDept(R_DEPT)-RDeptToGtDocComn(GT_DOC_COMN): R_DEPT->>GT_DOC_COMN
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_COMNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_COMNImpl.class ) )
         {
            this.childCascadeFor_RDeptToGtDocComn();
         }
         // Child Cascade for Role prfUsrToDept(R_DEPT)-DeptToGtDocNotifUsr(GT_DOC_NOTIFUSR): R_DEPT->>GT_DOC_NOTIFUSR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_NOTIFUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_NOTIFUSRImpl.class ) )
         {
            this.childCascadeFor_DeptToGtDocNotifUsr();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToGtDocOpty(GT_DOC_OPTY): R_DEPT->>GT_DOC_OPTY
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_OPTYImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_OPTYImpl.class ) )
         {
            this.childCascadeFor_DeptToGtDocOpty();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToGtDocResp(GT_DOC_RESP): R_DEPT->>GT_DOC_RESP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_RESPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_RESPImpl.class ) )
         {
            this.childCascadeFor_DeptToGtDocResp();
         }
         // Child Cascade for Role prncOtypToDept(R_DEPT)-DeptToInfApprFuncOtyp(INF_APPR_FUNC_OTYP): R_DEPT->>INF_APPR_FUNC_OTYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_APPR_FUNC_OTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_APPR_FUNC_OTYPImpl.class ) )
         {
            this.childCascadeFor_DeptToInfApprFuncOtyp();
         }
         // Child Cascade for Role prcApprInf(R_DEPT)-RsrcApprInfRecs(INF_APPR_RSRC): R_DEPT->>INF_APPR_RSRC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_APPR_RSRCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_APPR_RSRCImpl.class ) )
         {
            this.childCascadeFor_RsrcApprInfRecs();
         }
         // Child Cascade for Role pr_DEPT)-INF_BFYs1(INF_BFY): R_DEPT->>INF_BFY
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_BFYImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_BFYImpl.class ) )
         {
            this.childCascadeFor_INF_BFYs1();
         }
         // Child Cascade for Role prDeptUnit(R_DEPT)-InfDeptUnitToDept(INF_DEPT_UNIT): R_DEPT->>INF_DEPT_UNIT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_DEPT_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_DEPT_UNITImpl.class ) )
         {
            this.childCascadeFor_InfDeptUnitToDept();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToInfFpi6(INF_FPI_6): R_DEPT->>INF_FPI_6
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPI_6Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPI_6Impl.class ) )
         {
            this.childCascadeFor_DeptToInfFpi6();
         }
         // Child Cascade for Role pr_DEPT)-INF_FPRL_12(INF_FPRL_1): R_DEPT->>INF_FPRL_1
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPRL_1Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPRL_1Impl.class ) )
         {
            this.childCascadeFor_INF_FPRL_12();
         }
         // Child Cascade for Role prR_DEPT)-INF_FPRL_21(INF_FPRL_2): R_DEPT->>INF_FPRL_2
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPRL_2Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPRL_2Impl.class ) )
         {
            this.childCascadeFor_INF_FPRL_21();
         }
         // Child Cascade for Role prR_DEPT)-INF_FPRL_32(INF_FPRL_3): R_DEPT->>INF_FPRL_3
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPRL_3Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPRL_3Impl.class ) )
         {
            this.childCascadeFor_INF_FPRL_32();
         }
         // Child Cascade for Role prFprfl4(R_DEPT)-InfFprfl4Recs(INF_FPRL_4): R_DEPT->>INF_FPRL_4
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPRL_4Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPRL_4Impl.class ) )
         {
            this.childCascadeFor_InfFprfl4Recs();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToInfFprl5(INF_FPRL_5): R_DEPT->>INF_FPRL_5
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPRL_5Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPRL_5Impl.class ) )
         {
            this.childCascadeFor_DeptToInfFprl5();
         }
         // Child Cascade for Role proRDept(R_DEPT)-RDeptToInfFprlO(INF_FPRL_O): R_DEPT->>INF_FPRL_O
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPRL_OImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPRL_OImpl.class ) )
         {
            this.childCascadeFor_RDeptToInfFprlO();
         }
         // Child Cascade for Role prtToLcnToDept(R_DEPT)-DeptToInfFprlActToLcn(INF_FPRL_ACTV_LOC): R_DEPT->>INF_FPRL_ACTV_LOC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FPRL_ACTV_LOCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FPRL_ACTV_LOCImpl.class ) )
         {
            this.childCascadeFor_DeptToInfFprlActToLcn();
         }
         // Child Cascade for Role prndProgToDept(R_DEPT)-DeptToInfFuncFundProg(INF_FUNC_FUND_PROG): R_DEPT->>INF_FUNC_FUND_PROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FUNC_FUND_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FUNC_FUND_PROGImpl.class ) )
         {
            this.childCascadeFor_DeptToInfFuncFundProg();
         }
         // Child Cascade for Role prR_DEPT)-INF_FUND_FUNC_ACTVs1(INF_FUND_FUNC_ACTV): R_DEPT->>INF_FUND_FUNC_ACTV
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_FUND_FUNC_ACTVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_FUND_FUNC_ACTVImpl.class ) )
         {
            this.childCascadeFor_INF_FUND_FUNC_ACTVs1();
         }
         // Child Cascade for Role prI(R_DEPT)-GFPIToDept(INF_GRNT_FP): R_DEPT->>INF_GRNT_FP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_GRNT_FPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_GRNT_FPImpl.class ) )
         {
            this.childCascadeFor_GFPIToDept();
         }
         // Child Cascade for Role prObjOtyp(R_DEPT)-InfObjOtypToDept(INF_OBJ_OTYP): R_DEPT->>INF_OBJ_OTYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_OBJ_OTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_OBJ_OTYPImpl.class ) )
         {
            this.childCascadeFor_InfObjOtypToDept();
         }
         // Child Cascade for Role prR_DEPT)-INF_PHASE_PROGs(INF_PHASE_PROG): R_DEPT->>INF_PHASE_PROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_PHASE_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_PHASE_PROGImpl.class ) )
         {
            this.childCascadeFor_INF_PHASE_PROGs();
         }
         // Child Cascade for Role prI(R_DEPT)-PFPIToDept(INF_PROJ_FP): R_DEPT->>INF_PROJ_FP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_PROJ_FPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_PROJ_FPImpl.class ) )
         {
            this.childCascadeFor_PFPIToDept();
         }
         // Child Cascade for Role prSrcInf(R_DEPT)-RevSrcInfToDept(INF_REV_SRC): R_DEPT->>INF_REV_SRC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_REV_SRCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_REV_SRCImpl.class ) )
         {
            this.childCascadeFor_RevSrcInfToDept();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToInfUnit(INF_UNIT): R_DEPT->>INF_UNIT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_UNITImpl.class ) )
         {
            this.childCascadeFor_DeptToInfUnit();
         }
         // Child Cascade for Role prtDept(R_DEPT)-DeptMaAuthDept(MA_DOC_AUTHDEPT): R_DEPT->>MA_DOC_AUTHDEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(MA_DOC_AUTHDEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( MA_DOC_AUTHDEPTImpl.class ) )
         {
            this.childCascadeFor_DeptMaAuthDept();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToActgPrfl(R_ACTG_PRFL): R_DEPT->>R_ACTG_PRFL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ACTG_PRFLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ACTG_PRFLImpl.class ) )
         {
            this.childCascadeFor_DeptToActgPrfl();
         }
         // Child Cascade for Role prR_DEPT)-R_ACTG_TMPLs(R_ACTG_TMPL): R_DEPT->>R_ACTG_TMPL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ACTG_TMPLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ACTG_TMPLImpl.class ) )
         {
            this.childCascadeFor_R_ACTG_TMPLs();
         }
         // Child Cascade for Role prtToDept(R_DEPT)-DeptToStructDept(R_ALT_ORG_STRUCT): R_DEPT->>R_ALT_ORG_STRUCT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ALT_ORG_STRUCTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ALT_ORG_STRUCTImpl.class ) )
         {
            this.childCascadeFor_DeptToStructDept();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToApCwHdr(R_AP_CW_HDR): R_DEPT->>R_AP_CW_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_CW_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_CW_HDRImpl.class ) )
         {
            this.childCascadeFor_DeptToApCwHdr();
         }
         // Child Cascade for Role prR_DEPT)-R_AP_INCT_RQSTs2(R_AP_INCT_RQST): R_DEPT->>R_AP_INCT_RQST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_INCT_RQSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_INCT_RQSTImpl.class ) )
         {
            this.childCascadeFor_R_AP_INCT_RQSTs2();
         }
         // Child Cascade for Role proRDept(R_DEPT)-RDeptToRApdDept(R_APD_DEPT): R_DEPT->>R_APD_DEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_APD_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_APD_DEPTImpl.class ) )
         {
            this.childCascadeFor_RDeptToRApdDept();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToCitedAuth(R_CITED_AUTH): R_DEPT->>R_CITED_AUTH
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CITED_AUTHImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CITED_AUTHImpl.class ) )
         {
            this.childCascadeFor_DeptToCitedAuth();
         }
         // Child Cascade for Role prpt(R_DEPT)-DeptToCntac(R_CNTAC): R_DEPT->>R_CNTAC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CNTACImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CNTACImpl.class ) )
         {
            this.childCascadeFor_DeptToCntac();
         }
         // Child Cascade for Role prR_DEPT)-R_COMM_FA_THLDs1(R_COMM_FA_THLD): R_DEPT->>R_COMM_FA_THLD
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_COMM_FA_THLDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_COMM_FA_THLDImpl.class ) )
         {
            this.childCascadeFor_R_COMM_FA_THLDs1();
         }
         // Child Cascade for Role prR_DEPT)-R_COMM_OBJs1(R_COMM_OBJ): R_DEPT->>R_COMM_OBJ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_COMM_OBJImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_COMM_OBJImpl.class ) )
         {
            this.childCascadeFor_R_COMM_OBJs1();
         }
         // Child Cascade for Role prept(R_DEPT)-DeptToDeptFY(R_DEPT_FY): R_DEPT->>R_DEPT_FY
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DEPT_FYImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DEPT_FYImpl.class ) )
         {
            this.childCascadeFor_DeptToDeptFY();
         }
         // Child Cascade for Role prymtCtrlToRDept(R_DEPT)-RDeptToRDeptObjPymtCtrl(R_DEPT_OBJ_PYCTRL): R_DEPT->>R_DEPT_OBJ_PYCTRL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DEPT_OBJ_PYCTRLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DEPT_OBJ_PYCTRLImpl.class ) )
         {
            this.childCascadeFor_RDeptToRDeptObjPymtCtrl();
         }
         // Child Cascade for Role prept(R_DEPT)-DeptToDISCIV(R_DISCIV): R_DEPT->>R_DISCIV
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DISCIVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DISCIVImpl.class ) )
         {
            this.childCascadeFor_DeptToDISCIV();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToDrwdwnGrp(R_DRWDWN_GRP): R_DEPT->>R_DRWDWN_GRP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DRWDWN_GRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DRWDWN_GRPImpl.class ) )
         {
            this.childCascadeFor_DeptToDrwdwnGrp();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToEscrowDef(R_ESCROW_DEF): R_DEPT->>R_ESCROW_DEF
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ESCROW_DEFImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ESCROW_DEFImpl.class ) )
         {
            this.childCascadeFor_DeptToEscrowDef();
         }
         // Child Cascade for Role prRDept(R_DEPT)-RDeptToRFesReq(R_FESREQ): R_DEPT->>R_FESREQ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FESREQImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FESREQImpl.class ) )
         {
            this.childCascadeFor_RDeptToRFesReq();
         }
         // Child Cascade for Role prcToRDept(R_DEPT)-RDeptToRFndgAlloc(R_FNDG_ALLOC): R_DEPT->>R_FNDG_ALLOC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FNDG_ALLOCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FNDG_ALLOCImpl.class ) )
         {
            this.childCascadeFor_RDeptToRFndgAlloc();
         }
         // Child Cascade for Role prRDept(R_DEPT)-RDeptToRFyDept(R_FY_DEPT): R_DEPT->>R_FY_DEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FY_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FY_DEPTImpl.class ) )
         {
            this.childCascadeFor_RDeptToRFyDept();
         }
         // Child Cascade for Role prToRDept(R_DEPT)-RDeptToRGrntAppl(R_GRNT_APPL): R_DEPT->>R_GRNT_APPL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_APPLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_APPLImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntAppl();
         }
         // Child Cascade for Role prplToRDept(R_DEPT)-RDeptToRGrntDtTmpl(R_GRNT_DT_TMPL): R_DEPT->>R_GRNT_DT_TMPL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_DT_TMPLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_DT_TMPLImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntDtTmpl();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToGrntOpty(R_GRNT_OPTY): R_DEPT->>R_GRNT_OPTY
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_OPTYImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_OPTYImpl.class ) )
         {
            this.childCascadeFor_DeptToGrntOpty();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToGrntResp(R_GRNT_RESP): R_DEPT->>R_GRNT_RESP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_RESPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_RESPImpl.class ) )
         {
            this.childCascadeFor_DeptToGrntResp();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToGrntUser(R_GRNT_USER): R_DEPT->>R_GRNT_USER
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_USERImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_USERImpl.class ) )
         {
            this.childCascadeFor_DeptToGrntUser();
         }
         // Child Cascade for Role prDEPT)-R_INTG_CTRL(R_INTG_CTRL): R_DEPT->>R_INTG_CTRL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_INTG_CTRLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_INTG_CTRLImpl.class ) )
         {
            this.childCascadeFor_R_INTG_CTRL();
         }
         // Child Cascade for Role prR_DEPT)-R_MJR_PROGs3(R_MJR_PROG): R_DEPT->>R_MJR_PROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_MJR_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_MJR_PROGImpl.class ) )
         {
            this.childCascadeFor_R_MJR_PROGs3();
         }
         // Child Cascade for Role prardInfoToDepartment(R_DEPT)-DepartmentToOnGoingAwardInfo(R_ONGOING_AWD_INFO): R_DEPT->>R_ONGOING_AWD_INFO
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ONGOING_AWD_INFOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ONGOING_AWD_INFOImpl.class ) )
         {
            this.childCascadeFor_DepartmentToOnGoingAwardInfo();
         }
         // Child Cascade for Role prt(R_DEPT)-PerfEvalEvaluator(R_PE_EVALR): R_DEPT->>R_PE_EVALR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PE_EVALRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PE_EVALRImpl.class ) )
         {
            this.childCascadeFor_PerfEvalEvaluator();
         }
         // Child Cascade for Role prt(R_DEPT)-StateInstances(R_PRCU_ST): R_DEPT->>R_PRCU_ST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PRCU_STImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PRCU_STImpl.class ) )
         {
            this.childCascadeFor_StateInstances();
         }
         // Child Cascade for Role prDeptToRDept(R_DEPT)-RDeptToRPayHldByDept(R_PYMT_HLD_TYP_DPT): R_DEPT->>R_PYMT_HLD_TYP_DPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PYMT_HLD_TYP_DPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PYMT_HLD_TYP_DPTImpl.class ) )
         {
            this.childCascadeFor_RDeptToRPayHldByDept();
         }
         // Child Cascade for Role prR_DEPT)-R_STPF(R_STPF): R_DEPT->>R_STPF
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_STPFImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_STPFImpl.class ) )
         {
            this.childCascadeFor_R_STPF();
         }
         // Child Cascade for Role prt(R_DEPT)-UniversalRequestorControls(R_UR_CTRL): R_DEPT->>R_UR_CTRL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_UR_CTRLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_UR_CTRLImpl.class ) )
         {
            this.childCascadeFor_UniversalRequestorControls();
         }
         // Child Cascade for Role prrGrpTmpl(R_DEPT)-UserGrpTmplToDept(R_USER_GRP_TMPL): R_DEPT->>R_USER_GRP_TMPL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_USER_GRP_TMPLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_USER_GRP_TMPLImpl.class ) )
         {
            this.childCascadeFor_UserGrpTmplToDept();
         }
         // Child Cascade for Role prR_DEPT)-R_VEND_LSTs2(R_VEND_LST): R_DEPT->>R_VEND_LST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_VEND_LSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_VEND_LSTImpl.class ) )
         {
            this.childCascadeFor_R_VEND_LSTs2();
         }
         // Child Cascade for Role prR_DEPT)-REQ_ACTV_SACTVs(REQ_ACTV_SACTV): R_DEPT->>REQ_ACTV_SACTV
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_ACTV_SACTVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_ACTV_SACTVImpl.class ) )
         {
            this.childCascadeFor_REQ_ACTV_SACTVs();
         }
         // Child Cascade for Role prR_DEPT)-REQ_DEPT_OBJ_REVs(REQ_DEPT_OBJ_REV): R_DEPT->>REQ_DEPT_OBJ_REV
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_DEPT_OBJ_REVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_DEPT_OBJ_REVImpl.class ) )
         {
            this.childCascadeFor_REQ_DEPT_OBJ_REVs();
         }
         // Child Cascade for Role prqFundDept(R_DEPT)-ReqFundDeptToRDept(REQ_FUND_DEPT): R_DEPT->>REQ_FUND_DEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_FUND_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_FUND_DEPTImpl.class ) )
         {
            this.childCascadeFor_ReqFundDeptToRDept();
         }
         // Child Cascade for Role prR_DEPT)-REQ_FUND_UNIT_OBJs(REQ_FUND_UNIT_OBJ): R_DEPT->>REQ_FUND_UNIT_OBJ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_FUND_UNIT_OBJImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_FUND_UNIT_OBJImpl.class ) )
         {
            this.childCascadeFor_REQ_FUND_UNIT_OBJs();
         }
         // Child Cascade for Role prR_DEPT)-REQ_FUND_UNIT_RSRCs(REQ_FUND_UNIT_RSRC): R_DEPT->>REQ_FUND_UNIT_RSRC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_FUND_UNIT_RSRCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_FUND_UNIT_RSRCImpl.class ) )
         {
            this.childCascadeFor_REQ_FUND_UNIT_RSRCs();
         }
         // Child Cascade for Role prR_DEPT)-REQ_UNITs(REQ_UNIT): R_DEPT->>REQ_UNIT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_UNITImpl.class ) )
         {
            this.childCascadeFor_REQ_UNITs();
         }
         // Child Cascade for Role progToDept(R_DEPT)-DeptToReqUnitProg(REQ_UNIT_PROG): R_DEPT->>REQ_UNIT_PROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_UNIT_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_UNIT_PROGImpl.class ) )
         {
            this.childCascadeFor_DeptToReqUnitProg();
         }
         // Child Cascade for Role prR_DEPT)-REQ_UNIT_SUNITs(REQ_UNIT_SUNIT): R_DEPT->>REQ_UNIT_SUNIT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(REQ_UNIT_SUNITImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( REQ_UNIT_SUNITImpl.class ) )
         {
            this.childCascadeFor_REQ_UNIT_SUNITs();
         }
         // Child Cascade for Role prtParm(R_DEPT)-R_OTPT_PARM_DETs3(R_OTPT_PARM_DET): R_DEPT->>R_OTPT_PARM_DET
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_OTPT_PARM_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_OTPT_PARM_DETImpl.class ) )
         {
            this.childCascadeFor_R_OTPT_PARM_DETs3();
         }
         // Child Cascade for Role prtSchedToRDept2(R_DEPT)-RDeptToRGrntrEvntSched2(R_GRNTR_EVNT_SCHED): R_DEPT->>R_GRNTR_EVNT_SCHED
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNTR_EVNT_SCHEDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNTR_EVNT_SCHEDImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntrEvntSched2();
         }
         // Child Cascade for Role prFaroParm(R_DEPT)-R_FARO_PARMs3(R_FARO_PARM): R_DEPT->>R_FARO_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FARO_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FARO_PARMImpl.class ) )
         {
            this.childCascadeFor_R_FARO_PARMs3();
         }
         // Child Cascade for Role prept1(R_DEPT)-DeptToClmtrk1(R_CLMTRK): R_DEPT->>R_CLMTRK
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CLMTRKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CLMTRKImpl.class ) )
         {
            this.childCascadeFor_DeptToClmtrk1();
         }
         // Child Cascade for Role prMgmtUsrToRDept(R_DEPT)-RDeptToGtDocProgMgmtUsr(GT_DOC_PMGMTUSR): R_DEPT->>GT_DOC_PMGMTUSR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_PMGMTUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_PMGMTUSRImpl.class ) )
         {
            this.childCascadeFor_RDeptToGtDocProgMgmtUsr();
         }
         // Child Cascade for Role prDEPT)-ACRL_CLR_EXCL(ACRL_CLR_EXCL): R_DEPT->>ACRL_CLR_EXCL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ACRL_CLR_EXCLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ACRL_CLR_EXCLImpl.class ) )
         {
            this.childCascadeFor_ACRL_CLR_EXCL();
         }
         // Child Cascade for Role prDEPT)-RQ_DOC_CMPSHT(RQ_DOC_CMPSHT): R_DEPT->>RQ_DOC_CMPSHT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(RQ_DOC_CMPSHTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( RQ_DOC_CMPSHTImpl.class ) )
         {
            this.childCascadeFor_RQ_DOC_CMPSHT();
         }
         // Child Cascade for Role prR_DEPT)-R_MJR_PGRPs1(R_MJR_PGRP): R_DEPT->>R_MJR_PGRP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_MJR_PGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_MJR_PGRPImpl.class ) )
         {
            this.childCascadeFor_R_MJR_PGRPs1();
         }
         // Child Cascade for Role prIntrActg(R_DEPT)-IntrActgToDocDept(R_INTR_ACTG_CRSWLK): R_DEPT->>R_INTR_ACTG_CRSWLK
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_INTR_ACTG_CRSWLKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_INTR_ACTG_CRSWLKImpl.class ) )
         {
            this.childCascadeFor_IntrActgToDocDept();
         }
         // Child Cascade for Role prpat(R_DEPT)-FacpatToDept(R_FACPAT): R_DEPT->>R_FACPAT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FACPATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FACPATImpl.class ) )
         {
            this.childCascadeFor_FacpatToDept();
         }
         // Child Cascade for Role prpad(R_DEPT)-FacpadToDept(R_FACPAD): R_DEPT->>R_FACPAD
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FACPADImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FACPADImpl.class ) )
         {
            this.childCascadeFor_FacpadToDept();
         }
         // Child Cascade for Role prR_DEPT)-R_DOCATs1(R_DOCAT): R_DEPT->>R_DOCAT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DOCATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DOCATImpl.class ) )
         {
            this.childCascadeFor_R_DOCATs1();
         }
         // Child Cascade for Role prpnd_RDept(R_DEPT)-RDept_RBfyStpfSpnd(R_BFY_STPF_SPND): R_DEPT->>R_BFY_STPF_SPND
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_BFY_STPF_SPNDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_BFY_STPF_SPNDImpl.class ) )
         {
            this.childCascadeFor_RDept_RBfyStpfSpnd();
         }
         // Child Cascade for Role prR_DEPT)-R_AP_DISB_PARMs3(R_AP_DISB_PARM): R_DEPT->>R_AP_DISB_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_DISB_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_DISB_PARMImpl.class ) )
         {
            this.childCascadeFor_R_AP_DISB_PARMs3();
         }
         // Child Cascade for Role prcHdr(R_DEPT)-MMRDocHdrDept(MMR_DOC_HDR): R_DEPT->>MMR_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(MMR_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( MMR_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_MMRDocHdrDept();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToMaSrtyIns(MA_DOC_SRTYINS): R_DEPT->>MA_DOC_SRTYINS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(MA_DOC_SRTYINSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( MA_DOC_SRTYINSImpl.class ) )
         {
            this.childCascadeFor_DeptToMaSrtyIns();
         }
         // Child Cascade for Role prdCToDept(R_DEPT)-DeptToFndCDocFndC(FNDC_DOC_FNDC): R_DEPT->>FNDC_DOC_FNDC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(FNDC_DOC_FNDCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( FNDC_DOC_FNDCImpl.class ) )
         {
            this.childCascadeFor_DeptToFndCDocFndC();
         }
         // Child Cascade for Role prToRqstDept(R_DEPT)-RqstDeptToCMRDocHdr(CMR_DOC_HDR): R_DEPT->>CMR_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CMR_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CMR_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_RqstDeptToCMRDocHdr();
         }
         // Child Cascade for Role prR_DEPT)-R_TASKs1(R_TASK): R_DEPT->>R_TASK
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_TASKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_TASKImpl.class ) )
         {
            this.childCascadeFor_R_TASKs1();
         }
         // Child Cascade for Role prnToRDept(R_DEPT)-RDeptToRPayHldTin(R_PYMT_HLD_TIN): R_DEPT->>R_PYMT_HLD_TIN
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PYMT_HLD_TINImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PYMT_HLD_TINImpl.class ) )
         {
            this.childCascadeFor_RDeptToRPayHldTin();
         }
         // Child Cascade for Role prpt(R_DEPT)-RDeptToRFsc(R_FSC): R_DEPT->>R_FSC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FSCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FSCImpl.class ) )
         {
            this.childCascadeFor_RDeptToRFsc();
         }
         // Child Cascade for Role prDEPT)-R_FIN_CHRG_SETP(R_FIN_CHRG_SETP): R_DEPT->>R_FIN_CHRG_SETP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FIN_CHRG_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FIN_CHRG_SETPImpl.class ) )
         {
            this.childCascadeFor_R_FIN_CHRG_SETP();
         }
         // Child Cascade for Role prFaroParm(R_DEPT)-R_FARO_PARMs2(R_FARO_PARM): R_DEPT->>R_FARO_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FARO_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FARO_PARMImpl.class ) )
         {
            this.childCascadeFor_R_FARO_PARMs2();
         }
         // Child Cascade for Role prnToRDept1(R_DEPT)-RDeptToRCntrcGlln1(R_CNTRC_GOAL_LN): R_DEPT->>R_CNTRC_GOAL_LN
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CNTRC_GOAL_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CNTRC_GOAL_LNImpl.class ) )
         {
            this.childCascadeFor_RDeptToRCntrcGlln1();
         }
         // Child Cascade for Role prsa_RDept(R_DEPT)-RDept_RBfyStpfBsa(R_BFY_STPF_BSA): R_DEPT->>R_BFY_STPF_BSA
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_BFY_STPF_BSAImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_BFY_STPF_BSAImpl.class ) )
         {
            this.childCascadeFor_RDept_RBfyStpfBsa();
         }
         // Child Cascade for Role proRDept(R_DEPT)-RDeptToRAdcParm(R_ADC_PARM): R_DEPT->>R_ADC_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ADC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ADC_PARMImpl.class ) )
         {
            this.childCascadeFor_RDeptToRAdcParm();
         }
         // Child Cascade for Role prrUsrToRDept(R_DEPT)-RDeptToGtDocPrtnrUsr(GT_DOC_PRTNRUSR): R_DEPT->>GT_DOC_PRTNRUSR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_PRTNRUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_PRTNRUSRImpl.class ) )
         {
            this.childCascadeFor_RDeptToGtDocPrtnrUsr();
         }
         // Child Cascade for Role prarmToRdept(R_DEPT)-RdeptToCsalProcParm(CSAL_PROC_PARM): R_DEPT->>CSAL_PROC_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CSAL_PROC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CSAL_PROC_PARMImpl.class ) )
         {
            this.childCascadeFor_RdeptToCsalProcParm();
         }
         // Child Cascade for Role prnt(R_DEPT)-VmPrvntDept(VCM_DOC_PRVNT): R_DEPT->>VCM_DOC_PRVNT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(VCM_DOC_PRVNTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( VCM_DOC_PRVNTImpl.class ) )
         {
            this.childCascadeFor_VmPrvntDept();
         }
         // Child Cascade for Role prPrflToRDept(R_DEPT)-RDeptToRUtlyActgPrfl(R_UTLY_ACTG_PRFL): R_DEPT->>R_UTLY_ACTG_PRFL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_UTLY_ACTG_PRFLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_UTLY_ACTG_PRFLImpl.class ) )
         {
            this.childCascadeFor_RDeptToRUtlyActgPrfl();
         }
         // Child Cascade for Role prR_DEPT)-R_UNITs2(R_UNIT): R_DEPT->>R_UNIT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_UNITImpl.class ) )
         {
            this.childCascadeFor_R_UNITs2();
         }
         // Child Cascade for Role prR_DEPT)-R_TASK_ORDs1(R_TASK_ORD): R_DEPT->>R_TASK_ORD
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_TASK_ORDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_TASK_ORDImpl.class ) )
         {
            this.childCascadeFor_R_TASK_ORDs1();
         }
         // Child Cascade for Role prpt(R_DEPT)-RDeptToRRgn(R_RGN): R_DEPT->>R_RGN
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_RGNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_RGNImpl.class ) )
         {
            this.childCascadeFor_RDeptToRRgn();
         }
         // Child Cascade for Role prR_DEPT)-R_PGRPs1(R_PGRP): R_DEPT->>R_PGRP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PGRPImpl.class ) )
         {
            this.childCascadeFor_R_PGRPs1();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToPartUsg(R_PART_USG): R_DEPT->>R_PART_USG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PART_USGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PART_USGImpl.class ) )
         {
            this.childCascadeFor_DeptToPartUsg();
         }
         // Child Cascade for Role prR_DEPT)-R_MJR_PTYPs1(R_MJR_PTYP): R_DEPT->>R_MJR_PTYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_MJR_PTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_MJR_PTYPImpl.class ) )
         {
            this.childCascadeFor_R_MJR_PTYPs1();
         }
         // Child Cascade for Role prR_DEPT)-R_DSTCs1(R_DSTC): R_DEPT->>R_DSTC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DSTCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DSTCImpl.class ) )
         {
            this.childCascadeFor_R_DSTCs1();
         }
         // Child Cascade for Role prnToRDept(R_DEPT)-RDeptToRCntrcGlln(R_CNTRC_GOAL_LN): R_DEPT->>R_CNTRC_GOAL_LN
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CNTRC_GOAL_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CNTRC_GOAL_LNImpl.class ) )
         {
            this.childCascadeFor_RDeptToRCntrcGlln();
         }
         // Child Cascade for Role prshSweep(R_DEPT)-RCashSweepToRDept(R_CASH_SW_SETP): R_DEPT->>R_CASH_SW_SETP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CASH_SW_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CASH_SW_SETPImpl.class ) )
         {
            this.childCascadeFor_RCashSweepToRDept();
         }
         // Child Cascade for Role prR_DEPT)-R_AP_CLM_ACCTs1(R_AP_CLM_ACCT): R_DEPT->>R_AP_CLM_ACCT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_CLM_ACCTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_CLM_ACCTImpl.class ) )
         {
            this.childCascadeFor_R_AP_CLM_ACCTs1();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToAltDept(R_ALT_ORG_STRUCT): R_DEPT->>R_ALT_ORG_STRUCT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ALT_ORG_STRUCTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ALT_ORG_STRUCTImpl.class ) )
         {
            this.childCascadeFor_DeptToAltDept();
         }
         // Child Cascade for Role prR_DEPT)-ONLN_PRN_BAT_PARM1(ONLN_PRN_BAT_PARM): R_DEPT->>ONLN_PRN_BAT_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ONLN_PRN_BAT_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ONLN_PRN_BAT_PARMImpl.class ) )
         {
            this.childCascadeFor_ONLN_PRN_BAT_PARM1();
         }
         // Child Cascade for Role pr_DEPT)-INF_APPRs1(INF_APPR): R_DEPT->>INF_APPR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_APPRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_APPRImpl.class ) )
         {
            this.childCascadeFor_INF_APPRs1();
         }
         // Child Cascade for Role prserToRDept(R_DEPT)-RDeptToGtDocRptuser(GT_DOC_RPTUSER): R_DEPT->>GT_DOC_RPTUSER
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_RPTUSERImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_RPTUSERImpl.class ) )
         {
            this.childCascadeFor_RDeptToGtDocRptuser();
         }
         // Child Cascade for Role pr_DEPT)-DOC_HDRs(DOC_HDR): R_DEPT->>DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_DOC_HDRs();
         }
         // Child Cascade for Role prhDept(R_DEPT)-VmAuthDeptDept(VCM_DOC_AUTHDEPT): R_DEPT->>VCM_DOC_AUTHDEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(VCM_DOC_AUTHDEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( VCM_DOC_AUTHDEPTImpl.class ) )
         {
            this.childCascadeFor_VmAuthDeptDept();
         }
         // Child Cascade for Role prR_DEPT)-R_PRVNT_SPNDs(R_PRVNT_SPND): R_DEPT->>R_PRVNT_SPND
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PRVNT_SPNDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PRVNT_SPNDImpl.class ) )
         {
            this.childCascadeFor_R_PRVNT_SPNDs();
         }
         // Child Cascade for Role prept(R_DEPT)-DeptToPartRf(R_PART_RF): R_DEPT->>R_PART_RF
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PART_RFImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PART_RFImpl.class ) )
         {
            this.childCascadeFor_DeptToPartRf();
         }
         // Child Cascade for Role prToRDept(R_DEPT)-RDeptToRGrntrRpt(R_GRNTR_RPT): R_DEPT->>R_GRNTR_RPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNTR_RPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNTR_RPTImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntrRpt();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToDebtAuth(R_DEBT_AUTH): R_DEPT->>R_DEBT_AUTH
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DEBT_AUTHImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DEBT_AUTHImpl.class ) )
         {
            this.childCascadeFor_DeptToDebtAuth();
         }
         // Child Cascade for Role prrSetpToRdept(R_DEPT)-RdeptToRcsalSrctrSetp(R_CSAL_SRCTR_SETP): R_DEPT->>R_CSAL_SRCTR_SETP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CSAL_SRCTR_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CSAL_SRCTR_SETPImpl.class ) )
         {
            this.childCascadeFor_RdeptToRcsalSrctrSetp();
         }
         // Child Cascade for Role prrcuAlToRDept(R_DEPT)-RDeptToRApUprocPrcuAl(R_AP_UPROC_PRCU_AL): R_DEPT->>R_AP_UPROC_PRCU_AL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_UPROC_PRCU_ALImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_UPROC_PRCU_ALImpl.class ) )
         {
            this.childCascadeFor_RDeptToRApUprocPrcuAl();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToApCwChk(R_AP_CW_CHK_NO): R_DEPT->>R_AP_CW_CHK_NO
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_CW_CHK_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_CW_CHK_NOImpl.class ) )
         {
            this.childCascadeFor_DeptToApCwChk();
         }
         // Child Cascade for Role prToRDept1(R_DEPT)-RDept1ToRAdcParm1(R_ADC_PARM): R_DEPT->>R_ADC_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ADC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ADC_PARMImpl.class ) )
         {
            this.childCascadeFor_RDept1ToRAdcParm1();
         }
         // Child Cascade for Role prpt(R_DEPT)-DeptToMDHdr(MD_DOC_HDR): R_DEPT->>MD_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(MD_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( MD_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_DeptToMDHdr();
         }
         // Child Cascade for Role prrmToDept(R_DEPT)-DeptToCamProcParm(CAM_PROC_PARM): R_DEPT->>CAM_PROC_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(CAM_PROC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( CAM_PROC_PARMImpl.class ) )
         {
            this.childCascadeFor_DeptToCamProcParm();
         }
         // Child Cascade for Role prSetpToRdept(R_DEPT)-RdeptToRstatUnitSetp(R_STAT_UNIT_SETP): R_DEPT->>R_STAT_UNIT_SETP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_STAT_UNIT_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_STAT_UNIT_SETPImpl.class ) )
         {
            this.childCascadeFor_RdeptToRstatUnitSetp();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToProgSta(R_PROG_STA): R_DEPT->>R_PROG_STA
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PROG_STAImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PROG_STAImpl.class ) )
         {
            this.childCascadeFor_DeptToProgSta();
         }
         // Child Cascade for Role prR_DEPT)-R_PROGs2(R_PROG): R_DEPT->>R_PROG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PROGImpl.class ) )
         {
            this.childCascadeFor_R_PROGs2();
         }
         // Child Cascade for Role prardInfoToDept(R_DEPT)-DeptToOnGoingAwardInfo(R_ONGOING_AWD_INFO): R_DEPT->>R_ONGOING_AWD_INFO
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ONGOING_AWD_INFOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ONGOING_AWD_INFOImpl.class ) )
         {
            this.childCascadeFor_DeptToOnGoingAwardInfo();
         }
         // Child Cascade for Role prDrawExcpDtl(R_DEPT)-NegDrawExcpDtlRecs(R_NEG_DRW_EXCP_DTL): R_DEPT->>R_NEG_DRW_EXCP_DTL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_NEG_DRW_EXCP_DTLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_NEG_DRW_EXCP_DTLImpl.class ) )
         {
            this.childCascadeFor_NegDrawExcpDtlRecs();
         }
         // Child Cascade for Role prR_DEPT)-R_LCLSs1(R_LCLS): R_DEPT->>R_LCLS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_LCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_LCLSImpl.class ) )
         {
            this.childCascadeFor_R_LCLSs1();
         }
         // Child Cascade for Role prUsrToDept(R_DEPT)-DeptToGrntNotifUsr(R_GRNT_NOTIFUSR): R_DEPT->>R_GRNT_NOTIFUSR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_NOTIFUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_NOTIFUSRImpl.class ) )
         {
            this.childCascadeFor_DeptToGrntNotifUsr();
         }
         // Child Cascade for Role prToRDept2(R_DEPT)-RDept2ToRAdcParm2(R_ADC_PARM): R_DEPT->>R_ADC_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ADC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ADC_PARMImpl.class ) )
         {
            this.childCascadeFor_RDept2ToRAdcParm2();
         }
         // Child Cascade for Role prR_DEPT)-R_ACATs1(R_ACAT): R_DEPT->>R_ACAT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ACATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ACATImpl.class ) )
         {
            this.childCascadeFor_R_ACATs1();
         }
         // Child Cascade for Role prds(R_DEPT)-LrdsToDept1(LIC_RNEW_DT_STRG): R_DEPT->>LIC_RNEW_DT_STRG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(LIC_RNEW_DT_STRGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( LIC_RNEW_DT_STRGImpl.class ) )
         {
            this.childCascadeFor_LrdsToDept1();
         }
         // Child Cascade for Role prs(R_DEPT)-LrdsToDept(LIC_RNEW_DT_STRG): R_DEPT->>LIC_RNEW_DT_STRG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(LIC_RNEW_DT_STRGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( LIC_RNEW_DT_STRGImpl.class ) )
         {
            this.childCascadeFor_LrdsToDept();
         }
         // Child Cascade for Role prcpQtrToDept(R_DEPT)-DeptToARRADocSRcpQtr(ARRA_DOC_SRCPQTR): R_DEPT->>ARRA_DOC_SRCPQTR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ARRA_DOC_SRCPQTRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ARRA_DOC_SRCPQTRImpl.class ) )
         {
            this.childCascadeFor_DeptToARRADocSRcpQtr();
         }
         // Child Cascade for Role prR_DEPT)-ACRL_CLR_MGMT_2(ACRL_CLR_MGMT): R_DEPT->>ACRL_CLR_MGMT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ACRL_CLR_MGMTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ACRL_CLR_MGMTImpl.class ) )
         {
            this.childCascadeFor_ACRL_CLR_MGMT_2();
         }
         // Child Cascade for Role prVLCoaOVrd(R_DEPT)-TRVLCoaOVrdToRDept(TRVL_COA_OVRD): R_DEPT->>TRVL_COA_OVRD
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(TRVL_COA_OVRDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( TRVL_COA_OVRDImpl.class ) )
         {
            this.childCascadeFor_TRVLCoaOVrdToRDept();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToSrcOfFund(R_SRC_OF_FUND): R_DEPT->>R_SRC_OF_FUND
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_SRC_OF_FUNDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_SRC_OF_FUNDImpl.class ) )
         {
            this.childCascadeFor_DeptToSrcOfFund();
         }
         // Child Cascade for Role prR_DEPT)-R_REIM_GEN_PARAM(R_REIM_GEN_PARAM): R_DEPT->>R_REIM_GEN_PARAM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_REIM_GEN_PARAMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_REIM_GEN_PARAMImpl.class ) )
         {
            this.childCascadeFor_R_REIM_GEN_PARAM();
         }
         // Child Cascade for Role prjToDocDept(R_DEPT)-DocDeptToReimExpAdj(R_REIM_EXP_ADJ): R_DEPT->>R_REIM_EXP_ADJ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_REIM_EXP_ADJImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_REIM_EXP_ADJImpl.class ) )
         {
            this.childCascadeFor_DocDeptToReimExpAdj();
         }
         // Child Cascade for Role prAIntnExcep(R_DEPT)-RFAIntnExcepToRDept(R_FA_INTN_EXCEPT): R_DEPT->>R_FA_INTN_EXCEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FA_INTN_EXCEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FA_INTN_EXCEPTImpl.class ) )
         {
            this.childCascadeFor_RFAIntnExcepToRDept();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToDebtHist1(R_DEBT_HIST): R_DEPT->>R_DEBT_HIST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DEBT_HISTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DEBT_HISTImpl.class ) )
         {
            this.childCascadeFor_DeptToDebtHist1();
         }
         // Child Cascade for Role prR_DEPT)-R_CORSPDs1(R_CORSPD): R_DEPT->>R_CORSPD
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CORSPDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CORSPDImpl.class ) )
         {
            this.childCascadeFor_R_CORSPDs1();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToCWCanParm(R_AP_CWCAN_PARM): R_DEPT->>R_AP_CWCAN_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_CWCAN_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_CWCAN_PARMImpl.class ) )
         {
            this.childCascadeFor_DeptToCWCanParm();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToAutoCano(AUTO_CA_NO): R_DEPT->>AUTO_CA_NO
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(AUTO_CA_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( AUTO_CA_NOImpl.class ) )
         {
            this.childCascadeFor_DeptToAutoCano();
         }
         // Child Cascade for Role prLCoaOvrd(R_DEPT)-TRVLCoaOvrdToDept(TRVL_COA_OVRD): R_DEPT->>TRVL_COA_OVRD
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(TRVL_COA_OVRDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( TRVL_COA_OVRDImpl.class ) )
         {
            this.childCascadeFor_TRVLCoaOvrdToDept();
         }
         // Child Cascade for Role pryrLn1ToDept1(R_DEPT)-Dept1ToTaskOrdBuyrLn1(R_TASK_ORD_BUYR_LN): R_DEPT->>R_TASK_ORD_BUYR_LN
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_TASK_ORD_BUYR_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_TASK_ORD_BUYR_LNImpl.class ) )
         {
            this.childCascadeFor_Dept1ToTaskOrdBuyrLn1();
         }
         // Child Cascade for Role pryrLnToDept(R_DEPT)-DeptToTaskOrdBuyrLn(R_TASK_ORD_BUYR_LN): R_DEPT->>R_TASK_ORD_BUYR_LN
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_TASK_ORD_BUYR_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_TASK_ORD_BUYR_LNImpl.class ) )
         {
            this.childCascadeFor_DeptToTaskOrdBuyrLn();
         }
         // Child Cascade for Role prR_DEPT)-R_SYS_CROSWALKs(R_SYS_CROSWALK): R_DEPT->>R_SYS_CROSWALK
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_SYS_CROSWALKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_SYS_CROSWALKImpl.class ) )
         {
            this.childCascadeFor_R_SYS_CROSWALKs();
         }
         // Child Cascade for Role prR_DEPT)-R_PTYPs1(R_PTYP): R_DEPT->>R_PTYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PTYPImpl.class ) )
         {
            this.childCascadeFor_R_PTYPs1();
         }
         // Child Cascade for Role prReqToRdept(R_DEPT)-RdeptToRplbsOfstReq(R_PLBS_OFST_REQ): R_DEPT->>R_PLBS_OFST_REQ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PLBS_OFST_REQImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PLBS_OFST_REQImpl.class ) )
         {
            this.childCascadeFor_RdeptToRplbsOfstReq();
         }
         // Child Cascade for Role prToRdept(R_DEPT)-RdeptToRplbsDist(R_PLBS_DIST): R_DEPT->>R_PLBS_DIST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PLBS_DISTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PLBS_DISTImpl.class ) )
         {
            this.childCascadeFor_RdeptToRplbsDist();
         }
         // Child Cascade for Role prToRDept1(R_DEPT)-RDeptToRGrntrRpt1(R_GRNTR_RPT): R_DEPT->>R_GRNTR_RPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNTR_RPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNTR_RPTImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntrRpt1();
         }
         // Child Cascade for Role prR_DEPT)-R_FNCATs1(R_FNCAT): R_DEPT->>R_FNCAT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FNCATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FNCATImpl.class ) )
         {
            this.childCascadeFor_R_FNCATs1();
         }
         // Child Cascade for Role prtrSetpToRdept(R_DEPT)-RdeptToRcsalStpctrSetp(R_CSAL_STPCTR_SETP): R_DEPT->>R_CSAL_STPCTR_SETP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CSAL_STPCTR_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CSAL_STPCTR_SETPImpl.class ) )
         {
            this.childCascadeFor_RdeptToRcsalStpctrSetp();
         }
         // Child Cascade for Role prR_DEPT)-R_BURs1(R_BUR): R_DEPT->>R_BUR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_BURImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_BURImpl.class ) )
         {
            this.childCascadeFor_R_BURs1();
         }
         // Child Cascade for Role practg_RDept(R_DEPT)-RDept_RBfyStpfNactg(R_BFY_STPF_NACTG): R_DEPT->>R_BFY_STPF_NACTG
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_BFY_STPF_NACTGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_BFY_STPF_NACTGImpl.class ) )
         {
            this.childCascadeFor_RDept_RBfyStpfNactg();
         }
         // Child Cascade for Role prDEPT)-AUTO_DOC_NOs(AUTO_DOC_NO): R_DEPT->>AUTO_DOC_NO
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(AUTO_DOC_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( AUTO_DOC_NOImpl.class ) )
         {
            this.childCascadeFor_AUTO_DOC_NOs();
         }
         // Child Cascade for Role prept(R_DEPT)-RDeptVcVcust(VCC_DOC_VCUST): R_DEPT->>VCC_DOC_VCUST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(VCC_DOC_VCUSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( VCC_DOC_VCUSTImpl.class ) )
         {
            this.childCascadeFor_RDeptVcVcust();
         }
         // Child Cascade for Role prtRDept(R_DEPT)-RDeptVcAuthDept(VCC_DOC_AUTHDEPT): R_DEPT->>VCC_DOC_AUTHDEPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(VCC_DOC_AUTHDEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( VCC_DOC_AUTHDEPTImpl.class ) )
         {
            this.childCascadeFor_RDeptVcAuthDept();
         }
         // Child Cascade for Role prDEPT)-RQ_DOC_HDR(RQ_DOC_HDR): R_DEPT->>RQ_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(RQ_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( RQ_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_RQ_DOC_HDR();
         }
         // Child Cascade for Role prmReqRcycSel(R_DEPT)-ReimReqRcycSelToDept(R_REIMRQD_RCYCSEL): R_DEPT->>R_REIMRQD_RCYCSEL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_REIMRQD_RCYCSELImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_REIMRQD_RCYCSELImpl.class ) )
         {
            this.childCascadeFor_ReimReqRcycSelToDept();
         }
         // Child Cascade for Role prDept(R_DEPT)-RDeptToRPrtst(R_PRTST): R_DEPT->>R_PRTST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PRTSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PRTSTImpl.class ) )
         {
            this.childCascadeFor_RDeptToRPrtst();
         }
         // Child Cascade for Role prR_DEPT)-R_LOC_TBLs1(R_LOC_TBL): R_DEPT->>R_LOC_TBL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_LOC_TBLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_LOC_TBLImpl.class ) )
         {
            this.childCascadeFor_R_LOC_TBLs1();
         }
         // Child Cascade for Role prRDept1(R_DEPT)-RDept1ToRIntCst(R_INT_CST_PARM): R_DEPT->>R_INT_CST_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_INT_CST_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_INT_CST_PARMImpl.class ) )
         {
            this.childCascadeFor_RDept1ToRIntCst();
         }
         // Child Cascade for Role prtSchedToRDept(R_DEPT)-RDeptToRGrntrEvntSched(R_GRNTR_EVNT_SCHED): R_DEPT->>R_GRNTR_EVNT_SCHED
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNTR_EVNT_SCHEDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNTR_EVNT_SCHEDImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntrEvntSched();
         }
         // Child Cascade for Role prtToDept(R_DEPT)-DeptToEscrowHist(R_ESCROW_HIST): R_DEPT->>R_ESCROW_HIST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ESCROW_HISTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ESCROW_HISTImpl.class ) )
         {
            this.childCascadeFor_DeptToEscrowHist();
         }
         // Child Cascade for Role prR_DEPT)-R_DISB_MGMT_RSTRs2(R_DISB_MGMT_RSTR): R_DEPT->>R_DISB_MGMT_RSTR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DISB_MGMT_RSTRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DISB_MGMT_RSTRImpl.class ) )
         {
            this.childCascadeFor_R_DISB_MGMT_RSTRs2();
         }
         // Child Cascade for Role prbtInstToDept(R_DEPT)-DeptToDebtDocDebtInst(DEBT_DOC_DEBTINST): R_DEPT->>DEBT_DOC_DEBTINST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(DEBT_DOC_DEBTINSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( DEBT_DOC_DEBTINSTImpl.class ) )
         {
            this.childCascadeFor_DeptToDebtDocDebtInst();
         }
         // Child Cascade for Role prR_DEPT)-SO_DOC_HDRs2(SO_DOC_HDR): R_DEPT->>SO_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(SO_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( SO_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_SO_DOC_HDRs2();
         }
         // Child Cascade for Role prDept(R_DEPT)-RDeptToREquip(R_EQUIP): R_DEPT->>R_EQUIP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_EQUIPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_EQUIPImpl.class ) )
         {
            this.childCascadeFor_RDeptToREquip();
         }
         // Child Cascade for Role prR_DEPT)-R_DRSCLSs1(R_DRSCLS): R_DEPT->>R_DRSCLS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DRSCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DRSCLSImpl.class ) )
         {
            this.childCascadeFor_R_DRSCLSs1();
         }
         // Child Cascade for Role prR_DEPT)-R_DIVs1(R_DIV): R_DEPT->>R_DIV
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DIVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DIVImpl.class ) )
         {
            this.childCascadeFor_R_DIVs1();
         }
         // Child Cascade for Role proRDept(R_DEPT)-RDeptToPHMDocLn(PHM_DOC_LINE): R_DEPT->>PHM_DOC_LINE
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(PHM_DOC_LINEImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( PHM_DOC_LINEImpl.class ) )
         {
            this.childCascadeFor_RDeptToPHMDocLn();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToInfApBY2(INF_APBY2): R_DEPT->>INF_APBY2
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_APBY2Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_APBY2Impl.class ) )
         {
            this.childCascadeFor_DeptToInfApBY2();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToApEdiHdr(AP_EDI_HDR): R_DEPT->>AP_EDI_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(AP_EDI_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( AP_EDI_HDRImpl.class ) )
         {
            this.childCascadeFor_DeptToApEdiHdr();
         }
         // Child Cascade for Role prjToDept(R_DEPT)-DeptToReimExpAdj(R_REIM_EXP_ADJ): R_DEPT->>R_REIM_EXP_ADJ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_REIM_EXP_ADJImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_REIM_EXP_ADJImpl.class ) )
         {
            this.childCascadeFor_DeptToReimExpAdj();
         }
         // Child Cascade for Role prDocCrsRef(R_DEPT)-PrgDocCrsRefToDept(R_PROG_DOC_CRSREF): R_DEPT->>R_PROG_DOC_CRSREF
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PROG_DOC_CRSREFImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PROG_DOC_CRSREFImpl.class ) )
         {
            this.childCascadeFor_PrgDocCrsRefToDept();
         }
         // Child Cascade for Role prR_DEPT)-R_PHASEs(R_PHASE): R_DEPT->>R_PHASE
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PHASEImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PHASEImpl.class ) )
         {
            this.childCascadeFor_R_PHASEs();
         }
         // Child Cascade for Role prR_DEPT)-R_LOCs2(R_LOC): R_DEPT->>R_LOC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_LOCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_LOCImpl.class ) )
         {
            this.childCascadeFor_R_LOCs2();
         }
         // Child Cascade for Role prtToRDept(R_DEPT)-RDeptToRGrntDtDet(R_GRNT_DT_DET): R_DEPT->>R_GRNT_DT_DET
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_DT_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_DT_DETImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntDtDet();
         }
         // Child Cascade for Role prtSchedToRDept1(R_DEPT)-RDeptToRGrntrEvntSched1(R_GRNTR_EVNT_SCHED): R_DEPT->>R_GRNTR_EVNT_SCHED
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNTR_EVNT_SCHEDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNTR_EVNT_SCHEDImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntrEvntSched1();
         }
         // Child Cascade for Role prept(R_DEPT)-DeptToFDTOpt(R_FDT_OPT): R_DEPT->>R_FDT_OPT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FDT_OPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FDT_OPTImpl.class ) )
         {
            this.childCascadeFor_DeptToFDTOpt();
         }
         // Child Cascade for Role prR_DEPT)-R_DRSRCs1(R_DRSRC): R_DEPT->>R_DRSRC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DRSRCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DRSRCImpl.class ) )
         {
            this.childCascadeFor_R_DRSRCs1();
         }
         // Child Cascade for Role prR_DEPT)-R_DOCLSs1(R_DOCLS): R_DEPT->>R_DOCLS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DOCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DOCLSImpl.class ) )
         {
            this.childCascadeFor_R_DOCLSs1();
         }
         // Child Cascade for Role prSetpToRdept(R_DEPT)-RdeptToRcsalCtrlSetp(R_CSAL_CTRL_SETP): R_DEPT->>R_CSAL_CTRL_SETP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CSAL_CTRL_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CSAL_CTRL_SETPImpl.class ) )
         {
            this.childCascadeFor_RdeptToRcsalCtrlSetp();
         }
         // Child Cascade for Role prR_DEPT)-R_BUYR_FLINEs2(R_BUYR_FLINE): R_DEPT->>R_BUYR_FLINE
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_BUYR_FLINEImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_BUYR_FLINEImpl.class ) )
         {
            this.childCascadeFor_R_BUYR_FLINEs2();
         }
         // Child Cascade for Role pryDebtToDept(R_DEPT)-DeptToAlwPymntByDebt(R_ALW_PYMT_DBTYP): R_DEPT->>R_ALW_PYMT_DBTYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ALW_PYMT_DBTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ALW_PYMT_DBTYPImpl.class ) )
         {
            this.childCascadeFor_DeptToAlwPymntByDebt();
         }
         // Child Cascade for Role prudRule(R_DEPT)-GnBudRuleToDept(GN_BUD_RULE): R_DEPT->>GN_BUD_RULE
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GN_BUD_RULEImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GN_BUD_RULEImpl.class ) )
         {
            this.childCascadeFor_GnBudRuleToDept();
         }
         // Child Cascade for Role prR_DEPT)-R_RSTR_USEs(R_RSTR_USE): R_DEPT->>R_RSTR_USE
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_RSTR_USEImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_RSTR_USEImpl.class ) )
         {
            this.childCascadeFor_R_RSTR_USEs();
         }
         // Child Cascade for Role prc(R_DEPT)-R_FACCs(R_FACC): R_DEPT->>R_FACC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FACCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FACCImpl.class ) )
         {
            this.childCascadeFor_R_FACCs();
         }
         // Child Cascade for Role prT(R_DEPT)-ECRTToDept(R_EXTR_CASH_RECT): R_DEPT->>R_EXTR_CASH_RECT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_EXTR_CASH_RECTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_EXTR_CASH_RECTImpl.class ) )
         {
            this.childCascadeFor_ECRTToDept();
         }
         // Child Cascade for Role prR_DEPT)-R_DOGRPs1(R_DOGRP): R_DEPT->>R_DOGRP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DOGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DOGRPImpl.class ) )
         {
            this.childCascadeFor_R_DOGRPs1();
         }
         // Child Cascade for Role prept(R_DEPT)-DeptToClmtrk(R_CLMTRK): R_DEPT->>R_CLMTRK
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CLMTRKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CLMTRKImpl.class ) )
         {
            this.childCascadeFor_DeptToClmtrk();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToCADocHist(R_CA_DOC_HIST): R_DEPT->>R_CA_DOC_HIST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CA_DOC_HISTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CA_DOC_HISTImpl.class ) )
         {
            this.childCascadeFor_DeptToCADocHist();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToDisbExcp(R_AP_DISB_EXCP): R_DEPT->>R_AP_DISB_EXCP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_AP_DISB_EXCPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_AP_DISB_EXCPImpl.class ) )
         {
            this.childCascadeFor_DeptToDisbExcp();
         }
         // Child Cascade for Role prR_DEPT)-R_ACLSs1(R_ACLS): R_DEPT->>R_ACLS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ACLSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ACLSImpl.class ) )
         {
            this.childCascadeFor_R_ACLSs1();
         }
         // Child Cascade for Role prcFederalTaxPaymentSystemToDepartment(R_DEPT)-DepartmentToElectronicFederalTaxPaymentSystem(ELEC_FED_TAXP_SYS): R_DEPT->>ELEC_FED_TAXP_SYS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ELEC_FED_TAXP_SYSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ELEC_FED_TAXP_SYSImpl.class ) )
         {
            this.childCascadeFor_DepartmentToElectronicFederalTaxPaymentSystem();
         }
         // Child Cascade for Role prR_DEPT)-ACRL_CLR_MGMT_1(ACRL_CLR_MGMT): R_DEPT->>ACRL_CLR_MGMT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ACRL_CLR_MGMTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ACRL_CLR_MGMTImpl.class ) )
         {
            this.childCascadeFor_ACRL_CLR_MGMT_1();
         }
         // Child Cascade for Role prR_DEPT)-R_SECTs1(R_SECT): R_DEPT->>R_SECT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_SECTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_SECTImpl.class ) )
         {
            this.childCascadeFor_R_SECTs1();
         }
         // Child Cascade for Role prDocCrsRef1_1(R_DEPT)-PrgDocCrsRef1ToDept_1(R_PROG_DOC_CRSREF): R_DEPT->>R_PROG_DOC_CRSREF
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PROG_DOC_CRSREFImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PROG_DOC_CRSREFImpl.class ) )
         {
            this.childCascadeFor_PrgDocCrsRef1ToDept_1();
         }
         // Child Cascade for Role prrActg(R_DEPT)-IntrActgToDept(R_INTR_ACTG_CRSWLK): R_DEPT->>R_INTR_ACTG_CRSWLK
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_INTR_ACTG_CRSWLKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_INTR_ACTG_CRSWLKImpl.class ) )
         {
            this.childCascadeFor_IntrActgToDept();
         }
         // Child Cascade for Role prR_DEPT)-R_DOTYPs1(R_DOTYP): R_DEPT->>R_DOTYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DOTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DOTYPImpl.class ) )
         {
            this.childCascadeFor_R_DOTYPs1();
         }
         // Child Cascade for Role proRqstDept(R_DEPT)-RqstDeptToMaDocHdr(MA_DOC_HDR): R_DEPT->>MA_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(MA_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( MA_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_RqstDeptToMaDocHdr();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToInfAppr2(INF_APPR2): R_DEPT->>INF_APPR2
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_APPR2Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_APPR2Impl.class ) )
         {
            this.childCascadeFor_DeptToInfAppr2();
         }
         // Child Cascade for Role proDept(R_DEPT)-DeptToGRDocHdr(GR_DOC_HDR): R_DEPT->>GR_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GR_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GR_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_DeptToGRDocHdr();
         }
         // Child Cascade for Role prthToDept(R_DEPT)-DeptToDebtDocAuth(DEBT_DOC_AUTH): R_DEPT->>DEBT_DOC_AUTH
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(DEBT_DOC_AUTHImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( DEBT_DOC_AUTHImpl.class ) )
         {
            this.childCascadeFor_DeptToDebtDocAuth();
         }
         // Child Cascade for Role proToDept(R_DEPT)-DeptToAutoPartNo(AUTO_PART_NO): R_DEPT->>AUTO_PART_NO
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(AUTO_PART_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( AUTO_PART_NOImpl.class ) )
         {
            this.childCascadeFor_DeptToAutoPartNo();
         }
         // Child Cascade for Role prpt(R_DEPT)-DeptToADHdr(AD_DOC_HDR): R_DEPT->>AD_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(AD_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( AD_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_DeptToADHdr();
         }
         // Child Cascade for Role prR_DEPT)-RCLS_PARM_DTL1(RCLS_PARM_DTL): R_DEPT->>RCLS_PARM_DTL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(RCLS_PARM_DTLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( RCLS_PARM_DTLImpl.class ) )
         {
            this.childCascadeFor_RCLS_PARM_DTL1();
         }
         // Child Cascade for Role prpt(R_DEPT)-DeptToVcust(R_VEND_CUST): R_DEPT->>R_VEND_CUST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_VEND_CUSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_VEND_CUSTImpl.class ) )
         {
            this.childCascadeFor_DeptToVcust();
         }
         // Child Cascade for Role prept(R_DEPT)-DeptToMsmals(R_MSMALS): R_DEPT->>R_MSMALS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_MSMALSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_MSMALSImpl.class ) )
         {
            this.childCascadeFor_DeptToMsmals();
         }
         // Child Cascade for Role prRDept(R_DEPT)-RDeptToRIntCst(R_INT_CST_PARM): R_DEPT->>R_INT_CST_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_INT_CST_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_INT_CST_PARMImpl.class ) )
         {
            this.childCascadeFor_RDeptToRIntCst();
         }
         // Child Cascade for Role prR_DEPT)-R_FUNCs1(R_FUNC): R_DEPT->>R_FUNC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FUNCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FUNCImpl.class ) )
         {
            this.childCascadeFor_R_FUNCs1();
         }
         // Child Cascade for Role prpt(R_DEPT)-RDeptToRFac(R_FAC): R_DEPT->>R_FAC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FACImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FACImpl.class ) )
         {
            this.childCascadeFor_RDeptToRFac();
         }
         // Child Cascade for Role proRDept(R_DEPT)-RDeptToREmpInfo(R_EMP_INFO): R_DEPT->>R_EMP_INFO
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_EMP_INFOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_EMP_INFOImpl.class ) )
         {
            this.childCascadeFor_RDeptToREmpInfo();
         }
         // Child Cascade for Role prpPolToDept(R_DEPT)-DeptToDeptTrvlxpPol(R_DEPT_TRVLXP_POL): R_DEPT->>R_DEPT_TRVLXP_POL
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DEPT_TRVLXP_POLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DEPT_TRVLXP_POLImpl.class ) )
         {
            this.childCascadeFor_DeptToDeptTrvlxpPol();
         }
         // Child Cascade for Role prnstToDept(R_DEPT)-DeptToDebtDebtInst(R_DEBT_DEBTINST): R_DEPT->>R_DEBT_DEBTINST
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DEBT_DEBTINSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DEBT_DEBTINSTImpl.class ) )
         {
            this.childCascadeFor_DeptToDebtDebtInst();
         }
         // Child Cascade for Role prdToRDept(R_DEPT)-RDeptToRCntrcGlhd(R_CNTRC_GOAL_HDR): R_DEPT->>R_CNTRC_GOAL_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CNTRC_GOAL_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CNTRC_GOAL_HDRImpl.class ) )
         {
            this.childCascadeFor_RDeptToRCntrcGlhd();
         }
         // Child Cascade for Role prDEPT)-ACRL_CLR_MGMT(ACRL_CLR_MGMT): R_DEPT->>ACRL_CLR_MGMT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ACRL_CLR_MGMTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ACRL_CLR_MGMTImpl.class ) )
         {
            this.childCascadeFor_ACRL_CLR_MGMT();
         }
         // Child Cascade for Role prept(R_DEPT)-DeptToABSHdr(ABS_DOC_HDR): R_DEPT->>ABS_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ABS_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ABS_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_DeptToABSHdr();
         }
         // Child Cascade for Role prndToDept(R_DEPT)-DeptToTrvlDocVend(TRVL_DOC_VEND): R_DEPT->>TRVL_DOC_VEND
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(TRVL_DOC_VENDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( TRVL_DOC_VENDImpl.class ) )
         {
            this.childCascadeFor_DeptToTrvlDocVend();
         }
         // Child Cascade for Role prR_DEPT)-R_REIM_FREQ_DTs1(R_REIM_FREQ_DT): R_DEPT->>R_REIM_FREQ_DT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_REIM_FREQ_DTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_REIM_FREQ_DTImpl.class ) )
         {
            this.childCascadeFor_R_REIM_FREQ_DTs1();
         }
         // Child Cascade for Role prR_DEPT)-R_OTPT_PARM_DETs5(R_OTPT_PARM_DET): R_DEPT->>R_OTPT_PARM_DET
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_OTPT_PARM_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_OTPT_PARM_DETImpl.class ) )
         {
            this.childCascadeFor_R_OTPT_PARM_DETs5();
         }
         // Child Cascade for Role prR_DEPT)-R_MGR(R_MGR): R_DEPT->>R_MGR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_MGRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_MGRImpl.class ) )
         {
            this.childCascadeFor_R_MGR();
         }
         // Child Cascade for Role prR_DEPT)-R_GPs1(R_GP): R_DEPT->>R_GP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GPImpl.class ) )
         {
            this.childCascadeFor_R_GPs1();
         }
         // Child Cascade for Role prultiToRDept(R_DEPT)-RDeptToREmplBenMulti(R_EMPL_BEN_MULTI): R_DEPT->>R_EMPL_BEN_MULTI
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_EMPL_BEN_MULTIImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_EMPL_BEN_MULTIImpl.class ) )
         {
            this.childCascadeFor_RDeptToREmplBenMulti();
         }
         // Child Cascade for Role prR_DEPT)-R_DRSGRPs1(R_DRSGRP): R_DEPT->>R_DRSGRP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DRSGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DRSGRPImpl.class ) )
         {
            this.childCascadeFor_R_DRSGRPs1();
         }
         // Child Cascade for Role prR_DEPT)-R_DOBJs1(R_DOBJ): R_DEPT->>R_DOBJ
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DOBJImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DOBJImpl.class ) )
         {
            this.childCascadeFor_R_DOBJs1();
         }
         // Child Cascade for Role prDEPT)-PO_DOC_HDR(PO_DOC_HDR): R_DEPT->>PO_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(PO_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( PO_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_PO_DOC_HDR();
         }
         // Child Cascade for Role prept(R_DEPT)-RDeptVcPrvnt(VCC_DOC_PRVNT): R_DEPT->>VCC_DOC_PRVNT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(VCC_DOC_PRVNTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( VCC_DOC_PRVNTImpl.class ) )
         {
            this.childCascadeFor_RDeptVcPrvnt();
         }
         // Child Cascade for Role prDEPT)-R_PROG_GIS_LOC(R_PROG_GIS_LOC): R_DEPT->>R_PROG_GIS_LOC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PROG_GIS_LOCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PROG_GIS_LOCImpl.class ) )
         {
            this.childCascadeFor_R_PROG_GIS_LOC();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToPartTyp(R_PART_TYP): R_DEPT->>R_PART_TYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PART_TYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PART_TYPImpl.class ) )
         {
            this.childCascadeFor_DeptToPartTyp();
         }
         // Child Cascade for Role prR_DEPT)-R_LCATs1(R_LCAT): R_DEPT->>R_LCAT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_LCATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_LCATImpl.class ) )
         {
            this.childCascadeFor_R_LCATs1();
         }
         // Child Cascade for Role prUserToRDept(R_DEPT)-RDeptToRGrntAlrtUser(R_GRNT_ALRT_USER): R_DEPT->>R_GRNT_ALRT_USER
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_GRNT_ALRT_USERImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_GRNT_ALRT_USERImpl.class ) )
         {
            this.childCascadeFor_RDeptToRGrntAlrtUser();
         }
         // Child Cascade for Role proRDept(R_DEPT)-RDeptToRFndgGrp(R_FNDG_GRP): R_DEPT->>R_FNDG_GRP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FNDG_GRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FNDG_GRPImpl.class ) )
         {
            this.childCascadeFor_RDeptToRFndgGrp();
         }
         // Child Cascade for Role prpt(R_DEPT)-RDeptToRFgc(R_FGC): R_DEPT->>R_FGC
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FGCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FGCImpl.class ) )
         {
            this.childCascadeFor_RDeptToRFgc();
         }
         // Child Cascade for Role prDept(R_DEPT)-RDeptToFarHdr(R_FAR_HDR): R_DEPT->>R_FAR_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FAR_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FAR_HDRImpl.class ) )
         {
            this.childCascadeFor_RDeptToFarHdr();
         }
         // Child Cascade for Role prR_DEPT)-R_DRSTYPs1(R_DRSTYP): R_DEPT->>R_DRSTYP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DRSTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DRSTYPImpl.class ) )
         {
            this.childCascadeFor_R_DRSTYPs1();
         }
         // Child Cascade for Role prR_DEPT)-R_DRSCATs1(R_DRSCAT): R_DEPT->>R_DRSCAT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DRSCATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DRSCATImpl.class ) )
         {
            this.childCascadeFor_R_DRSCATs1();
         }
         // Child Cascade for Role prR_DEPT)-R_ACTVs6(R_ACTV): R_DEPT->>R_ACTV
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_ACTVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_ACTVImpl.class ) )
         {
            this.childCascadeFor_R_ACTVs6();
         }
         // Child Cascade for Role prToDept(R_DEPT)-DeptToPoSrtyIns(PO_DOC_SRTYINS): R_DEPT->>PO_DOC_SRTYINS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(PO_DOC_SRTYINSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( PO_DOC_SRTYINSImpl.class ) )
         {
            this.childCascadeFor_DeptToPoSrtyIns();
         }
         // Child Cascade for Role prmDfltToRDpt(R_DEPT)-RDptToROnPrnParmDflt(ONLN_PRN_PARM_DFLT): R_DEPT->>ONLN_PRN_PARM_DFLT
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ONLN_PRN_PARM_DFLTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ONLN_PRN_PARM_DFLTImpl.class ) )
         {
            this.childCascadeFor_RDptToROnPrnParmDflt();
         }
         // Child Cascade for Role prDept(R_DEPT)-DeptToInfApBY(INF_APBY): R_DEPT->>INF_APBY
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(INF_APBYImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( INF_APBYImpl.class ) )
         {
            this.childCascadeFor_DeptToInfApBY();
         }
         // Child Cascade for Role pruserToRDept(R_DEPT)-RDeptToGtDocAlrtuser(GT_DOC_ALRTUSER): R_DEPT->>GT_DOC_ALRTUSER
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(GT_DOC_ALRTUSERImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( GT_DOC_ALRTUSERImpl.class ) )
         {
            this.childCascadeFor_RDeptToGtDocAlrtuser();
         }
         // Child Cascade for Role proFADocHdr(R_DEPT)-FA_DOC_HDRs1(FA_DOC_HDR): R_DEPT->>FA_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(FA_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( FA_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_FA_DOC_HDRs1();
         }
         // Child Cascade for Role prgoingToDept(R_DEPT)-DeptToARRADocOngoing(ARRA_DOC_ONGOING): R_DEPT->>ARRA_DOC_ONGOING
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ARRA_DOC_ONGOINGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ARRA_DOC_ONGOINGImpl.class ) )
         {
            this.childCascadeFor_DeptToARRADocOngoing();
         }
         // Child Cascade for Role prtrlyAwdToDepartment(R_DEPT)-DepartmentToSubRcpntQtrlyAwd(R_SRCPNT_QTRLY_AWD): R_DEPT->>R_SRCPNT_QTRLY_AWD
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_SRCPNT_QTRLY_AWDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_SRCPNT_QTRLY_AWDImpl.class ) )
         {
            this.childCascadeFor_DepartmentToSubRcpntQtrlyAwd();
         }
         // Child Cascade for Role prToRdept(R_DEPT)-RdeptToRplbsSetp(R_PLBS_SETP): R_DEPT->>R_PLBS_SETP
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_PLBS_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_PLBS_SETPImpl.class ) )
         {
            this.childCascadeFor_RdeptToRplbsSetp();
         }
         // Child Cascade for Role prR_DEPT)-R_OTPT_PARM_DETs4(R_OTPT_PARM_DET): R_DEPT->>R_OTPT_PARM_DET
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_OTPT_PARM_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_OTPT_PARM_DETImpl.class ) )
         {
            this.childCascadeFor_R_OTPT_PARM_DETs4();
         }
         // Child Cascade for Role prntCstOtMulti1(R_DEPT)-RIntCstOtMultiToRDept1(R_INT_CST_OT_MULTI): R_DEPT->>R_INT_CST_OT_MULTI
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_INT_CST_OT_MULTIImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_INT_CST_OT_MULTIImpl.class ) )
         {
            this.childCascadeFor_RIntCstOtMultiToRDept1();
         }
         // Child Cascade for Role prR_DEPT)-R_FNCLSs1(R_FNCLS): R_DEPT->>R_FNCLS
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_FNCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_FNCLSImpl.class ) )
         {
            this.childCascadeFor_R_FNCLSs1();
         }
         // Child Cascade for Role pr_DEPT)-R_DISB_MGMT_RSTR_1(R_DISB_MGMT_RSTR): R_DEPT->>R_DISB_MGMT_RSTR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DISB_MGMT_RSTRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DISB_MGMT_RSTRImpl.class ) )
         {
            this.childCascadeFor_R_DISB_MGMT_RSTR_1();
         }
         // Child Cascade for Role prDEPT)-R_DISB_MGMT_RSTR(R_DISB_MGMT_RSTR): R_DEPT->>R_DISB_MGMT_RSTR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_DISB_MGMT_RSTRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_DISB_MGMT_RSTRImpl.class ) )
         {
            this.childCascadeFor_R_DISB_MGMT_RSTR();
         }
         // Child Cascade for Role prDEPT)-R_CMIA_INTR_PARMs(R_CMIA_INTR_PARM): R_DEPT->>R_CMIA_INTR_PARM
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_CMIA_INTR_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_CMIA_INTR_PARMImpl.class ) )
         {
            this.childCascadeFor_R_CMIA_INTR_PARMs();
         }
         // Child Cascade for Role prev_RDept(R_DEPT)-RDept_RBfyStpfRev(R_BFY_STPF_REV): R_DEPT->>R_BFY_STPF_REV
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(R_BFY_STPF_REVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( R_BFY_STPF_REVImpl.class ) )
         {
            this.childCascadeFor_RDept_RBfyStpfRev();
         }
         // Child Cascade for Role prgToDept(R_DEPT)-DeptToIctDocActg(ICT_DOC_HDR): R_DEPT->>ICT_DOC_HDR
         if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_UPDATE))
         && !(ICT_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
         && isValidChildCascade( ICT_DOC_HDRImpl.class ) )
         {
            this.childCascadeFor_DeptToIctDocActg();
         }
   }
   else
   {
      //Bypassing child cascades this update; reset this behavior for next time
      mboolPerformCascade = true ;
   }

   
   // Post Rule Event
   postRuleEvent(VLSEvent.AFTER_UPDATE, null);
   // This concludes the update procedure.
}


protected void delete() throws ServerException
{
   // AMS BEGIN : SDO
   if ( cacheSize != 0 )
   {
      throw new ServerException( "R_DEPT is cached.  Delete not permitted." ) ; 
   }
   // AMS END : SDO

   if ( isBehaviorEnabled( AMSBEHAVIOR_PROCESS_SENSITIVE ) )
   {
      processInProgressCheck( VLSEvent.BEFORE_DELETE ) ;
   }

   // Process delete with business rules?
   if ( !getProcessWithBusinessLogic() )
   {
      // No, so just save the component and exit
      this.updateRowImmediate() ;
      return ;
   }
   // Post Rule Event
   postRuleEvent(VLSEvent.BEFORE_DELETE, response.reset());
   if (response.rejected())
   {
      return;
   }

   // Remove myself from the parent cache.
        // Do the parent checks.
          removeMeFromDelegatedTeamCache();
          removeMeFromBuyerTeamCache();
          removeMeFromR_CNTAC28Cache();
          removeMeFromDelegatedBuyerCache();
          removeMeFromBuyerCache();
          removeMeFromRdeptToRtrvlPolCache();
          removeMeFromContactToDepartmentCache();

   if(isValidationRequired())
   {

      // Do Column Validation Checks
      this.columnValidationCheck();

      // Do TableConstraintChecks
         this.tableConstraintCheck();

   }

        // Check delete security for this data object:
   if( mboolCheckDeleteSecurity )
   {
      checkDeleteSecurity() ;
   }



   // Adds the data object to the write cache so any queries for it
      // will return the current instance of the data object
      getSession().getTransactionInfo().save(this);

   if(isMediatorRequired())
   {
      invokeMediator();
   }
   if(isSecondaryMediatorRequired())
   {
      invokeSecondaryMediator();
   }   

   // Generate code for conditional action events.
   // Factored out duplicate code passage - Val/Paul 03-17-03
   this.tableConditionActions();

   
   if ( !isCascadeDeletedInDB() )

   this.updateRowImmediate();
   notifyBeforeChildAdjustments() ;

   if ( mboolPerformCascade )
   {
   // Do Child Cascades.
      // Child Cascade for Role prgoingToDeptCA(R_DEPT)-DeptCAToARRADocOngoing(ARRA_DOC_ONGOING): R_DEPT->>ARRA_DOC_ONGOING
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(ARRA_DOC_ONGOINGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( ARRA_DOC_ONGOINGImpl.class ))
      {
         this.childCascadeFor_DeptCAToARRADocOngoing();
      }
      // Child Cascade for Role prgDocToDept(R_DEPT)-DeptToCAMMjrProgDoc(CAM_DOC_MJRPROG): R_DEPT->>CAM_DOC_MJRPROG
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(CAM_DOC_MJRPROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( CAM_DOC_MJRPROGImpl.class ))
      {
         this.childCascadeFor_DeptToCAMMjrProgDoc();
      }
      // Child Cascade for Role prgDocToDept(R_DEPT)-DeptToCASMjrProgDoc(CAS_DOC_MJRPROG): R_DEPT->>CAS_DOC_MJRPROG
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(CAS_DOC_MJRPROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( CAS_DOC_MJRPROGImpl.class ))
      {
         this.childCascadeFor_DeptToCASMjrProgDoc();
      }
      // Child Cascade for Role pr_DEPT)-CVEX_FUND_DEPTs(CVEX_FUND_DEPT): R_DEPT->>CVEX_FUND_DEPT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(CVEX_FUND_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( CVEX_FUND_DEPTImpl.class ))
      {
         this.childCascadeFor_CVEX_FUND_DEPTs();
      }
      // Child Cascade for Role pr_DEPT)-CVIN_FUND_DEPTs(CVIN_FUND_DEPT): R_DEPT->>CVIN_FUND_DEPT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(CVIN_FUND_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( CVIN_FUND_DEPTImpl.class ))
      {
         this.childCascadeFor_CVIN_FUND_DEPTs();
      }
      // Child Cascade for Role pr4L3ReqToRDept(R_DEPT)-RDeptToCvinStru44L3Req(CVIN_STRU44L3_REQ): R_DEPT->>CVIN_STRU44L3_REQ
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(CVIN_STRU44L3_REQImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( CVIN_STRU44L3_REQImpl.class ))
      {
         this.childCascadeFor_RDeptToCvinStru44L3Req();
      }
      // Child Cascade for Role pr5L3ReqToDept(R_DEPT)-DeptToCvinStru45L3Req(CVIN_STRU45L3_REQ): R_DEPT->>CVIN_STRU45L3_REQ
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(CVIN_STRU45L3_REQImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( CVIN_STRU45L3_REQImpl.class ))
      {
         this.childCascadeFor_DeptToCvinStru45L3Req();
      }
      // Child Cascade for Role proDept(R_DEPT)-DeptToUnitProg(CVIN_UNIT_PROG): R_DEPT->>CVIN_UNIT_PROG
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(CVIN_UNIT_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( CVIN_UNIT_PROGImpl.class ))
      {
         this.childCascadeFor_DeptToUnitProg();
      }
      // Child Cascade for Role pr_DEPT)-DOC_COAs28(DOC_COA): R_DEPT->>DOC_COA
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(DOC_COAImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( DOC_COAImpl.class ))
      {
         this.childCascadeFor_DOC_COAs28();
      }
      // Child Cascade for Role prDept(R_DEPT)-DeptDocIntCoa(DOC_INT_COA): R_DEPT->>DOC_INT_COA
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(DOC_INT_COAImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( DOC_INT_COAImpl.class ))
      {
         this.childCascadeFor_DeptDocIntCoa();
      }
      // Child Cascade for Role prToRDept(R_DEPT)-RDeptToGtDocComn(GT_DOC_COMN): R_DEPT->>GT_DOC_COMN
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(GT_DOC_COMNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( GT_DOC_COMNImpl.class ))
      {
         this.childCascadeFor_RDeptToGtDocComn();
      }
      // Child Cascade for Role prfUsrToDept(R_DEPT)-DeptToGtDocNotifUsr(GT_DOC_NOTIFUSR): R_DEPT->>GT_DOC_NOTIFUSR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(GT_DOC_NOTIFUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( GT_DOC_NOTIFUSRImpl.class ))
      {
         this.childCascadeFor_DeptToGtDocNotifUsr();
      }
      // Child Cascade for Role prToDept(R_DEPT)-DeptToGtDocOpty(GT_DOC_OPTY): R_DEPT->>GT_DOC_OPTY
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(GT_DOC_OPTYImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( GT_DOC_OPTYImpl.class ))
      {
         this.childCascadeFor_DeptToGtDocOpty();
      }
      // Child Cascade for Role prToDept(R_DEPT)-DeptToGtDocResp(GT_DOC_RESP): R_DEPT->>GT_DOC_RESP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(GT_DOC_RESPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( GT_DOC_RESPImpl.class ))
      {
         this.childCascadeFor_DeptToGtDocResp();
      }
      // Child Cascade for Role prncOtypToDept(R_DEPT)-DeptToInfApprFuncOtyp(INF_APPR_FUNC_OTYP): R_DEPT->>INF_APPR_FUNC_OTYP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_APPR_FUNC_OTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_APPR_FUNC_OTYPImpl.class ))
      {
         this.childCascadeFor_DeptToInfApprFuncOtyp();
      }
      // Child Cascade for Role prcApprInf(R_DEPT)-RsrcApprInfRecs(INF_APPR_RSRC): R_DEPT->>INF_APPR_RSRC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_APPR_RSRCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_APPR_RSRCImpl.class ))
      {
         this.childCascadeFor_RsrcApprInfRecs();
      }
      // Child Cascade for Role pr_DEPT)-INF_BFYs1(INF_BFY): R_DEPT->>INF_BFY
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_BFYImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_BFYImpl.class ))
      {
         this.childCascadeFor_INF_BFYs1();
      }
      // Child Cascade for Role prDeptUnit(R_DEPT)-InfDeptUnitToDept(INF_DEPT_UNIT): R_DEPT->>INF_DEPT_UNIT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_DEPT_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_DEPT_UNITImpl.class ))
      {
         this.childCascadeFor_InfDeptUnitToDept();
      }
      // Child Cascade for Role prDept(R_DEPT)-DeptToInfFpi6(INF_FPI_6): R_DEPT->>INF_FPI_6
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_FPI_6Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_FPI_6Impl.class ))
      {
         this.childCascadeFor_DeptToInfFpi6();
      }
      // Child Cascade for Role pr_DEPT)-INF_FPRL_12(INF_FPRL_1): R_DEPT->>INF_FPRL_1
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_FPRL_1Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_FPRL_1Impl.class ))
      {
         this.childCascadeFor_INF_FPRL_12();
      }
      // Child Cascade for Role prR_DEPT)-INF_FPRL_21(INF_FPRL_2): R_DEPT->>INF_FPRL_2
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_FPRL_2Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_FPRL_2Impl.class ))
      {
         this.childCascadeFor_INF_FPRL_21();
      }
      // Child Cascade for Role prR_DEPT)-INF_FPRL_32(INF_FPRL_3): R_DEPT->>INF_FPRL_3
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_FPRL_3Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_FPRL_3Impl.class ))
      {
         this.childCascadeFor_INF_FPRL_32();
      }
      // Child Cascade for Role prFprfl4(R_DEPT)-InfFprfl4Recs(INF_FPRL_4): R_DEPT->>INF_FPRL_4
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_FPRL_4Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_FPRL_4Impl.class ))
      {
         this.childCascadeFor_InfFprfl4Recs();
      }
      // Child Cascade for Role proDept(R_DEPT)-DeptToInfFprl5(INF_FPRL_5): R_DEPT->>INF_FPRL_5
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_FPRL_5Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_FPRL_5Impl.class ))
      {
         this.childCascadeFor_DeptToInfFprl5();
      }
      // Child Cascade for Role proRDept(R_DEPT)-RDeptToInfFprlO(INF_FPRL_O): R_DEPT->>INF_FPRL_O
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_FPRL_OImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_FPRL_OImpl.class ))
      {
         this.childCascadeFor_RDeptToInfFprlO();
      }
      // Child Cascade for Role prtToLcnToDept(R_DEPT)-DeptToInfFprlActToLcn(INF_FPRL_ACTV_LOC): R_DEPT->>INF_FPRL_ACTV_LOC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_FPRL_ACTV_LOCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_FPRL_ACTV_LOCImpl.class ))
      {
         this.childCascadeFor_DeptToInfFprlActToLcn();
      }
      // Child Cascade for Role prndProgToDept(R_DEPT)-DeptToInfFuncFundProg(INF_FUNC_FUND_PROG): R_DEPT->>INF_FUNC_FUND_PROG
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_FUNC_FUND_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_FUNC_FUND_PROGImpl.class ))
      {
         this.childCascadeFor_DeptToInfFuncFundProg();
      }
      // Child Cascade for Role prR_DEPT)-INF_FUND_FUNC_ACTVs1(INF_FUND_FUNC_ACTV): R_DEPT->>INF_FUND_FUNC_ACTV
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_FUND_FUNC_ACTVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_FUND_FUNC_ACTVImpl.class ))
      {
         this.childCascadeFor_INF_FUND_FUNC_ACTVs1();
      }
      // Child Cascade for Role prI(R_DEPT)-GFPIToDept(INF_GRNT_FP): R_DEPT->>INF_GRNT_FP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_GRNT_FPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_GRNT_FPImpl.class ))
      {
         this.childCascadeFor_GFPIToDept();
      }
      // Child Cascade for Role prObjOtyp(R_DEPT)-InfObjOtypToDept(INF_OBJ_OTYP): R_DEPT->>INF_OBJ_OTYP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_OBJ_OTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_OBJ_OTYPImpl.class ))
      {
         this.childCascadeFor_InfObjOtypToDept();
      }
      // Child Cascade for Role prR_DEPT)-INF_PHASE_PROGs(INF_PHASE_PROG): R_DEPT->>INF_PHASE_PROG
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_PHASE_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_PHASE_PROGImpl.class ))
      {
         this.childCascadeFor_INF_PHASE_PROGs();
      }
      // Child Cascade for Role prI(R_DEPT)-PFPIToDept(INF_PROJ_FP): R_DEPT->>INF_PROJ_FP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_PROJ_FPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_PROJ_FPImpl.class ))
      {
         this.childCascadeFor_PFPIToDept();
      }
      // Child Cascade for Role prSrcInf(R_DEPT)-RevSrcInfToDept(INF_REV_SRC): R_DEPT->>INF_REV_SRC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_REV_SRCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_REV_SRCImpl.class ))
      {
         this.childCascadeFor_RevSrcInfToDept();
      }
      // Child Cascade for Role prDept(R_DEPT)-DeptToInfUnit(INF_UNIT): R_DEPT->>INF_UNIT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_UNITImpl.class ))
      {
         this.childCascadeFor_DeptToInfUnit();
      }
      // Child Cascade for Role prtDept(R_DEPT)-DeptMaAuthDept(MA_DOC_AUTHDEPT): R_DEPT->>MA_DOC_AUTHDEPT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(MA_DOC_AUTHDEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( MA_DOC_AUTHDEPTImpl.class ))
      {
         this.childCascadeFor_DeptMaAuthDept();
      }
      // Child Cascade for Role proDept(R_DEPT)-DeptToActgPrfl(R_ACTG_PRFL): R_DEPT->>R_ACTG_PRFL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_ACTG_PRFLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_ACTG_PRFLImpl.class ))
      {
         this.childCascadeFor_DeptToActgPrfl();
      }
      // Child Cascade for Role prR_DEPT)-R_ACTG_TMPLs(R_ACTG_TMPL): R_DEPT->>R_ACTG_TMPL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_ACTG_TMPLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_ACTG_TMPLImpl.class ))
      {
         this.childCascadeFor_R_ACTG_TMPLs();
      }
      // Child Cascade for Role prtToDept(R_DEPT)-DeptToStructDept(R_ALT_ORG_STRUCT): R_DEPT->>R_ALT_ORG_STRUCT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_ALT_ORG_STRUCTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_ALT_ORG_STRUCTImpl.class ))
      {
         this.childCascadeFor_DeptToStructDept();
      }
      // Child Cascade for Role prDept(R_DEPT)-DeptToApCwHdr(R_AP_CW_HDR): R_DEPT->>R_AP_CW_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_AP_CW_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_AP_CW_HDRImpl.class ))
      {
         this.childCascadeFor_DeptToApCwHdr();
      }
      // Child Cascade for Role prR_DEPT)-R_AP_INCT_RQSTs2(R_AP_INCT_RQST): R_DEPT->>R_AP_INCT_RQST
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_AP_INCT_RQSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_AP_INCT_RQSTImpl.class ))
      {
         this.childCascadeFor_R_AP_INCT_RQSTs2();
      }
      // Child Cascade for Role proRDept(R_DEPT)-RDeptToRApdDept(R_APD_DEPT): R_DEPT->>R_APD_DEPT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_APD_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_APD_DEPTImpl.class ))
      {
         this.childCascadeFor_RDeptToRApdDept();
      }
      // Child Cascade for Role prToDept(R_DEPT)-DeptToCitedAuth(R_CITED_AUTH): R_DEPT->>R_CITED_AUTH
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_CITED_AUTHImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_CITED_AUTHImpl.class ))
      {
         this.childCascadeFor_DeptToCitedAuth();
      }
      // Child Cascade for Role prpt(R_DEPT)-DeptToCntac(R_CNTAC): R_DEPT->>R_CNTAC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_CNTACImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_CNTACImpl.class ))
      {
         this.childCascadeFor_DeptToCntac();
      }
      // Child Cascade for Role prR_DEPT)-R_COMM_FA_THLDs1(R_COMM_FA_THLD): R_DEPT->>R_COMM_FA_THLD
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_COMM_FA_THLDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_COMM_FA_THLDImpl.class ))
      {
         this.childCascadeFor_R_COMM_FA_THLDs1();
      }
      // Child Cascade for Role prR_DEPT)-R_COMM_OBJs1(R_COMM_OBJ): R_DEPT->>R_COMM_OBJ
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_COMM_OBJImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_COMM_OBJImpl.class ))
      {
         this.childCascadeFor_R_COMM_OBJs1();
      }
      // Child Cascade for Role prept(R_DEPT)-DeptToDeptFY(R_DEPT_FY): R_DEPT->>R_DEPT_FY
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DEPT_FYImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DEPT_FYImpl.class ))
      {
         this.childCascadeFor_DeptToDeptFY();
      }
      // Child Cascade for Role prymtCtrlToRDept(R_DEPT)-RDeptToRDeptObjPymtCtrl(R_DEPT_OBJ_PYCTRL): R_DEPT->>R_DEPT_OBJ_PYCTRL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DEPT_OBJ_PYCTRLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DEPT_OBJ_PYCTRLImpl.class ))
      {
         this.childCascadeFor_RDeptToRDeptObjPymtCtrl();
      }
      // Child Cascade for Role prept(R_DEPT)-DeptToDISCIV(R_DISCIV): R_DEPT->>R_DISCIV
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DISCIVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DISCIVImpl.class ))
      {
         this.childCascadeFor_DeptToDISCIV();
      }
      // Child Cascade for Role prToDept(R_DEPT)-DeptToDrwdwnGrp(R_DRWDWN_GRP): R_DEPT->>R_DRWDWN_GRP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DRWDWN_GRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DRWDWN_GRPImpl.class ))
      {
         this.childCascadeFor_DeptToDrwdwnGrp();
      }
      // Child Cascade for Role prToDept(R_DEPT)-DeptToEscrowDef(R_ESCROW_DEF): R_DEPT->>R_ESCROW_DEF
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_ESCROW_DEFImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_ESCROW_DEFImpl.class ))
      {
         this.childCascadeFor_DeptToEscrowDef();
      }
      // Child Cascade for Role prRDept(R_DEPT)-RDeptToRFesReq(R_FESREQ): R_DEPT->>R_FESREQ
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FESREQImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FESREQImpl.class ))
      {
         this.childCascadeFor_RDeptToRFesReq();
      }
      // Child Cascade for Role prcToRDept(R_DEPT)-RDeptToRFndgAlloc(R_FNDG_ALLOC): R_DEPT->>R_FNDG_ALLOC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FNDG_ALLOCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FNDG_ALLOCImpl.class ))
      {
         this.childCascadeFor_RDeptToRFndgAlloc();
      }
      // Child Cascade for Role prRDept(R_DEPT)-RDeptToRFyDept(R_FY_DEPT): R_DEPT->>R_FY_DEPT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FY_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FY_DEPTImpl.class ))
      {
         this.childCascadeFor_RDeptToRFyDept();
      }
      // Child Cascade for Role prToRDept(R_DEPT)-RDeptToRGrntAppl(R_GRNT_APPL): R_DEPT->>R_GRNT_APPL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_GRNT_APPLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_GRNT_APPLImpl.class ))
      {
         this.childCascadeFor_RDeptToRGrntAppl();
      }
      // Child Cascade for Role prplToRDept(R_DEPT)-RDeptToRGrntDtTmpl(R_GRNT_DT_TMPL): R_DEPT->>R_GRNT_DT_TMPL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_GRNT_DT_TMPLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_GRNT_DT_TMPLImpl.class ))
      {
         this.childCascadeFor_RDeptToRGrntDtTmpl();
      }
      // Child Cascade for Role proDept(R_DEPT)-DeptToGrntOpty(R_GRNT_OPTY): R_DEPT->>R_GRNT_OPTY
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_GRNT_OPTYImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_GRNT_OPTYImpl.class ))
      {
         this.childCascadeFor_DeptToGrntOpty();
      }
      // Child Cascade for Role proDept(R_DEPT)-DeptToGrntResp(R_GRNT_RESP): R_DEPT->>R_GRNT_RESP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_GRNT_RESPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_GRNT_RESPImpl.class ))
      {
         this.childCascadeFor_DeptToGrntResp();
      }
      // Child Cascade for Role proDept(R_DEPT)-DeptToGrntUser(R_GRNT_USER): R_DEPT->>R_GRNT_USER
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_GRNT_USERImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_GRNT_USERImpl.class ))
      {
         this.childCascadeFor_DeptToGrntUser();
      }
      // Child Cascade for Role prDEPT)-R_INTG_CTRL(R_INTG_CTRL): R_DEPT->>R_INTG_CTRL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_INTG_CTRLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_INTG_CTRLImpl.class ))
      {
         this.childCascadeFor_R_INTG_CTRL();
      }
      // Child Cascade for Role prR_DEPT)-R_MJR_PROGs3(R_MJR_PROG): R_DEPT->>R_MJR_PROG
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_MJR_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_MJR_PROGImpl.class ))
      {
         this.childCascadeFor_R_MJR_PROGs3();
      }
      // Child Cascade for Role prardInfoToDepartment(R_DEPT)-DepartmentToOnGoingAwardInfo(R_ONGOING_AWD_INFO): R_DEPT->>R_ONGOING_AWD_INFO
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_ONGOING_AWD_INFOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_ONGOING_AWD_INFOImpl.class ))
      {
         this.childCascadeFor_DepartmentToOnGoingAwardInfo();
      }
      // Child Cascade for Role prt(R_DEPT)-PerfEvalEvaluator(R_PE_EVALR): R_DEPT->>R_PE_EVALR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PE_EVALRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PE_EVALRImpl.class ))
      {
         this.childCascadeFor_PerfEvalEvaluator();
      }
      // Child Cascade for Role prt(R_DEPT)-StateInstances(R_PRCU_ST): R_DEPT->>R_PRCU_ST
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PRCU_STImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PRCU_STImpl.class ))
      {
         this.childCascadeFor_StateInstances();
      }
      // Child Cascade for Role prDeptToRDept(R_DEPT)-RDeptToRPayHldByDept(R_PYMT_HLD_TYP_DPT): R_DEPT->>R_PYMT_HLD_TYP_DPT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PYMT_HLD_TYP_DPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PYMT_HLD_TYP_DPTImpl.class ))
      {
         this.childCascadeFor_RDeptToRPayHldByDept();
      }
      // Child Cascade for Role prR_DEPT)-R_STPF(R_STPF): R_DEPT->>R_STPF
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_STPFImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_STPFImpl.class ))
      {
         this.childCascadeFor_R_STPF();
      }
      // Child Cascade for Role prt(R_DEPT)-UniversalRequestorControls(R_UR_CTRL): R_DEPT->>R_UR_CTRL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_UR_CTRLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_UR_CTRLImpl.class ))
      {
         this.childCascadeFor_UniversalRequestorControls();
      }
      // Child Cascade for Role prrGrpTmpl(R_DEPT)-UserGrpTmplToDept(R_USER_GRP_TMPL): R_DEPT->>R_USER_GRP_TMPL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_USER_GRP_TMPLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_USER_GRP_TMPLImpl.class ))
      {
         this.childCascadeFor_UserGrpTmplToDept();
      }
      // Child Cascade for Role prR_DEPT)-R_VEND_LSTs2(R_VEND_LST): R_DEPT->>R_VEND_LST
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_VEND_LSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_VEND_LSTImpl.class ))
      {
         this.childCascadeFor_R_VEND_LSTs2();
      }
      // Child Cascade for Role prR_DEPT)-REQ_ACTV_SACTVs(REQ_ACTV_SACTV): R_DEPT->>REQ_ACTV_SACTV
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(REQ_ACTV_SACTVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( REQ_ACTV_SACTVImpl.class ))
      {
         this.childCascadeFor_REQ_ACTV_SACTVs();
      }
      // Child Cascade for Role prR_DEPT)-REQ_DEPT_OBJ_REVs(REQ_DEPT_OBJ_REV): R_DEPT->>REQ_DEPT_OBJ_REV
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(REQ_DEPT_OBJ_REVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( REQ_DEPT_OBJ_REVImpl.class ))
      {
         this.childCascadeFor_REQ_DEPT_OBJ_REVs();
      }
      // Child Cascade for Role prqFundDept(R_DEPT)-ReqFundDeptToRDept(REQ_FUND_DEPT): R_DEPT->>REQ_FUND_DEPT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(REQ_FUND_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( REQ_FUND_DEPTImpl.class ))
      {
         this.childCascadeFor_ReqFundDeptToRDept();
      }
      // Child Cascade for Role prR_DEPT)-REQ_FUND_UNIT_OBJs(REQ_FUND_UNIT_OBJ): R_DEPT->>REQ_FUND_UNIT_OBJ
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(REQ_FUND_UNIT_OBJImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( REQ_FUND_UNIT_OBJImpl.class ))
      {
         this.childCascadeFor_REQ_FUND_UNIT_OBJs();
      }
      // Child Cascade for Role prR_DEPT)-REQ_FUND_UNIT_RSRCs(REQ_FUND_UNIT_RSRC): R_DEPT->>REQ_FUND_UNIT_RSRC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(REQ_FUND_UNIT_RSRCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( REQ_FUND_UNIT_RSRCImpl.class ))
      {
         this.childCascadeFor_REQ_FUND_UNIT_RSRCs();
      }
      // Child Cascade for Role prR_DEPT)-REQ_UNITs(REQ_UNIT): R_DEPT->>REQ_UNIT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(REQ_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( REQ_UNITImpl.class ))
      {
         this.childCascadeFor_REQ_UNITs();
      }
      // Child Cascade for Role progToDept(R_DEPT)-DeptToReqUnitProg(REQ_UNIT_PROG): R_DEPT->>REQ_UNIT_PROG
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(REQ_UNIT_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( REQ_UNIT_PROGImpl.class ))
      {
         this.childCascadeFor_DeptToReqUnitProg();
      }
      // Child Cascade for Role prR_DEPT)-REQ_UNIT_SUNITs(REQ_UNIT_SUNIT): R_DEPT->>REQ_UNIT_SUNIT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(REQ_UNIT_SUNITImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( REQ_UNIT_SUNITImpl.class ))
      {
         this.childCascadeFor_REQ_UNIT_SUNITs();
      }
      // Child Cascade for Role prtParm(R_DEPT)-R_OTPT_PARM_DETs3(R_OTPT_PARM_DET): R_DEPT->>R_OTPT_PARM_DET
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_OTPT_PARM_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_OTPT_PARM_DETImpl.class ))
      {
         this.childCascadeFor_R_OTPT_PARM_DETs3();
      }
      // Child Cascade for Role prtSchedToRDept2(R_DEPT)-RDeptToRGrntrEvntSched2(R_GRNTR_EVNT_SCHED): R_DEPT->>R_GRNTR_EVNT_SCHED
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_GRNTR_EVNT_SCHEDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_GRNTR_EVNT_SCHEDImpl.class ))
      {
         this.childCascadeFor_RDeptToRGrntrEvntSched2();
      }
      // Child Cascade for Role prFaroParm(R_DEPT)-R_FARO_PARMs3(R_FARO_PARM): R_DEPT->>R_FARO_PARM
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FARO_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FARO_PARMImpl.class ))
      {
         this.childCascadeFor_R_FARO_PARMs3();
      }
      // Child Cascade for Role prept1(R_DEPT)-DeptToClmtrk1(R_CLMTRK): R_DEPT->>R_CLMTRK
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_CLMTRKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_CLMTRKImpl.class ))
      {
         this.childCascadeFor_DeptToClmtrk1();
      }
      // Child Cascade for Role prMgmtUsrToRDept(R_DEPT)-RDeptToGtDocProgMgmtUsr(GT_DOC_PMGMTUSR): R_DEPT->>GT_DOC_PMGMTUSR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(GT_DOC_PMGMTUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( GT_DOC_PMGMTUSRImpl.class ))
      {
         this.childCascadeFor_RDeptToGtDocProgMgmtUsr();
      }
      // Child Cascade for Role prDEPT)-ACRL_CLR_EXCL(ACRL_CLR_EXCL): R_DEPT->>ACRL_CLR_EXCL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(ACRL_CLR_EXCLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( ACRL_CLR_EXCLImpl.class ))
      {
         this.childCascadeFor_ACRL_CLR_EXCL();
      }
      // Child Cascade for Role prDEPT)-RQ_DOC_CMPSHT(RQ_DOC_CMPSHT): R_DEPT->>RQ_DOC_CMPSHT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(RQ_DOC_CMPSHTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( RQ_DOC_CMPSHTImpl.class ))
      {
         this.childCascadeFor_RQ_DOC_CMPSHT();
      }
      // Child Cascade for Role prR_DEPT)-R_MJR_PGRPs1(R_MJR_PGRP): R_DEPT->>R_MJR_PGRP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_MJR_PGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_MJR_PGRPImpl.class ))
      {
         this.childCascadeFor_R_MJR_PGRPs1();
      }
      // Child Cascade for Role prIntrActg(R_DEPT)-IntrActgToDocDept(R_INTR_ACTG_CRSWLK): R_DEPT->>R_INTR_ACTG_CRSWLK
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_INTR_ACTG_CRSWLKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_INTR_ACTG_CRSWLKImpl.class ))
      {
         this.childCascadeFor_IntrActgToDocDept();
      }
      // Child Cascade for Role prpat(R_DEPT)-FacpatToDept(R_FACPAT): R_DEPT->>R_FACPAT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FACPATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FACPATImpl.class ))
      {
         this.childCascadeFor_FacpatToDept();
      }
      // Child Cascade for Role prpad(R_DEPT)-FacpadToDept(R_FACPAD): R_DEPT->>R_FACPAD
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FACPADImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FACPADImpl.class ))
      {
         this.childCascadeFor_FacpadToDept();
      }
      // Child Cascade for Role prR_DEPT)-R_DOCATs1(R_DOCAT): R_DEPT->>R_DOCAT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DOCATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DOCATImpl.class ))
      {
         this.childCascadeFor_R_DOCATs1();
      }
      // Child Cascade for Role prpnd_RDept(R_DEPT)-RDept_RBfyStpfSpnd(R_BFY_STPF_SPND): R_DEPT->>R_BFY_STPF_SPND
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_BFY_STPF_SPNDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_BFY_STPF_SPNDImpl.class ))
      {
         this.childCascadeFor_RDept_RBfyStpfSpnd();
      }
      // Child Cascade for Role prR_DEPT)-R_AP_DISB_PARMs3(R_AP_DISB_PARM): R_DEPT->>R_AP_DISB_PARM
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_AP_DISB_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_AP_DISB_PARMImpl.class ))
      {
         this.childCascadeFor_R_AP_DISB_PARMs3();
      }
      // Child Cascade for Role prcHdr(R_DEPT)-MMRDocHdrDept(MMR_DOC_HDR): R_DEPT->>MMR_DOC_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(MMR_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( MMR_DOC_HDRImpl.class ))
      {
         this.childCascadeFor_MMRDocHdrDept();
      }
      // Child Cascade for Role prToDept(R_DEPT)-DeptToMaSrtyIns(MA_DOC_SRTYINS): R_DEPT->>MA_DOC_SRTYINS
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(MA_DOC_SRTYINSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( MA_DOC_SRTYINSImpl.class ))
      {
         this.childCascadeFor_DeptToMaSrtyIns();
      }
      // Child Cascade for Role prdCToDept(R_DEPT)-DeptToFndCDocFndC(FNDC_DOC_FNDC): R_DEPT->>FNDC_DOC_FNDC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(FNDC_DOC_FNDCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( FNDC_DOC_FNDCImpl.class ))
      {
         this.childCascadeFor_DeptToFndCDocFndC();
      }
      // Child Cascade for Role prToRqstDept(R_DEPT)-RqstDeptToCMRDocHdr(CMR_DOC_HDR): R_DEPT->>CMR_DOC_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(CMR_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( CMR_DOC_HDRImpl.class ))
      {
         this.childCascadeFor_RqstDeptToCMRDocHdr();
      }
      // Child Cascade for Role prR_DEPT)-R_TASKs1(R_TASK): R_DEPT->>R_TASK
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_TASKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_TASKImpl.class ))
      {
         this.childCascadeFor_R_TASKs1();
      }
      // Child Cascade for Role prnToRDept(R_DEPT)-RDeptToRPayHldTin(R_PYMT_HLD_TIN): R_DEPT->>R_PYMT_HLD_TIN
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PYMT_HLD_TINImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PYMT_HLD_TINImpl.class ))
      {
         this.childCascadeFor_RDeptToRPayHldTin();
      }
      // Child Cascade for Role prpt(R_DEPT)-RDeptToRFsc(R_FSC): R_DEPT->>R_FSC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FSCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FSCImpl.class ))
      {
         this.childCascadeFor_RDeptToRFsc();
      }
      // Child Cascade for Role prDEPT)-R_FIN_CHRG_SETP(R_FIN_CHRG_SETP): R_DEPT->>R_FIN_CHRG_SETP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FIN_CHRG_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FIN_CHRG_SETPImpl.class ))
      {
         this.childCascadeFor_R_FIN_CHRG_SETP();
      }
      // Child Cascade for Role prFaroParm(R_DEPT)-R_FARO_PARMs2(R_FARO_PARM): R_DEPT->>R_FARO_PARM
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FARO_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FARO_PARMImpl.class ))
      {
         this.childCascadeFor_R_FARO_PARMs2();
      }
      // Child Cascade for Role prnToRDept1(R_DEPT)-RDeptToRCntrcGlln1(R_CNTRC_GOAL_LN): R_DEPT->>R_CNTRC_GOAL_LN
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_CNTRC_GOAL_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_CNTRC_GOAL_LNImpl.class ))
      {
         this.childCascadeFor_RDeptToRCntrcGlln1();
      }
      // Child Cascade for Role prsa_RDept(R_DEPT)-RDept_RBfyStpfBsa(R_BFY_STPF_BSA): R_DEPT->>R_BFY_STPF_BSA
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_BFY_STPF_BSAImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_BFY_STPF_BSAImpl.class ))
      {
         this.childCascadeFor_RDept_RBfyStpfBsa();
      }
      // Child Cascade for Role proRDept(R_DEPT)-RDeptToRAdcParm(R_ADC_PARM): R_DEPT->>R_ADC_PARM
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_ADC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_ADC_PARMImpl.class ))
      {
         this.childCascadeFor_RDeptToRAdcParm();
      }
      // Child Cascade for Role prrUsrToRDept(R_DEPT)-RDeptToGtDocPrtnrUsr(GT_DOC_PRTNRUSR): R_DEPT->>GT_DOC_PRTNRUSR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(GT_DOC_PRTNRUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( GT_DOC_PRTNRUSRImpl.class ))
      {
         this.childCascadeFor_RDeptToGtDocPrtnrUsr();
      }
      // Child Cascade for Role prarmToRdept(R_DEPT)-RdeptToCsalProcParm(CSAL_PROC_PARM): R_DEPT->>CSAL_PROC_PARM
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(CSAL_PROC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( CSAL_PROC_PARMImpl.class ))
      {
         this.childCascadeFor_RdeptToCsalProcParm();
      }
      // Child Cascade for Role prnt(R_DEPT)-VmPrvntDept(VCM_DOC_PRVNT): R_DEPT->>VCM_DOC_PRVNT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(VCM_DOC_PRVNTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( VCM_DOC_PRVNTImpl.class ))
      {
         this.childCascadeFor_VmPrvntDept();
      }
      // Child Cascade for Role prPrflToRDept(R_DEPT)-RDeptToRUtlyActgPrfl(R_UTLY_ACTG_PRFL): R_DEPT->>R_UTLY_ACTG_PRFL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_UTLY_ACTG_PRFLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_UTLY_ACTG_PRFLImpl.class ))
      {
         this.childCascadeFor_RDeptToRUtlyActgPrfl();
      }
      // Child Cascade for Role prR_DEPT)-R_UNITs2(R_UNIT): R_DEPT->>R_UNIT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_UNITImpl.class ))
      {
         this.childCascadeFor_R_UNITs2();
      }
      // Child Cascade for Role prR_DEPT)-R_TASK_ORDs1(R_TASK_ORD): R_DEPT->>R_TASK_ORD
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_TASK_ORDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_TASK_ORDImpl.class ))
      {
         this.childCascadeFor_R_TASK_ORDs1();
      }
      // Child Cascade for Role prpt(R_DEPT)-RDeptToRRgn(R_RGN): R_DEPT->>R_RGN
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_RGNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_RGNImpl.class ))
      {
         this.childCascadeFor_RDeptToRRgn();
      }
      // Child Cascade for Role prR_DEPT)-R_PGRPs1(R_PGRP): R_DEPT->>R_PGRP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PGRPImpl.class ))
      {
         this.childCascadeFor_R_PGRPs1();
      }
      // Child Cascade for Role prDept(R_DEPT)-DeptToPartUsg(R_PART_USG): R_DEPT->>R_PART_USG
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PART_USGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PART_USGImpl.class ))
      {
         this.childCascadeFor_DeptToPartUsg();
      }
      // Child Cascade for Role prR_DEPT)-R_MJR_PTYPs1(R_MJR_PTYP): R_DEPT->>R_MJR_PTYP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_MJR_PTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_MJR_PTYPImpl.class ))
      {
         this.childCascadeFor_R_MJR_PTYPs1();
      }
      // Child Cascade for Role prR_DEPT)-R_DSTCs1(R_DSTC): R_DEPT->>R_DSTC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DSTCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DSTCImpl.class ))
      {
         this.childCascadeFor_R_DSTCs1();
      }
      // Child Cascade for Role prnToRDept(R_DEPT)-RDeptToRCntrcGlln(R_CNTRC_GOAL_LN): R_DEPT->>R_CNTRC_GOAL_LN
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_CNTRC_GOAL_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_CNTRC_GOAL_LNImpl.class ))
      {
         this.childCascadeFor_RDeptToRCntrcGlln();
      }
      // Child Cascade for Role prshSweep(R_DEPT)-RCashSweepToRDept(R_CASH_SW_SETP): R_DEPT->>R_CASH_SW_SETP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_CASH_SW_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_CASH_SW_SETPImpl.class ))
      {
         this.childCascadeFor_RCashSweepToRDept();
      }
      // Child Cascade for Role prR_DEPT)-R_AP_CLM_ACCTs1(R_AP_CLM_ACCT): R_DEPT->>R_AP_CLM_ACCT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_AP_CLM_ACCTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_AP_CLM_ACCTImpl.class ))
      {
         this.childCascadeFor_R_AP_CLM_ACCTs1();
      }
      // Child Cascade for Role prDept(R_DEPT)-DeptToAltDept(R_ALT_ORG_STRUCT): R_DEPT->>R_ALT_ORG_STRUCT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_ALT_ORG_STRUCTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_ALT_ORG_STRUCTImpl.class ))
      {
         this.childCascadeFor_DeptToAltDept();
      }
      // Child Cascade for Role prR_DEPT)-ONLN_PRN_BAT_PARM1(ONLN_PRN_BAT_PARM): R_DEPT->>ONLN_PRN_BAT_PARM
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(ONLN_PRN_BAT_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( ONLN_PRN_BAT_PARMImpl.class ))
      {
         this.childCascadeFor_ONLN_PRN_BAT_PARM1();
      }
      // Child Cascade for Role pr_DEPT)-INF_APPRs1(INF_APPR): R_DEPT->>INF_APPR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_APPRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_APPRImpl.class ))
      {
         this.childCascadeFor_INF_APPRs1();
      }
      // Child Cascade for Role prserToRDept(R_DEPT)-RDeptToGtDocRptuser(GT_DOC_RPTUSER): R_DEPT->>GT_DOC_RPTUSER
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(GT_DOC_RPTUSERImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( GT_DOC_RPTUSERImpl.class ))
      {
         this.childCascadeFor_RDeptToGtDocRptuser();
      }
      // Child Cascade for Role pr_DEPT)-DOC_HDRs(DOC_HDR): R_DEPT->>DOC_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( DOC_HDRImpl.class ))
      {
         this.childCascadeFor_DOC_HDRs();
      }
      // Child Cascade for Role prhDept(R_DEPT)-VmAuthDeptDept(VCM_DOC_AUTHDEPT): R_DEPT->>VCM_DOC_AUTHDEPT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(VCM_DOC_AUTHDEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( VCM_DOC_AUTHDEPTImpl.class ))
      {
         this.childCascadeFor_VmAuthDeptDept();
      }
      // Child Cascade for Role prR_DEPT)-R_PRVNT_SPNDs(R_PRVNT_SPND): R_DEPT->>R_PRVNT_SPND
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PRVNT_SPNDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PRVNT_SPNDImpl.class ))
      {
         this.childCascadeFor_R_PRVNT_SPNDs();
      }
      // Child Cascade for Role prept(R_DEPT)-DeptToPartRf(R_PART_RF): R_DEPT->>R_PART_RF
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PART_RFImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PART_RFImpl.class ))
      {
         this.childCascadeFor_DeptToPartRf();
      }
      // Child Cascade for Role prToRDept(R_DEPT)-RDeptToRGrntrRpt(R_GRNTR_RPT): R_DEPT->>R_GRNTR_RPT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_GRNTR_RPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_GRNTR_RPTImpl.class ))
      {
         this.childCascadeFor_RDeptToRGrntrRpt();
      }
      // Child Cascade for Role proDept(R_DEPT)-DeptToDebtAuth(R_DEBT_AUTH): R_DEPT->>R_DEBT_AUTH
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DEBT_AUTHImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DEBT_AUTHImpl.class ))
      {
         this.childCascadeFor_DeptToDebtAuth();
      }
      // Child Cascade for Role prrSetpToRdept(R_DEPT)-RdeptToRcsalSrctrSetp(R_CSAL_SRCTR_SETP): R_DEPT->>R_CSAL_SRCTR_SETP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_CSAL_SRCTR_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_CSAL_SRCTR_SETPImpl.class ))
      {
         this.childCascadeFor_RdeptToRcsalSrctrSetp();
      }
      // Child Cascade for Role prrcuAlToRDept(R_DEPT)-RDeptToRApUprocPrcuAl(R_AP_UPROC_PRCU_AL): R_DEPT->>R_AP_UPROC_PRCU_AL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_AP_UPROC_PRCU_ALImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_AP_UPROC_PRCU_ALImpl.class ))
      {
         this.childCascadeFor_RDeptToRApUprocPrcuAl();
      }
      // Child Cascade for Role prDept(R_DEPT)-DeptToApCwChk(R_AP_CW_CHK_NO): R_DEPT->>R_AP_CW_CHK_NO
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_AP_CW_CHK_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_AP_CW_CHK_NOImpl.class ))
      {
         this.childCascadeFor_DeptToApCwChk();
      }
      // Child Cascade for Role prToRDept1(R_DEPT)-RDept1ToRAdcParm1(R_ADC_PARM): R_DEPT->>R_ADC_PARM
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_ADC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_ADC_PARMImpl.class ))
      {
         this.childCascadeFor_RDept1ToRAdcParm1();
      }
      // Child Cascade for Role prpt(R_DEPT)-DeptToMDHdr(MD_DOC_HDR): R_DEPT->>MD_DOC_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(MD_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( MD_DOC_HDRImpl.class ))
      {
         this.childCascadeFor_DeptToMDHdr();
      }
      // Child Cascade for Role prrmToDept(R_DEPT)-DeptToCamProcParm(CAM_PROC_PARM): R_DEPT->>CAM_PROC_PARM
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(CAM_PROC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( CAM_PROC_PARMImpl.class ))
      {
         this.childCascadeFor_DeptToCamProcParm();
      }
      // Child Cascade for Role prSetpToRdept(R_DEPT)-RdeptToRstatUnitSetp(R_STAT_UNIT_SETP): R_DEPT->>R_STAT_UNIT_SETP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_STAT_UNIT_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_STAT_UNIT_SETPImpl.class ))
      {
         this.childCascadeFor_RdeptToRstatUnitSetp();
      }
      // Child Cascade for Role prDept(R_DEPT)-DeptToProgSta(R_PROG_STA): R_DEPT->>R_PROG_STA
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PROG_STAImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PROG_STAImpl.class ))
      {
         this.childCascadeFor_DeptToProgSta();
      }
      // Child Cascade for Role prR_DEPT)-R_PROGs2(R_PROG): R_DEPT->>R_PROG
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PROGImpl.class ))
      {
         this.childCascadeFor_R_PROGs2();
      }
      // Child Cascade for Role prardInfoToDept(R_DEPT)-DeptToOnGoingAwardInfo(R_ONGOING_AWD_INFO): R_DEPT->>R_ONGOING_AWD_INFO
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_ONGOING_AWD_INFOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_ONGOING_AWD_INFOImpl.class ))
      {
         this.childCascadeFor_DeptToOnGoingAwardInfo();
      }
      // Child Cascade for Role prDrawExcpDtl(R_DEPT)-NegDrawExcpDtlRecs(R_NEG_DRW_EXCP_DTL): R_DEPT->>R_NEG_DRW_EXCP_DTL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_NEG_DRW_EXCP_DTLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_NEG_DRW_EXCP_DTLImpl.class ))
      {
         this.childCascadeFor_NegDrawExcpDtlRecs();
      }
      // Child Cascade for Role prR_DEPT)-R_LCLSs1(R_LCLS): R_DEPT->>R_LCLS
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_LCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_LCLSImpl.class ))
      {
         this.childCascadeFor_R_LCLSs1();
      }
      // Child Cascade for Role prUsrToDept(R_DEPT)-DeptToGrntNotifUsr(R_GRNT_NOTIFUSR): R_DEPT->>R_GRNT_NOTIFUSR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_GRNT_NOTIFUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_GRNT_NOTIFUSRImpl.class ))
      {
         this.childCascadeFor_DeptToGrntNotifUsr();
      }
      // Child Cascade for Role prToRDept2(R_DEPT)-RDept2ToRAdcParm2(R_ADC_PARM): R_DEPT->>R_ADC_PARM
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_ADC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_ADC_PARMImpl.class ))
      {
         this.childCascadeFor_RDept2ToRAdcParm2();
      }
      // Child Cascade for Role prR_DEPT)-R_ACATs1(R_ACAT): R_DEPT->>R_ACAT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_ACATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_ACATImpl.class ))
      {
         this.childCascadeFor_R_ACATs1();
      }
      // Child Cascade for Role prds(R_DEPT)-LrdsToDept1(LIC_RNEW_DT_STRG): R_DEPT->>LIC_RNEW_DT_STRG
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(LIC_RNEW_DT_STRGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( LIC_RNEW_DT_STRGImpl.class ))
      {
         this.childCascadeFor_LrdsToDept1();
      }
      // Child Cascade for Role prs(R_DEPT)-LrdsToDept(LIC_RNEW_DT_STRG): R_DEPT->>LIC_RNEW_DT_STRG
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(LIC_RNEW_DT_STRGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( LIC_RNEW_DT_STRGImpl.class ))
      {
         this.childCascadeFor_LrdsToDept();
      }
      // Child Cascade for Role prcpQtrToDept(R_DEPT)-DeptToARRADocSRcpQtr(ARRA_DOC_SRCPQTR): R_DEPT->>ARRA_DOC_SRCPQTR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(ARRA_DOC_SRCPQTRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( ARRA_DOC_SRCPQTRImpl.class ))
      {
         this.childCascadeFor_DeptToARRADocSRcpQtr();
      }
      // Child Cascade for Role prR_DEPT)-ACRL_CLR_MGMT_2(ACRL_CLR_MGMT): R_DEPT->>ACRL_CLR_MGMT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(ACRL_CLR_MGMTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( ACRL_CLR_MGMTImpl.class ))
      {
         this.childCascadeFor_ACRL_CLR_MGMT_2();
      }
      // Child Cascade for Role prVLCoaOVrd(R_DEPT)-TRVLCoaOVrdToRDept(TRVL_COA_OVRD): R_DEPT->>TRVL_COA_OVRD
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(TRVL_COA_OVRDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( TRVL_COA_OVRDImpl.class ))
      {
         this.childCascadeFor_TRVLCoaOVrdToRDept();
      }
      // Child Cascade for Role prToDept(R_DEPT)-DeptToSrcOfFund(R_SRC_OF_FUND): R_DEPT->>R_SRC_OF_FUND
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_SRC_OF_FUNDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_SRC_OF_FUNDImpl.class ))
      {
         this.childCascadeFor_DeptToSrcOfFund();
      }
      // Child Cascade for Role prR_DEPT)-R_REIM_GEN_PARAM(R_REIM_GEN_PARAM): R_DEPT->>R_REIM_GEN_PARAM
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_REIM_GEN_PARAMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_REIM_GEN_PARAMImpl.class ))
      {
         this.childCascadeFor_R_REIM_GEN_PARAM();
      }
      // Child Cascade for Role prjToDocDept(R_DEPT)-DocDeptToReimExpAdj(R_REIM_EXP_ADJ): R_DEPT->>R_REIM_EXP_ADJ
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_REIM_EXP_ADJImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_REIM_EXP_ADJImpl.class ))
      {
         this.childCascadeFor_DocDeptToReimExpAdj();
      }
      // Child Cascade for Role prAIntnExcep(R_DEPT)-RFAIntnExcepToRDept(R_FA_INTN_EXCEPT): R_DEPT->>R_FA_INTN_EXCEPT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FA_INTN_EXCEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FA_INTN_EXCEPTImpl.class ))
      {
         this.childCascadeFor_RFAIntnExcepToRDept();
      }
      // Child Cascade for Role prToDept(R_DEPT)-DeptToDebtHist1(R_DEBT_HIST): R_DEPT->>R_DEBT_HIST
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DEBT_HISTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DEBT_HISTImpl.class ))
      {
         this.childCascadeFor_DeptToDebtHist1();
      }
      // Child Cascade for Role prR_DEPT)-R_CORSPDs1(R_CORSPD): R_DEPT->>R_CORSPD
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_CORSPDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_CORSPDImpl.class ))
      {
         this.childCascadeFor_R_CORSPDs1();
      }
      // Child Cascade for Role prToDept(R_DEPT)-DeptToCWCanParm(R_AP_CWCAN_PARM): R_DEPT->>R_AP_CWCAN_PARM
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_AP_CWCAN_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_AP_CWCAN_PARMImpl.class ))
      {
         this.childCascadeFor_DeptToCWCanParm();
      }
      // Child Cascade for Role proDept(R_DEPT)-DeptToAutoCano(AUTO_CA_NO): R_DEPT->>AUTO_CA_NO
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(AUTO_CA_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( AUTO_CA_NOImpl.class ))
      {
         this.childCascadeFor_DeptToAutoCano();
      }
      // Child Cascade for Role prLCoaOvrd(R_DEPT)-TRVLCoaOvrdToDept(TRVL_COA_OVRD): R_DEPT->>TRVL_COA_OVRD
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(TRVL_COA_OVRDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( TRVL_COA_OVRDImpl.class ))
      {
         this.childCascadeFor_TRVLCoaOvrdToDept();
      }
      // Child Cascade for Role pryrLn1ToDept1(R_DEPT)-Dept1ToTaskOrdBuyrLn1(R_TASK_ORD_BUYR_LN): R_DEPT->>R_TASK_ORD_BUYR_LN
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_TASK_ORD_BUYR_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_TASK_ORD_BUYR_LNImpl.class ))
      {
         this.childCascadeFor_Dept1ToTaskOrdBuyrLn1();
      }
      // Child Cascade for Role pryrLnToDept(R_DEPT)-DeptToTaskOrdBuyrLn(R_TASK_ORD_BUYR_LN): R_DEPT->>R_TASK_ORD_BUYR_LN
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_TASK_ORD_BUYR_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_TASK_ORD_BUYR_LNImpl.class ))
      {
         this.childCascadeFor_DeptToTaskOrdBuyrLn();
      }
      // Child Cascade for Role prR_DEPT)-R_SYS_CROSWALKs(R_SYS_CROSWALK): R_DEPT->>R_SYS_CROSWALK
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_SYS_CROSWALKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_SYS_CROSWALKImpl.class ))
      {
         this.childCascadeFor_R_SYS_CROSWALKs();
      }
      // Child Cascade for Role prR_DEPT)-R_PTYPs1(R_PTYP): R_DEPT->>R_PTYP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PTYPImpl.class ))
      {
         this.childCascadeFor_R_PTYPs1();
      }
      // Child Cascade for Role prReqToRdept(R_DEPT)-RdeptToRplbsOfstReq(R_PLBS_OFST_REQ): R_DEPT->>R_PLBS_OFST_REQ
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PLBS_OFST_REQImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PLBS_OFST_REQImpl.class ))
      {
         this.childCascadeFor_RdeptToRplbsOfstReq();
      }
      // Child Cascade for Role prToRdept(R_DEPT)-RdeptToRplbsDist(R_PLBS_DIST): R_DEPT->>R_PLBS_DIST
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PLBS_DISTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PLBS_DISTImpl.class ))
      {
         this.childCascadeFor_RdeptToRplbsDist();
      }
      // Child Cascade for Role prToRDept1(R_DEPT)-RDeptToRGrntrRpt1(R_GRNTR_RPT): R_DEPT->>R_GRNTR_RPT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_GRNTR_RPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_GRNTR_RPTImpl.class ))
      {
         this.childCascadeFor_RDeptToRGrntrRpt1();
      }
      // Child Cascade for Role prR_DEPT)-R_FNCATs1(R_FNCAT): R_DEPT->>R_FNCAT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FNCATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FNCATImpl.class ))
      {
         this.childCascadeFor_R_FNCATs1();
      }
      // Child Cascade for Role prtrSetpToRdept(R_DEPT)-RdeptToRcsalStpctrSetp(R_CSAL_STPCTR_SETP): R_DEPT->>R_CSAL_STPCTR_SETP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_CSAL_STPCTR_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_CSAL_STPCTR_SETPImpl.class ))
      {
         this.childCascadeFor_RdeptToRcsalStpctrSetp();
      }
      // Child Cascade for Role prR_DEPT)-R_BURs1(R_BUR): R_DEPT->>R_BUR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_BURImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_BURImpl.class ))
      {
         this.childCascadeFor_R_BURs1();
      }
      // Child Cascade for Role practg_RDept(R_DEPT)-RDept_RBfyStpfNactg(R_BFY_STPF_NACTG): R_DEPT->>R_BFY_STPF_NACTG
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_BFY_STPF_NACTGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_BFY_STPF_NACTGImpl.class ))
      {
         this.childCascadeFor_RDept_RBfyStpfNactg();
      }
      // Child Cascade for Role prDEPT)-AUTO_DOC_NOs(AUTO_DOC_NO): R_DEPT->>AUTO_DOC_NO
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(AUTO_DOC_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( AUTO_DOC_NOImpl.class ))
      {
         this.childCascadeFor_AUTO_DOC_NOs();
      }
      // Child Cascade for Role prept(R_DEPT)-RDeptVcVcust(VCC_DOC_VCUST): R_DEPT->>VCC_DOC_VCUST
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(VCC_DOC_VCUSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( VCC_DOC_VCUSTImpl.class ))
      {
         this.childCascadeFor_RDeptVcVcust();
      }
      // Child Cascade for Role prtRDept(R_DEPT)-RDeptVcAuthDept(VCC_DOC_AUTHDEPT): R_DEPT->>VCC_DOC_AUTHDEPT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(VCC_DOC_AUTHDEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( VCC_DOC_AUTHDEPTImpl.class ))
      {
         this.childCascadeFor_RDeptVcAuthDept();
      }
      // Child Cascade for Role prDEPT)-RQ_DOC_HDR(RQ_DOC_HDR): R_DEPT->>RQ_DOC_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(RQ_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( RQ_DOC_HDRImpl.class ))
      {
         this.childCascadeFor_RQ_DOC_HDR();
      }
      // Child Cascade for Role prmReqRcycSel(R_DEPT)-ReimReqRcycSelToDept(R_REIMRQD_RCYCSEL): R_DEPT->>R_REIMRQD_RCYCSEL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_REIMRQD_RCYCSELImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_REIMRQD_RCYCSELImpl.class ))
      {
         this.childCascadeFor_ReimReqRcycSelToDept();
      }
      // Child Cascade for Role prDept(R_DEPT)-RDeptToRPrtst(R_PRTST): R_DEPT->>R_PRTST
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PRTSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PRTSTImpl.class ))
      {
         this.childCascadeFor_RDeptToRPrtst();
      }
      // Child Cascade for Role prR_DEPT)-R_LOC_TBLs1(R_LOC_TBL): R_DEPT->>R_LOC_TBL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_LOC_TBLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_LOC_TBLImpl.class ))
      {
         this.childCascadeFor_R_LOC_TBLs1();
      }
      // Child Cascade for Role prRDept1(R_DEPT)-RDept1ToRIntCst(R_INT_CST_PARM): R_DEPT->>R_INT_CST_PARM
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_INT_CST_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_INT_CST_PARMImpl.class ))
      {
         this.childCascadeFor_RDept1ToRIntCst();
      }
      // Child Cascade for Role prtSchedToRDept(R_DEPT)-RDeptToRGrntrEvntSched(R_GRNTR_EVNT_SCHED): R_DEPT->>R_GRNTR_EVNT_SCHED
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_GRNTR_EVNT_SCHEDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_GRNTR_EVNT_SCHEDImpl.class ))
      {
         this.childCascadeFor_RDeptToRGrntrEvntSched();
      }
      // Child Cascade for Role prtToDept(R_DEPT)-DeptToEscrowHist(R_ESCROW_HIST): R_DEPT->>R_ESCROW_HIST
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_ESCROW_HISTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_ESCROW_HISTImpl.class ))
      {
         this.childCascadeFor_DeptToEscrowHist();
      }
      // Child Cascade for Role prR_DEPT)-R_DISB_MGMT_RSTRs2(R_DISB_MGMT_RSTR): R_DEPT->>R_DISB_MGMT_RSTR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DISB_MGMT_RSTRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DISB_MGMT_RSTRImpl.class ))
      {
         this.childCascadeFor_R_DISB_MGMT_RSTRs2();
      }
      // Child Cascade for Role prbtInstToDept(R_DEPT)-DeptToDebtDocDebtInst(DEBT_DOC_DEBTINST): R_DEPT->>DEBT_DOC_DEBTINST
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(DEBT_DOC_DEBTINSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( DEBT_DOC_DEBTINSTImpl.class ))
      {
         this.childCascadeFor_DeptToDebtDocDebtInst();
      }
      // Child Cascade for Role prR_DEPT)-SO_DOC_HDRs2(SO_DOC_HDR): R_DEPT->>SO_DOC_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(SO_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( SO_DOC_HDRImpl.class ))
      {
         this.childCascadeFor_SO_DOC_HDRs2();
      }
      // Child Cascade for Role prDept(R_DEPT)-RDeptToREquip(R_EQUIP): R_DEPT->>R_EQUIP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_EQUIPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_EQUIPImpl.class ))
      {
         this.childCascadeFor_RDeptToREquip();
      }
      // Child Cascade for Role prR_DEPT)-R_DRSCLSs1(R_DRSCLS): R_DEPT->>R_DRSCLS
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DRSCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DRSCLSImpl.class ))
      {
         this.childCascadeFor_R_DRSCLSs1();
      }
      // Child Cascade for Role prR_DEPT)-R_DIVs1(R_DIV): R_DEPT->>R_DIV
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DIVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DIVImpl.class ))
      {
         this.childCascadeFor_R_DIVs1();
      }
      // Child Cascade for Role proRDept(R_DEPT)-RDeptToPHMDocLn(PHM_DOC_LINE): R_DEPT->>PHM_DOC_LINE
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(PHM_DOC_LINEImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( PHM_DOC_LINEImpl.class ))
      {
         this.childCascadeFor_RDeptToPHMDocLn();
      }
      // Child Cascade for Role proDept(R_DEPT)-DeptToInfApBY2(INF_APBY2): R_DEPT->>INF_APBY2
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_APBY2Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_APBY2Impl.class ))
      {
         this.childCascadeFor_DeptToInfApBY2();
      }
      // Child Cascade for Role proDept(R_DEPT)-DeptToApEdiHdr(AP_EDI_HDR): R_DEPT->>AP_EDI_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(AP_EDI_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( AP_EDI_HDRImpl.class ))
      {
         this.childCascadeFor_DeptToApEdiHdr();
      }
      // Child Cascade for Role prjToDept(R_DEPT)-DeptToReimExpAdj(R_REIM_EXP_ADJ): R_DEPT->>R_REIM_EXP_ADJ
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_REIM_EXP_ADJImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_REIM_EXP_ADJImpl.class ))
      {
         this.childCascadeFor_DeptToReimExpAdj();
      }
      // Child Cascade for Role prDocCrsRef(R_DEPT)-PrgDocCrsRefToDept(R_PROG_DOC_CRSREF): R_DEPT->>R_PROG_DOC_CRSREF
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PROG_DOC_CRSREFImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PROG_DOC_CRSREFImpl.class ))
      {
         this.childCascadeFor_PrgDocCrsRefToDept();
      }
      // Child Cascade for Role prR_DEPT)-R_PHASEs(R_PHASE): R_DEPT->>R_PHASE
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PHASEImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PHASEImpl.class ))
      {
         this.childCascadeFor_R_PHASEs();
      }
      // Child Cascade for Role prR_DEPT)-R_LOCs2(R_LOC): R_DEPT->>R_LOC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_LOCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_LOCImpl.class ))
      {
         this.childCascadeFor_R_LOCs2();
      }
      // Child Cascade for Role prtToRDept(R_DEPT)-RDeptToRGrntDtDet(R_GRNT_DT_DET): R_DEPT->>R_GRNT_DT_DET
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_GRNT_DT_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_GRNT_DT_DETImpl.class ))
      {
         this.childCascadeFor_RDeptToRGrntDtDet();
      }
      // Child Cascade for Role prtSchedToRDept1(R_DEPT)-RDeptToRGrntrEvntSched1(R_GRNTR_EVNT_SCHED): R_DEPT->>R_GRNTR_EVNT_SCHED
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_GRNTR_EVNT_SCHEDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_GRNTR_EVNT_SCHEDImpl.class ))
      {
         this.childCascadeFor_RDeptToRGrntrEvntSched1();
      }
      // Child Cascade for Role prept(R_DEPT)-DeptToFDTOpt(R_FDT_OPT): R_DEPT->>R_FDT_OPT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FDT_OPTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FDT_OPTImpl.class ))
      {
         this.childCascadeFor_DeptToFDTOpt();
      }
      // Child Cascade for Role prR_DEPT)-R_DRSRCs1(R_DRSRC): R_DEPT->>R_DRSRC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DRSRCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DRSRCImpl.class ))
      {
         this.childCascadeFor_R_DRSRCs1();
      }
      // Child Cascade for Role prR_DEPT)-R_DOCLSs1(R_DOCLS): R_DEPT->>R_DOCLS
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DOCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DOCLSImpl.class ))
      {
         this.childCascadeFor_R_DOCLSs1();
      }
      // Child Cascade for Role prSetpToRdept(R_DEPT)-RdeptToRcsalCtrlSetp(R_CSAL_CTRL_SETP): R_DEPT->>R_CSAL_CTRL_SETP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_CSAL_CTRL_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_CSAL_CTRL_SETPImpl.class ))
      {
         this.childCascadeFor_RdeptToRcsalCtrlSetp();
      }
      // Child Cascade for Role prR_DEPT)-R_BUYR_FLINEs2(R_BUYR_FLINE): R_DEPT->>R_BUYR_FLINE
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_BUYR_FLINEImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_BUYR_FLINEImpl.class ))
      {
         this.childCascadeFor_R_BUYR_FLINEs2();
      }
      // Child Cascade for Role pryDebtToDept(R_DEPT)-DeptToAlwPymntByDebt(R_ALW_PYMT_DBTYP): R_DEPT->>R_ALW_PYMT_DBTYP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_ALW_PYMT_DBTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_ALW_PYMT_DBTYPImpl.class ))
      {
         this.childCascadeFor_DeptToAlwPymntByDebt();
      }
      // Child Cascade for Role prudRule(R_DEPT)-GnBudRuleToDept(GN_BUD_RULE): R_DEPT->>GN_BUD_RULE
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(GN_BUD_RULEImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( GN_BUD_RULEImpl.class ))
      {
         this.childCascadeFor_GnBudRuleToDept();
      }
      // Child Cascade for Role prR_DEPT)-R_RSTR_USEs(R_RSTR_USE): R_DEPT->>R_RSTR_USE
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_RSTR_USEImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_RSTR_USEImpl.class ))
      {
         this.childCascadeFor_R_RSTR_USEs();
      }
      // Child Cascade for Role prc(R_DEPT)-R_FACCs(R_FACC): R_DEPT->>R_FACC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FACCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FACCImpl.class ))
      {
         this.childCascadeFor_R_FACCs();
      }
      // Child Cascade for Role prT(R_DEPT)-ECRTToDept(R_EXTR_CASH_RECT): R_DEPT->>R_EXTR_CASH_RECT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_EXTR_CASH_RECTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_EXTR_CASH_RECTImpl.class ))
      {
         this.childCascadeFor_ECRTToDept();
      }
      // Child Cascade for Role prR_DEPT)-R_DOGRPs1(R_DOGRP): R_DEPT->>R_DOGRP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DOGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DOGRPImpl.class ))
      {
         this.childCascadeFor_R_DOGRPs1();
      }
      // Child Cascade for Role prept(R_DEPT)-DeptToClmtrk(R_CLMTRK): R_DEPT->>R_CLMTRK
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_CLMTRKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_CLMTRKImpl.class ))
      {
         this.childCascadeFor_DeptToClmtrk();
      }
      // Child Cascade for Role prToDept(R_DEPT)-DeptToCADocHist(R_CA_DOC_HIST): R_DEPT->>R_CA_DOC_HIST
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_CA_DOC_HISTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_CA_DOC_HISTImpl.class ))
      {
         this.childCascadeFor_DeptToCADocHist();
      }
      // Child Cascade for Role proDept(R_DEPT)-DeptToDisbExcp(R_AP_DISB_EXCP): R_DEPT->>R_AP_DISB_EXCP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_AP_DISB_EXCPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_AP_DISB_EXCPImpl.class ))
      {
         this.childCascadeFor_DeptToDisbExcp();
      }
      // Child Cascade for Role prR_DEPT)-R_ACLSs1(R_ACLS): R_DEPT->>R_ACLS
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_ACLSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_ACLSImpl.class ))
      {
         this.childCascadeFor_R_ACLSs1();
      }
      // Child Cascade for Role prcFederalTaxPaymentSystemToDepartment(R_DEPT)-DepartmentToElectronicFederalTaxPaymentSystem(ELEC_FED_TAXP_SYS): R_DEPT->>ELEC_FED_TAXP_SYS
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(ELEC_FED_TAXP_SYSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( ELEC_FED_TAXP_SYSImpl.class ))
      {
         this.childCascadeFor_DepartmentToElectronicFederalTaxPaymentSystem();
      }
      // Child Cascade for Role prR_DEPT)-ACRL_CLR_MGMT_1(ACRL_CLR_MGMT): R_DEPT->>ACRL_CLR_MGMT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(ACRL_CLR_MGMTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( ACRL_CLR_MGMTImpl.class ))
      {
         this.childCascadeFor_ACRL_CLR_MGMT_1();
      }
      // Child Cascade for Role prR_DEPT)-R_SECTs1(R_SECT): R_DEPT->>R_SECT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_SECTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_SECTImpl.class ))
      {
         this.childCascadeFor_R_SECTs1();
      }
      // Child Cascade for Role prDocCrsRef1_1(R_DEPT)-PrgDocCrsRef1ToDept_1(R_PROG_DOC_CRSREF): R_DEPT->>R_PROG_DOC_CRSREF
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PROG_DOC_CRSREFImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PROG_DOC_CRSREFImpl.class ))
      {
         this.childCascadeFor_PrgDocCrsRef1ToDept_1();
      }
      // Child Cascade for Role prrActg(R_DEPT)-IntrActgToDept(R_INTR_ACTG_CRSWLK): R_DEPT->>R_INTR_ACTG_CRSWLK
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_INTR_ACTG_CRSWLKImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_INTR_ACTG_CRSWLKImpl.class ))
      {
         this.childCascadeFor_IntrActgToDept();
      }
      // Child Cascade for Role prR_DEPT)-R_DOTYPs1(R_DOTYP): R_DEPT->>R_DOTYP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DOTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DOTYPImpl.class ))
      {
         this.childCascadeFor_R_DOTYPs1();
      }
      // Child Cascade for Role proRqstDept(R_DEPT)-RqstDeptToMaDocHdr(MA_DOC_HDR): R_DEPT->>MA_DOC_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(MA_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( MA_DOC_HDRImpl.class ))
      {
         this.childCascadeFor_RqstDeptToMaDocHdr();
      }
      // Child Cascade for Role proDept(R_DEPT)-DeptToInfAppr2(INF_APPR2): R_DEPT->>INF_APPR2
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_APPR2Impl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_APPR2Impl.class ))
      {
         this.childCascadeFor_DeptToInfAppr2();
      }
      // Child Cascade for Role proDept(R_DEPT)-DeptToGRDocHdr(GR_DOC_HDR): R_DEPT->>GR_DOC_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(GR_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( GR_DOC_HDRImpl.class ))
      {
         this.childCascadeFor_DeptToGRDocHdr();
      }
      // Child Cascade for Role prthToDept(R_DEPT)-DeptToDebtDocAuth(DEBT_DOC_AUTH): R_DEPT->>DEBT_DOC_AUTH
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(DEBT_DOC_AUTHImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( DEBT_DOC_AUTHImpl.class ))
      {
         this.childCascadeFor_DeptToDebtDocAuth();
      }
      // Child Cascade for Role proToDept(R_DEPT)-DeptToAutoPartNo(AUTO_PART_NO): R_DEPT->>AUTO_PART_NO
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(AUTO_PART_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( AUTO_PART_NOImpl.class ))
      {
         this.childCascadeFor_DeptToAutoPartNo();
      }
      // Child Cascade for Role prpt(R_DEPT)-DeptToADHdr(AD_DOC_HDR): R_DEPT->>AD_DOC_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(AD_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( AD_DOC_HDRImpl.class ))
      {
         this.childCascadeFor_DeptToADHdr();
      }
      // Child Cascade for Role prR_DEPT)-RCLS_PARM_DTL1(RCLS_PARM_DTL): R_DEPT->>RCLS_PARM_DTL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(RCLS_PARM_DTLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( RCLS_PARM_DTLImpl.class ))
      {
         this.childCascadeFor_RCLS_PARM_DTL1();
      }
      // Child Cascade for Role prpt(R_DEPT)-DeptToVcust(R_VEND_CUST): R_DEPT->>R_VEND_CUST
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_VEND_CUSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_VEND_CUSTImpl.class ))
      {
         this.childCascadeFor_DeptToVcust();
      }
      // Child Cascade for Role prept(R_DEPT)-DeptToMsmals(R_MSMALS): R_DEPT->>R_MSMALS
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_MSMALSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_MSMALSImpl.class ))
      {
         this.childCascadeFor_DeptToMsmals();
      }
      // Child Cascade for Role prRDept(R_DEPT)-RDeptToRIntCst(R_INT_CST_PARM): R_DEPT->>R_INT_CST_PARM
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_INT_CST_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_INT_CST_PARMImpl.class ))
      {
         this.childCascadeFor_RDeptToRIntCst();
      }
      // Child Cascade for Role prR_DEPT)-R_FUNCs1(R_FUNC): R_DEPT->>R_FUNC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FUNCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FUNCImpl.class ))
      {
         this.childCascadeFor_R_FUNCs1();
      }
      // Child Cascade for Role prpt(R_DEPT)-RDeptToRFac(R_FAC): R_DEPT->>R_FAC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FACImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FACImpl.class ))
      {
         this.childCascadeFor_RDeptToRFac();
      }
      // Child Cascade for Role proRDept(R_DEPT)-RDeptToREmpInfo(R_EMP_INFO): R_DEPT->>R_EMP_INFO
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_EMP_INFOImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_EMP_INFOImpl.class ))
      {
         this.childCascadeFor_RDeptToREmpInfo();
      }
      // Child Cascade for Role prpPolToDept(R_DEPT)-DeptToDeptTrvlxpPol(R_DEPT_TRVLXP_POL): R_DEPT->>R_DEPT_TRVLXP_POL
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DEPT_TRVLXP_POLImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DEPT_TRVLXP_POLImpl.class ))
      {
         this.childCascadeFor_DeptToDeptTrvlxpPol();
      }
      // Child Cascade for Role prnstToDept(R_DEPT)-DeptToDebtDebtInst(R_DEBT_DEBTINST): R_DEPT->>R_DEBT_DEBTINST
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DEBT_DEBTINSTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DEBT_DEBTINSTImpl.class ))
      {
         this.childCascadeFor_DeptToDebtDebtInst();
      }
      // Child Cascade for Role prdToRDept(R_DEPT)-RDeptToRCntrcGlhd(R_CNTRC_GOAL_HDR): R_DEPT->>R_CNTRC_GOAL_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_CNTRC_GOAL_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_CNTRC_GOAL_HDRImpl.class ))
      {
         this.childCascadeFor_RDeptToRCntrcGlhd();
      }
      // Child Cascade for Role prDEPT)-ACRL_CLR_MGMT(ACRL_CLR_MGMT): R_DEPT->>ACRL_CLR_MGMT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(ACRL_CLR_MGMTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( ACRL_CLR_MGMTImpl.class ))
      {
         this.childCascadeFor_ACRL_CLR_MGMT();
      }
      // Child Cascade for Role prept(R_DEPT)-DeptToABSHdr(ABS_DOC_HDR): R_DEPT->>ABS_DOC_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(ABS_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( ABS_DOC_HDRImpl.class ))
      {
         this.childCascadeFor_DeptToABSHdr();
      }
      // Child Cascade for Role prndToDept(R_DEPT)-DeptToTrvlDocVend(TRVL_DOC_VEND): R_DEPT->>TRVL_DOC_VEND
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(TRVL_DOC_VENDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( TRVL_DOC_VENDImpl.class ))
      {
         this.childCascadeFor_DeptToTrvlDocVend();
      }
      // Child Cascade for Role prR_DEPT)-R_REIM_FREQ_DTs1(R_REIM_FREQ_DT): R_DEPT->>R_REIM_FREQ_DT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_REIM_FREQ_DTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_REIM_FREQ_DTImpl.class ))
      {
         this.childCascadeFor_R_REIM_FREQ_DTs1();
      }
      // Child Cascade for Role prR_DEPT)-R_OTPT_PARM_DETs5(R_OTPT_PARM_DET): R_DEPT->>R_OTPT_PARM_DET
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_OTPT_PARM_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_OTPT_PARM_DETImpl.class ))
      {
         this.childCascadeFor_R_OTPT_PARM_DETs5();
      }
      // Child Cascade for Role prR_DEPT)-R_MGR(R_MGR): R_DEPT->>R_MGR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_MGRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_MGRImpl.class ))
      {
         this.childCascadeFor_R_MGR();
      }
      // Child Cascade for Role prR_DEPT)-R_GPs1(R_GP): R_DEPT->>R_GP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_GPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_GPImpl.class ))
      {
         this.childCascadeFor_R_GPs1();
      }
      // Child Cascade for Role prultiToRDept(R_DEPT)-RDeptToREmplBenMulti(R_EMPL_BEN_MULTI): R_DEPT->>R_EMPL_BEN_MULTI
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_EMPL_BEN_MULTIImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_EMPL_BEN_MULTIImpl.class ))
      {
         this.childCascadeFor_RDeptToREmplBenMulti();
      }
      // Child Cascade for Role prR_DEPT)-R_DRSGRPs1(R_DRSGRP): R_DEPT->>R_DRSGRP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DRSGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DRSGRPImpl.class ))
      {
         this.childCascadeFor_R_DRSGRPs1();
      }
      // Child Cascade for Role prR_DEPT)-R_DOBJs1(R_DOBJ): R_DEPT->>R_DOBJ
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DOBJImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DOBJImpl.class ))
      {
         this.childCascadeFor_R_DOBJs1();
      }
      // Child Cascade for Role prDEPT)-PO_DOC_HDR(PO_DOC_HDR): R_DEPT->>PO_DOC_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(PO_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( PO_DOC_HDRImpl.class ))
      {
         this.childCascadeFor_PO_DOC_HDR();
      }
      // Child Cascade for Role prept(R_DEPT)-RDeptVcPrvnt(VCC_DOC_PRVNT): R_DEPT->>VCC_DOC_PRVNT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(VCC_DOC_PRVNTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( VCC_DOC_PRVNTImpl.class ))
      {
         this.childCascadeFor_RDeptVcPrvnt();
      }
      // Child Cascade for Role prDEPT)-R_PROG_GIS_LOC(R_PROG_GIS_LOC): R_DEPT->>R_PROG_GIS_LOC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PROG_GIS_LOCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PROG_GIS_LOCImpl.class ))
      {
         this.childCascadeFor_R_PROG_GIS_LOC();
      }
      // Child Cascade for Role prDept(R_DEPT)-DeptToPartTyp(R_PART_TYP): R_DEPT->>R_PART_TYP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PART_TYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PART_TYPImpl.class ))
      {
         this.childCascadeFor_DeptToPartTyp();
      }
      // Child Cascade for Role prR_DEPT)-R_LCATs1(R_LCAT): R_DEPT->>R_LCAT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_LCATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_LCATImpl.class ))
      {
         this.childCascadeFor_R_LCATs1();
      }
      // Child Cascade for Role prUserToRDept(R_DEPT)-RDeptToRGrntAlrtUser(R_GRNT_ALRT_USER): R_DEPT->>R_GRNT_ALRT_USER
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_GRNT_ALRT_USERImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_GRNT_ALRT_USERImpl.class ))
      {
         this.childCascadeFor_RDeptToRGrntAlrtUser();
      }
      // Child Cascade for Role proRDept(R_DEPT)-RDeptToRFndgGrp(R_FNDG_GRP): R_DEPT->>R_FNDG_GRP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FNDG_GRPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FNDG_GRPImpl.class ))
      {
         this.childCascadeFor_RDeptToRFndgGrp();
      }
      // Child Cascade for Role prpt(R_DEPT)-RDeptToRFgc(R_FGC): R_DEPT->>R_FGC
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FGCImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FGCImpl.class ))
      {
         this.childCascadeFor_RDeptToRFgc();
      }
      // Child Cascade for Role prDept(R_DEPT)-RDeptToFarHdr(R_FAR_HDR): R_DEPT->>R_FAR_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FAR_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FAR_HDRImpl.class ))
      {
         this.childCascadeFor_RDeptToFarHdr();
      }
      // Child Cascade for Role prR_DEPT)-R_DRSTYPs1(R_DRSTYP): R_DEPT->>R_DRSTYP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DRSTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DRSTYPImpl.class ))
      {
         this.childCascadeFor_R_DRSTYPs1();
      }
      // Child Cascade for Role prR_DEPT)-R_DRSCATs1(R_DRSCAT): R_DEPT->>R_DRSCAT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DRSCATImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DRSCATImpl.class ))
      {
         this.childCascadeFor_R_DRSCATs1();
      }
      // Child Cascade for Role prR_DEPT)-R_ACTVs6(R_ACTV): R_DEPT->>R_ACTV
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_ACTVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_ACTVImpl.class ))
      {
         this.childCascadeFor_R_ACTVs6();
      }
      // Child Cascade for Role prToDept(R_DEPT)-DeptToPoSrtyIns(PO_DOC_SRTYINS): R_DEPT->>PO_DOC_SRTYINS
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(PO_DOC_SRTYINSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( PO_DOC_SRTYINSImpl.class ))
      {
         this.childCascadeFor_DeptToPoSrtyIns();
      }
      // Child Cascade for Role prmDfltToRDpt(R_DEPT)-RDptToROnPrnParmDflt(ONLN_PRN_PARM_DFLT): R_DEPT->>ONLN_PRN_PARM_DFLT
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(ONLN_PRN_PARM_DFLTImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( ONLN_PRN_PARM_DFLTImpl.class ))
      {
         this.childCascadeFor_RDptToROnPrnParmDflt();
      }
      // Child Cascade for Role prDept(R_DEPT)-DeptToInfApBY(INF_APBY): R_DEPT->>INF_APBY
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(INF_APBYImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( INF_APBYImpl.class ))
      {
         this.childCascadeFor_DeptToInfApBY();
      }
      // Child Cascade for Role pruserToRDept(R_DEPT)-RDeptToGtDocAlrtuser(GT_DOC_ALRTUSER): R_DEPT->>GT_DOC_ALRTUSER
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(GT_DOC_ALRTUSERImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( GT_DOC_ALRTUSERImpl.class ))
      {
         this.childCascadeFor_RDeptToGtDocAlrtuser();
      }
      // Child Cascade for Role proFADocHdr(R_DEPT)-FA_DOC_HDRs1(FA_DOC_HDR): R_DEPT->>FA_DOC_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(FA_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( FA_DOC_HDRImpl.class ))
      {
         this.childCascadeFor_FA_DOC_HDRs1();
      }
      // Child Cascade for Role prgoingToDept(R_DEPT)-DeptToARRADocOngoing(ARRA_DOC_ONGOING): R_DEPT->>ARRA_DOC_ONGOING
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(ARRA_DOC_ONGOINGImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( ARRA_DOC_ONGOINGImpl.class ))
      {
         this.childCascadeFor_DeptToARRADocOngoing();
      }
      // Child Cascade for Role prtrlyAwdToDepartment(R_DEPT)-DepartmentToSubRcpntQtrlyAwd(R_SRCPNT_QTRLY_AWD): R_DEPT->>R_SRCPNT_QTRLY_AWD
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_SRCPNT_QTRLY_AWDImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_SRCPNT_QTRLY_AWDImpl.class ))
      {
         this.childCascadeFor_DepartmentToSubRcpntQtrlyAwd();
      }
      // Child Cascade for Role prToRdept(R_DEPT)-RdeptToRplbsSetp(R_PLBS_SETP): R_DEPT->>R_PLBS_SETP
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_PLBS_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_PLBS_SETPImpl.class ))
      {
         this.childCascadeFor_RdeptToRplbsSetp();
      }
      // Child Cascade for Role prR_DEPT)-R_OTPT_PARM_DETs4(R_OTPT_PARM_DET): R_DEPT->>R_OTPT_PARM_DET
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_OTPT_PARM_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_OTPT_PARM_DETImpl.class ))
      {
         this.childCascadeFor_R_OTPT_PARM_DETs4();
      }
      // Child Cascade for Role prntCstOtMulti1(R_DEPT)-RIntCstOtMultiToRDept1(R_INT_CST_OT_MULTI): R_DEPT->>R_INT_CST_OT_MULTI
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_INT_CST_OT_MULTIImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_INT_CST_OT_MULTIImpl.class ))
      {
         this.childCascadeFor_RIntCstOtMultiToRDept1();
      }
      // Child Cascade for Role prR_DEPT)-R_FNCLSs1(R_FNCLS): R_DEPT->>R_FNCLS
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_FNCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_FNCLSImpl.class ))
      {
         this.childCascadeFor_R_FNCLSs1();
      }
      // Child Cascade for Role pr_DEPT)-R_DISB_MGMT_RSTR_1(R_DISB_MGMT_RSTR): R_DEPT->>R_DISB_MGMT_RSTR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DISB_MGMT_RSTRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DISB_MGMT_RSTRImpl.class ))
      {
         this.childCascadeFor_R_DISB_MGMT_RSTR_1();
      }
      // Child Cascade for Role prDEPT)-R_DISB_MGMT_RSTR(R_DISB_MGMT_RSTR): R_DEPT->>R_DISB_MGMT_RSTR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_DISB_MGMT_RSTRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_DISB_MGMT_RSTRImpl.class ))
      {
         this.childCascadeFor_R_DISB_MGMT_RSTR();
      }
      // Child Cascade for Role prDEPT)-R_CMIA_INTR_PARMs(R_CMIA_INTR_PARM): R_DEPT->>R_CMIA_INTR_PARM
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_CMIA_INTR_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_CMIA_INTR_PARMImpl.class ))
      {
         this.childCascadeFor_R_CMIA_INTR_PARMs();
      }
      // Child Cascade for Role prev_RDept(R_DEPT)-RDept_RBfyStpfRev(R_BFY_STPF_REV): R_DEPT->>R_BFY_STPF_REV
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(R_BFY_STPF_REVImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( R_BFY_STPF_REVImpl.class ))
      {
         this.childCascadeFor_RDept_RBfyStpfRev();
      }
      // Child Cascade for Role prgToDept(R_DEPT)-DeptToIctDocActg(ICT_DOC_HDR): R_DEPT->>ICT_DOC_HDR
      if(!(myBehavior.get(AMSBEHAVIOR_NO_CASCADE_ON_PARENT_DELETE))
      && !(ICT_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_NO_CASCADE_RECEIVING))
      && isValidChildCascade( ICT_DOC_HDRImpl.class ))
      {
         this.childCascadeFor_DeptToIctDocActg();
      }
   }
   else
   {
      //Bypassing child cascades this delete; reset this behavior for next time
      mboolPerformCascade = true ;
   } 

   // Do the Parent Adjustment.

   // Post Rule Event
   postRuleEvent(VLSEvent.AFTER_DELETE, null);

   // Delete all attachments that are associated with this record.
   String lsObjAttType = getObjectAttType() ;

   if (lsObjAttType != null)
   {
      SearchRequest  loSearchReq ;
      Parameter      loParam ;
      String         lsValue     = null ;
      String         lsFieldName  = null ;

      if(lsObjAttType.equals(OBJ_ATT_TYPE_REF_TBL))
      {
         lsValue = getData( AMSCommonConstants.ATTR_OBJ_ATT_PG_UNID ).getString() ;
         lsFieldName = AMSCommonConstants.ATTR_OBJ_ATT_PG_UNID ;
      }
      else if(lsObjAttType.equals(OBJ_ATT_TYPE_ALT_VIEW))
      {
         lsValue = getData( AMSCommonConstants.ATTR_OBJ_ATT_ALT_UNID ).getString() ;
         lsFieldName = AMSCommonConstants.ATTR_OBJ_ATT_ALT_UNID ;
      }

      if (lsValue != null)
      {
         loSearchReq = new SearchRequest() ;
         loParam = new Parameter();
         loParam.objName = "IN_OBJ_ATT_CTLG";
         loParam.fieldName = lsFieldName;
         loParam.value = lsValue;
         loSearchReq.add(loParam);
      
         Enumeration leRows = null ;
         IN_OBJ_ATT_CTLGImpl loRow = null ;

         leRows = IN_OBJ_ATT_CTLGImpl.getObjects( loSearchReq, this.getSession() ) ;

         if(lsObjAttType.equals( OBJ_ATT_TYPE_REF_TBL ))
         {
            while (leRows.hasMoreElements())
            {
               loRow = (IN_OBJ_ATT_CTLGImpl)leRows.nextElement();
               loRow.setDelete() ;
               loRow.save() ;
            }
         }
         else if(lsObjAttType.equals( OBJ_ATT_TYPE_ALT_VIEW ))
         {
            while (leRows.hasMoreElements())
            {
               loRow = (IN_OBJ_ATT_CTLGImpl)leRows.nextElement();
               
               if (loRow.getData( ATTR_OBJ_ATT_ST ).getint() == OBJ_ATT_ST_ARCHIVED)
               {  
                  loRow.setDelete() ;
                  loRow.save() ;
               }
               else
               {
                  loRow.getData( ATTR_OBJ_ATT_ALT_ST ).setint( OBJ_ATT_ST_DELETED ) ;
                  loRow.save() ;
               }
            } /* end of while (leRows.hasMoreElements()) */
         } /* end of if(lsObjAttType.equals(OBJ_ATT_TYPE_ALT_VIEW )) */
      } /* end of if (lsValue != null && lsFieldName != null) */
   } /* end of if (lsObjAttType != null) */
   // This concludes the delete procedure.
   
   
}   

protected void setDefaultValueForAggregates()
{
   // Set the default values, i.e. Zero, for the aggregate attributes
}

protected void setFormulaValues()
{
      Data dataVal = null;
      IVSTrace tr = null;
      long tr_id = 0;

         if ( isFormulaEnabled( "DEPT_NM_UP", false ) )
         {
         try {
            if ( VSTrace.IS_ON ) {
                  tr = VSTrace.get(); 
                  tr_id = tr.beg(logger);
                  tr.set(VST_CATEGORY,"VST_RULE_DERIVATION").set(VST_OBJECT_NAME, this.getClass().getName() + "_" + "DEPT_NM_UP" );
               }
            
                     getDEPT_NM();
                  setDEPT_NM_UP((String)(AMSDataObject.toUpperCaseString(this.getDEPT_NM())));
            } catch (Exception ex) {

               if(isValidationRequired())
               handleAttributeFormulaException(ex, "DEPT_NM_UP");
            } finally {
               if ( tr != null ) tr.end( tr_id );
            }        

         }
         if ( isFormulaEnabled( "DEPT_SH_NM_UP", false ) )
         {
         try {
            if ( VSTrace.IS_ON ) {
                  tr = VSTrace.get(); 
                  tr_id = tr.beg(logger);
                  tr.set(VST_CATEGORY,"VST_RULE_DERIVATION").set(VST_OBJECT_NAME, this.getClass().getName() + "_" + "DEPT_SH_NM_UP" );
               }
            
                     getDEPT_SH_NM();
                  setDEPT_SH_NM_UP((String)(AMSDataObject.toUpperCaseString(this.getDEPT_SH_NM())));
            } catch (Exception ex) {

               if(isValidationRequired())
               handleAttributeFormulaException(ex, "DEPT_SH_NM_UP");
            } finally {
               if ( tr != null ) tr.end( tr_id );
            }        

         }
         if ( isFormulaEnabled( "DEPT_DSCR_UP", false ) )
         {
         try {
            if ( VSTrace.IS_ON ) {
                  tr = VSTrace.get(); 
                  tr_id = tr.beg(logger);
                  tr.set(VST_CATEGORY,"VST_RULE_DERIVATION").set(VST_OBJECT_NAME, this.getClass().getName() + "_" + "DEPT_DSCR_UP" );
               }
            
                     getDEPT_DSCR();
                  setDEPT_DSCR_UP((String)(AMSDataObject.toUpperCaseString(this.getDEPT_DSCR())));
            } catch (Exception ex) {

               if(isValidationRequired())
               handleAttributeFormulaException(ex, "DEPT_DSCR_UP");
            } finally {
               if ( tr != null ) tr.end( tr_id );
            }        

         }
}
  
 protected void setFormulaValuesWithoutException()
 {
       Data dataVal = null;
 
         if ( isFormulaEnabled( "DEPT_NM_UP", true ) )
         {
          try {
                    getDEPT_NM();
                 setDEPT_NM_UP((String)(AMSDataObject.toUpperCaseString(this.getDEPT_NM())));
          } catch (Exception ex) {
            // handleAttributeFormulaException(ex, "DEPT_NM_UP");
         }
         }
         if ( isFormulaEnabled( "DEPT_SH_NM_UP", true ) )
         {
          try {
                    getDEPT_SH_NM();
                 setDEPT_SH_NM_UP((String)(AMSDataObject.toUpperCaseString(this.getDEPT_SH_NM())));
          } catch (Exception ex) {
            // handleAttributeFormulaException(ex, "DEPT_SH_NM_UP");
         }
         }
         if ( isFormulaEnabled( "DEPT_DSCR_UP", true ) )
         {
          try {
                    getDEPT_DSCR();
                 setDEPT_DSCR_UP((String)(AMSDataObject.toUpperCaseString(this.getDEPT_DSCR())));
          } catch (Exception ex) {
            // handleAttributeFormulaException(ex, "DEPT_DSCR_UP");
         }
         }
  }
  
   public void tableConstraintCheck() 
   {

         try {


                    getTEAM_ID();
                    getBUYR_ID();
                 if ( ! isNull("BUYR_ID")  &&  ! isNull("TEAM_ID") ) {
                       raiseException("%c:A516,v:[b:R_DEPT/DEPT_CD]%","R_DEPT","BUYR_ID");
                 }

         } catch (Exception ex) {
             String dependents[] = {                "TEAM_ID"
               ,  "BUYR_ID"
 };
            handleConstraintValidationException(ex, "BuyerOrBuyerTeam", dependents);
         }
   
         try {


                    getDLGTD_TEAM_ID();
                 if ((  ( isInserted() == true )  ||  ( isUpdated() == true )  ) &&  ! isNull("DLGTD_TEAM_ID")  && getDelegatedTeam( ) !=  null  && ( getDelegatedTeam( ).getMGR_TEAM( ) ==  true  || getDelegatedTeam( ).getEVAL_TEAM( ) ==  true  )) {
                       raiseException("%c:A1686,v:[b:R_DEPT/DEPT_CD]%","R_DEPT","DLGTD_TEAM_ID");
                 }

         } catch (Exception ex) {
             String dependents[] = {                "DLGTD_TEAM_ID"
 };
            handleConstraintValidationException(ex, "DlgtdBuyerTeamConstraint", dependents);
         }
   
         try {


                    getAR_UNIT_INFR();
                 if ((  ( isInserted() == true )  ||  ( isUpdated() == true )  ) && R_RV_SOPTImpl.getRvOptionsAR_DEPT_INFR(getSession( ) , R_CLDTImpl.getCLDTInfoFY(getSession( ))) == CVL_INFR_DP_UNImpl.SETTOALL && this.getAR_UNIT_INFR() != CVL_INFR_DP_UNImpl.SETTOALL) {
                       raiseException("%c:A2070%","R_DEPT","");
                 }

         } catch (Exception ex) {
             String dependents[] = {                "AR_UNIT_INFR"
 };
            handleConstraintValidationException(ex, "ARUnitInferValidate", dependents);
         }
   
         try {


                    getEFEND_DT();
                    getEFBGN_DT();
                 if (( (  ( isInserted() == true )  ||  ( isUpdated() == true )  ) && (  ! isNull("EFBGN_DT")  ) && (  ! isNull("EFEND_DT")  ) && ( (this.getEFBGN_DT()).after(this.getEFEND_DT()) ) )) {
                       raiseException("%c:A1050%","R_DEPT","");
                 }

         } catch (Exception ex) {
             String dependents[] = {                "EFEND_DT"
               ,  "EFBGN_DT"
 };
            handleConstraintValidationException(ex, "EffectiveDateCheck", dependents);
         }
   
         try {


                 if ((  ( isInserted() == true )  ||  ( isUpdated() == true )  ) && ( validateBaseDepartmentValue( ) ==  false  )) {
                       raiseException("%c:A4386,v:[b:R_DEPT/BASE_DEPT_FL]%","R_DEPT","BASE_DEPT_FL");
                 }

         } catch (Exception ex) {
             String dependents[] = { };
            handleConstraintValidationException(ex, "OnlyOneDeptAlw", dependents);
         }
   
         try {


                    getTEAM_ID();
                 if ((  ( isInserted() == true )  ||  ( isUpdated() == true )  ) &&  ! isNull("TEAM_ID")  && ( isBuyerTeamValidOnWorkloadTable( ) ==  false  )) {
                       raiseException("%c:A637%","R_DEPT","");
                 }

         } catch (Exception ex) {
             String dependents[] = {                "TEAM_ID"
 };
            handleConstraintValidationException(ex, "BuyerTeamConstraint", dependents);
         }
   
         try {


                 if ((  ( isInserted() == true )  ||  ( isUpdated() == true )  ) && ( AMSStringUtil.strIsEmpty(getTRVL_POL( )) ==  false  ) && ( R_TRVL_POLImpl.isActiveTrvlPol(getSession( ) , getTRVL_POL( )) ==  false  )) {
                       raiseException("%c:A381,v:[b:R_DEPT/TRVL_POL]%","R_DEPT","TRVL_POL");
                 }

         } catch (Exception ex) {
             String dependents[] = { };
            handleConstraintValidationException(ex, "ChkForActiveTrvlPol", dependents);
         }
   
         try {


                    getDLGTD_BUYR_ID();
                    getDLGTD_TEAM_ID();
                 if ( ! isNull("DLGTD_BUYR_ID")  &&  ! isNull("DLGTD_TEAM_ID") ) {
                       raiseException("%c:A1685,v:[b:R_DEPT/DEPT_CD]%","R_DEPT","DLGTD_BUYR_ID");
                 }

         } catch (Exception ex) {
             String dependents[] = {                "DLGTD_BUYR_ID"
               ,  "DLGTD_TEAM_ID"
 };
            handleConstraintValidationException(ex, "DlgtdBuyerOrBuyerTeam", dependents);
         }
   
   }


private boolean columnRequiredCheck()
{
   boolean lboolReqExp = false ;

   if ( isInserted() || isUpdated() ) 
   {
      String lsCurrReq ;
      String lsCurrVal ;
      String lsCaption ;
      Data   loData ;

      for ( int liCtr = 0 ; liCtr < myRequired.size() ; liCtr++ )
      {
         lsCurrReq = (String)myRequired.elementAt( liCtr ) ;
         loData    = getData( lsCurrReq ) ;
         lsCurrVal = loData.getString() ;      

         if ( ( lsCurrVal == null ) || ( lsCurrVal.length() == 0 ) )
         {
            lboolReqExp = true ;
            lsCaption = loData.getMetaColumn().getCaption().trim() ;
            if ( lsCaption.length() > 0 )
            {
               raiseException( lsCaption + " is required.", "R_DEPT", lsCurrReq ) ;
            }
            else
            {
               raiseException( lsCurrReq + " is required.", "R_DEPT", lsCurrReq ) ;
            }
         }
      }   
   }
   return lboolReqExp ;
}


public void columnValidationCheck() 
{
}

   protected void parentCheckFor_DelegatedTeam()
   {
      IVSTrace tr = null;  long tr_id = 0;
      if ( VSTrace.IS_ON ) {
         tr = VSTrace.get(); 
         tr_id = tr.beg(logger);
         tr.set(VST_CATEGORY,VST_RULE).set(VST_ACTION_NAME,"parentCheckFor_DelegatedTeam").set(VST_OBJECT_NAME,"R_DEPT");
      }
      
      try {
       if(!isRelationshipEnabledfor_DelegatedTeam(getSession()))
       {
           return;
       }
       
         R_WRKLD_TEAMSImpl   parent = null;
         R_WRKLD_TEAMSImpl   oldParent = null;
         boolean      ParentKeyChanged = false;
         boolean      OrphanChildParenting;

         ParentExtension loParent = (ParentExtension)myParents.get("R_WRKLD_TEAMS");
         if(loParent != null)
         {
            Enumeration lenumExceptions = loParent.getExceptions();
            if(lenumExceptions != null)
            {
               while(lenumExceptions.hasMoreElements())
               {
                  String lsAttribute = (String)lenumExceptions.nextElement();
                  Data   loData      = this.getData(lsAttribute);
                  if(isExceptionAttributeApplicableForRole(
                     "DelegatedTeam",
                     "R_WRKLD_TEAMS",
                     lsAttribute,
                     loData.getString()))
                  {
                     if(loParent.isExceptional(
                        lsAttribute, 
                        ((loData.getString() == null) ? "" : loData.getString())))
                     {
                        return;
                     }
                  }
               }
            }
         }

         //
         // Is this an inclusion combo corresponding to an
         // already-failed exclusion combo?
         //
         if(this.mvFailedComboExcludeParents != null
         && R_WRKLD_TEAMSImpl.getType() == AMSPARENTTYPE_COMBO_IN
         && "R_WRKLD_TEAMS".startsWith("CVIN_"))
         {
             String ls = "CVEX_" + "R_WRKLD_TEAMS".substring(5);
             if(this.mvFailedComboExcludeParents.contains(ls))
             {
                 return;
             }
         }

 beforeParentCheck("R_WRKLD_TEAMS");

            if ((!R_WRKLD_TEAMSImpl.getBehaviors().get(AMSBEHAVIOR_ALLOW_NULL_KEY_PARENT_LOOKUPS)
            &&   (!isNull("DLGTD_TEAM_ID") )
            &&   (isInserted() || isUpdated()))
            ||  
                (R_WRKLD_TEAMSImpl.getBehaviors().get(AMSBEHAVIOR_ALLOW_NULL_KEY_PARENT_LOOKUPS )
            &&   (isInserted() || isUpdated())))
            {
               if (isOldNull("DLGTD_TEAM_ID") )
                  OrphanChildParenting = true;
               else
                  OrphanChildParenting = false;
               if ( isUpdated() && !OrphanChildParenting )

               {
                  // Argument value of false means get the old parent.
                  parent = this.getOldDelegatedTeam();
                  oldParent = parent ;
                  if (( parent != null ) && ( clientInitiatedUpdate() ))
                  {
                        if(isOverwriteableByReplicate("DLGTD_TEAM_NM")) this.forceOldValue("DLGTD_TEAM_NM", parent.getData("TEAM_NM"));
                  }
                  // See if the parent is null.

                  if ( parent == null ) // No parent found
                     ParentKeyChanged = true;
                  else
                     ParentKeyChanged = false;
               }

               parent = this.getDelegatedTeam();
               if ( ( oldParent != null ) && ( parent != null ) && ( oldParent == parent) &&
                    ( R_WRKLD_TEAMSImpl.isBehaviorEnabled( AMSBEHAVIOR_EFFECTIVE_DATED ) ) &&
                    ( !AMSUtil.isEffectiveDatedValid( getSession(), parent ) ) )
               {
                  /*
                   * It is necessary to make this check because the call to this.getDelegatedTeam() 
                   * will not apply the effective date filter for its getObjectByKey call if the
                   * call to this.getOldDelegatedTeam() used the same foreign key
                   * and returned an instance of R_WRKLD_TEAMSImpl.  This is because
                   * the call to this.getOldDelegatedTeam() temporarily disables
                   * the effective date filter and places the return data object in the transaction
                   * cache.  Then when the call to this.getDelegatedTeam() is made,
                   * the same R_WRKLD_TEAMSImpl instance is returned from the transaction
                   * cache without going to the database using SQL where the effective date filter
                   * is applied.  Therefore, if both lookups return the same object and if effective
                   * dating is enabled, we check if the parent is valid using the effective dating
                   * logic and set it to null if it is not.
                   */
                  parent = null ;
               }
               this.parentCustom(parent);         
               if ( !ParentKeyChanged )
               {
                  if ( parent != null )
                  {

                        if (parent.isNull("TEAM_NM"))
                        {
                           if(isOverwriteableByReplicate("DLGTD_TEAM_NM"))
                              this.setValue("DLGTD_TEAM_NM", null);
                        }
                        else
                        {
                           if(isOverwriteableByReplicate("DLGTD_TEAM_NM"))
                              this.setDLGTD_TEAM_NM(parent.getTEAM_NM());
                        }
                  }
                  else 
                  {
                        if(nullParentReplWhenNoParentFound("DLGTD_TEAM_NM"))
                        {
                           if(isOverwriteableByReplicate("DLGTD_TEAM_NM")) this.setValue("DLGTD_TEAM_NM", null);
                        }
                  }
               }
               else
               {
                  // Which means cascade
                  if ( parent != null )
                  {
                           if (parent.isNull("TEAM_NM"))
                           {
                              if(isOverwriteableByReplicate("DLGTD_TEAM_NM"))
                                 this.setValue("DLGTD_TEAM_NM", null);
                           }
                           else
                           {
                              if(isOverwriteableByReplicate("DLGTD_TEAM_NM"))
                                 this.setDLGTD_TEAM_NM(parent.getTEAM_NM());
                           }
                   }
                  else
                  {
                     if (!OrphanChildParenting)
                     {
                              if(nullParentReplWhenNoParentFound("DLGTD_TEAM_NM"))
                              {
                                 if(isOverwriteableByReplicate("DLGTD_TEAM_NM")) this.setValue("DLGTD_TEAM_NM", null);
                              }

                           if (nullParentForeignKeyWhenNoParentFound("DLGTD_TEAM_ID"))
                           {
                              this.setValue("DLGTD_TEAM_ID", null);
                           }
                     }
                  }
               }

               if ( isValidationRequired() )
               {

               if(!(R_WRKLD_TEAMSImpl.getBehaviors().get(AMSBEHAVIOR_NO_CHILD_PREVENT)))
               {
                  if ( parent == null )
                  {

                        // 
                        // If parent is a combo, issue message
                        // only if there is at least one record
                        // with a predefined subcombination.
                        //
                        boolean lboolIssueMsg = true;
                        if(R_WRKLD_TEAMSImpl.getBehaviors().get(AMSBEHAVIOR_COMBO))
                        {
                           SearchRequest lsr = this.buildAtLeastOneParentRequest( "R_WRKLD_TEAMS" );

                           if(lsr != null)
                           {
                              if( R_WRKLD_TEAMSImpl.getObjectCount( lsr, this.getSession() ) < 1 )
                              {
                                 lboolIssueMsg = false;
                              }
                           }
                        }

                        if(lboolIssueMsg)
                        {
                              raiseException("%c:A761,v:Decentralized Buyer Team ID,v:Workload Teams Table%","R_DEPT","DLGTD_TEAM_ID");
                           // AMS BEGIN : TIMELINE
                           if( (isUpdated()) &&
                               ((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                               (R_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                           {
                              getTimeline().raiseOrphanMessage( "R_WRKLD_TEAMS", "DLGTD_TEAM_ID",
                                    (new String[] {"DLGTD_TEAM_ID" }) ) ;
                           }
                           // AMS END : TIMELINE
                        }

                  }

               }

               if  (parent != null 
               &&  R_WRKLD_TEAMSImpl.getBehaviors().get(AMSBEHAVIOR_REVERSE_CHILD_PREVENT))
               {
                  //
                  // If an exclusion parent, add this failed parent to
                  // a list of failed exclusion parents.
                  //
                  if(R_WRKLD_TEAMSImpl.getType() == AMSPARENTTYPE_COMBO_EX)
                  {
                      if(this.mvFailedComboExcludeParents == null)
                      {
                          this.mvFailedComboExcludeParents = new Vector(5);
                      }
                      this.mvFailedComboExcludeParents.addElement("R_WRKLD_TEAMS");
                  }

                        raiseException("%c:A761,v:Decentralized Buyer Team ID,v:Workload Teams Table%","R_DEPT","DLGTD_TEAM_ID");
               }

               }
            }
            else
            {
               if ( isUpdated()  && ( 
               (isChanged("DLGTD_TEAM_ID"))
 ) &&
               (isNull("DLGTD_TEAM_ID") ))
               {
                  parent = this.getOldDelegatedTeam();
                  if (( parent != null ) && ( clientInitiatedUpdate() ))
                  {
                        if(isOverwriteableByReplicate("DLGTD_TEAM_NM")) this.forceOldValue("DLGTD_TEAM_NM", parent.getData("TEAM_NM"));
                  }
                        if(nullParentReplWhenNoParentFound("DLGTD_TEAM_NM"))
                        {
                           if(isOverwriteableByReplicate("DLGTD_TEAM_NM")) this.setValue("DLGTD_TEAM_NM", null);
                        }
               }
            }


    
         }
      finally { if (  tr != null ) tr.end( tr_id ); }
   }

   protected void parentCheckFor_BuyerTeam()
   {
      IVSTrace tr = null;  long tr_id = 0;
      if ( VSTrace.IS_ON ) {
         tr = VSTrace.get(); 
         tr_id = tr.beg(logger);
         tr.set(VST_CATEGORY,VST_RULE).set(VST_ACTION_NAME,"parentCheckFor_BuyerTeam").set(VST_OBJECT_NAME,"R_DEPT");
      }
      
      try {
       if(!isRelationshipEnabledfor_BuyerTeam(getSession()))
       {
           return;
       }
       
         R_WRKLD_TEAMSImpl   parent = null;
         R_WRKLD_TEAMSImpl   oldParent = null;
         boolean      ParentKeyChanged = false;
         boolean      OrphanChildParenting;

         ParentExtension loParent = (ParentExtension)myParents.get("R_WRKLD_TEAMS");
         if(loParent != null)
         {
            Enumeration lenumExceptions = loParent.getExceptions();
            if(lenumExceptions != null)
            {
               while(lenumExceptions.hasMoreElements())
               {
                  String lsAttribute = (String)lenumExceptions.nextElement();
                  Data   loData      = this.getData(lsAttribute);
                  if(isExceptionAttributeApplicableForRole(
                     "BuyerTeam",
                     "R_WRKLD_TEAMS",
                     lsAttribute,
                     loData.getString()))
                  {
                     if(loParent.isExceptional(
                        lsAttribute, 
                        ((loData.getString() == null) ? "" : loData.getString())))
                     {
                        return;
                     }
                  }
               }
            }
         }

         //
         // Is this an inclusion combo corresponding to an
         // already-failed exclusion combo?
         //
         if(this.mvFailedComboExcludeParents != null
         && R_WRKLD_TEAMSImpl.getType() == AMSPARENTTYPE_COMBO_IN
         && "R_WRKLD_TEAMS".startsWith("CVIN_"))
         {
             String ls = "CVEX_" + "R_WRKLD_TEAMS".substring(5);
             if(this.mvFailedComboExcludeParents.contains(ls))
             {
                 return;
             }
         }

 beforeParentCheck("R_WRKLD_TEAMS");

            if ((!R_WRKLD_TEAMSImpl.getBehaviors().get(AMSBEHAVIOR_ALLOW_NULL_KEY_PARENT_LOOKUPS)
            &&   (!isNull("TEAM_ID") )
            &&   (isInserted() || isUpdated()))
            ||  
                (R_WRKLD_TEAMSImpl.getBehaviors().get(AMSBEHAVIOR_ALLOW_NULL_KEY_PARENT_LOOKUPS )
            &&   (isInserted() || isUpdated())))
            {
               if (isOldNull("TEAM_ID") )
                  OrphanChildParenting = true;
               else
                  OrphanChildParenting = false;
               if ( isUpdated() && !OrphanChildParenting )

               {
                  // Argument value of false means get the old parent.
                  parent = this.getOldBuyerTeam();
                  oldParent = parent ;
                  if (( parent != null ) && ( clientInitiatedUpdate() ))
                  {
                        if(isOverwriteableByReplicate("TEAM_NM")) this.forceOldValue("TEAM_NM", parent.getData("TEAM_NM"));
                  }
                  // See if the parent is null.

                  if ( parent == null ) // No parent found
                     ParentKeyChanged = true;
                  else
                     ParentKeyChanged = false;
               }

               parent = this.getBuyerTeam();
               if ( ( oldParent != null ) && ( parent != null ) && ( oldParent == parent) &&
                    ( R_WRKLD_TEAMSImpl.isBehaviorEnabled( AMSBEHAVIOR_EFFECTIVE_DATED ) ) &&
                    ( !AMSUtil.isEffectiveDatedValid( getSession(), parent ) ) )
               {
                  /*
                   * It is necessary to make this check because the call to this.getBuyerTeam() 
                   * will not apply the effective date filter for its getObjectByKey call if the
                   * call to this.getOldBuyerTeam() used the same foreign key
                   * and returned an instance of R_WRKLD_TEAMSImpl.  This is because
                   * the call to this.getOldBuyerTeam() temporarily disables
                   * the effective date filter and places the return data object in the transaction
                   * cache.  Then when the call to this.getBuyerTeam() is made,
                   * the same R_WRKLD_TEAMSImpl instance is returned from the transaction
                   * cache without going to the database using SQL where the effective date filter
                   * is applied.  Therefore, if both lookups return the same object and if effective
                   * dating is enabled, we check if the parent is valid using the effective dating
                   * logic and set it to null if it is not.
                   */
                  parent = null ;
               }
               this.parentCustom(parent);         
               if ( !ParentKeyChanged )
               {
                  if ( parent != null )
                  {

                        if (parent.isNull("TEAM_NM"))
                        {
                           if(isOverwriteableByReplicate("TEAM_NM"))
                              this.setValue("TEAM_NM", null);
                        }
                        else
                        {
                           if(isOverwriteableByReplicate("TEAM_NM"))
                              this.setTEAM_NM(parent.getTEAM_NM());
                        }
                  }
                  else 
                  {
                        if(nullParentReplWhenNoParentFound("TEAM_NM"))
                        {
                           if(isOverwriteableByReplicate("TEAM_NM")) this.setValue("TEAM_NM", null);
                        }
                  }
               }
               else
               {
                  // Which means cascade
                  if ( parent != null )
                  {
                           if (parent.isNull("TEAM_NM"))
                           {
                              if(isOverwriteableByReplicate("TEAM_NM"))
                                 this.setValue("TEAM_NM", null);
                           }
                           else
                           {
                              if(isOverwriteableByReplicate("TEAM_NM"))
                                 this.setTEAM_NM(parent.getTEAM_NM());
                           }
                   }
                  else
                  {
                     if (!OrphanChildParenting)
                     {
                              if(nullParentReplWhenNoParentFound("TEAM_NM"))
                              {
                                 if(isOverwriteableByReplicate("TEAM_NM")) this.setValue("TEAM_NM", null);
                              }

                           if (nullParentForeignKeyWhenNoParentFound("TEAM_ID"))
                           {
                              this.setValue("TEAM_ID", null);
                           }
                     }
                  }
               }

               if ( isValidationRequired() )
               {

               if(!(R_WRKLD_TEAMSImpl.getBehaviors().get(AMSBEHAVIOR_NO_CHILD_PREVENT)))
               {
                  if ( parent == null )
                  {

                        // 
                        // If parent is a combo, issue message
                        // only if there is at least one record
                        // with a predefined subcombination.
                        //
                        boolean lboolIssueMsg = true;
                        if(R_WRKLD_TEAMSImpl.getBehaviors().get(AMSBEHAVIOR_COMBO))
                        {
                           SearchRequest lsr = this.buildAtLeastOneParentRequest( "R_WRKLD_TEAMS" );

                           if(lsr != null)
                           {
                              if( R_WRKLD_TEAMSImpl.getObjectCount( lsr, this.getSession() ) < 1 )
                              {
                                 lboolIssueMsg = false;
                              }
                           }
                        }

                        if(lboolIssueMsg)
                        {
                              raiseException("%c:A761,v:Team ID,v:Workload Teams Table%","R_DEPT","TEAM_ID");
                           // AMS BEGIN : TIMELINE
                           if( (isUpdated()) &&
                               ((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                               (R_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                           {
                              getTimeline().raiseOrphanMessage( "R_WRKLD_TEAMS", "TEAM_ID",
                                    (new String[] {"TEAM_ID" }) ) ;
                           }
                           // AMS END : TIMELINE
                        }

                  }

               }

               if  (parent != null 
               &&  R_WRKLD_TEAMSImpl.getBehaviors().get(AMSBEHAVIOR_REVERSE_CHILD_PREVENT))
               {
                  //
                  // If an exclusion parent, add this failed parent to
                  // a list of failed exclusion parents.
                  //
                  if(R_WRKLD_TEAMSImpl.getType() == AMSPARENTTYPE_COMBO_EX)
                  {
                      if(this.mvFailedComboExcludeParents == null)
                      {
                          this.mvFailedComboExcludeParents = new Vector(5);
                      }
                      this.mvFailedComboExcludeParents.addElement("R_WRKLD_TEAMS");
                  }

                        raiseException("%c:A761,v:Team ID,v:Workload Teams Table%","R_DEPT","TEAM_ID");
               }

               }
            }
            else
            {
               if ( isUpdated()  && ( 
               (isChanged("TEAM_ID"))
 ) &&
               (isNull("TEAM_ID") ))
               {
                  parent = this.getOldBuyerTeam();
                  if (( parent != null ) && ( clientInitiatedUpdate() ))
                  {
                        if(isOverwriteableByReplicate("TEAM_NM")) this.forceOldValue("TEAM_NM", parent.getData("TEAM_NM"));
                  }
                        if(nullParentReplWhenNoParentFound("TEAM_NM"))
                        {
                           if(isOverwriteableByReplicate("TEAM_NM")) this.setValue("TEAM_NM", null);
                        }
               }
            }


    
         }
      finally { if (  tr != null ) tr.end( tr_id ); }
   }

   protected void parentCheckFor_R_CNTAC28()
   {
      IVSTrace tr = null;  long tr_id = 0;
      if ( VSTrace.IS_ON ) {
         tr = VSTrace.get(); 
         tr_id = tr.beg(logger);
         tr.set(VST_CATEGORY,VST_RULE).set(VST_ACTION_NAME,"parentCheckFor_R_CNTAC28").set(VST_OBJECT_NAME,"R_DEPT");
      }
      
      try {
       if(!isRelationshipEnabledfor_R_CNTAC28(getSession()))
       {
           return;
       }
       
         R_CNTACImpl   parent = null;
         R_CNTACImpl   oldParent = null;
         boolean      ParentKeyChanged = false;
         boolean      OrphanChildParenting;

         ParentExtension loParent = (ParentExtension)myParents.get("R_CNTAC");
         if(loParent != null)
         {
            Enumeration lenumExceptions = loParent.getExceptions();
            if(lenumExceptions != null)
            {
               while(lenumExceptions.hasMoreElements())
               {
                  String lsAttribute = (String)lenumExceptions.nextElement();
                  Data   loData      = this.getData(lsAttribute);
                  if(isExceptionAttributeApplicableForRole(
                     "R_CNTAC28",
                     "R_CNTAC",
                     lsAttribute,
                     loData.getString()))
                  {
                     if(loParent.isExceptional(
                        lsAttribute, 
                        ((loData.getString() == null) ? "" : loData.getString())))
                     {
                        return;
                     }
                  }
               }
            }
         }

         //
         // Is this an inclusion combo corresponding to an
         // already-failed exclusion combo?
         //
         if(this.mvFailedComboExcludeParents != null
         && R_CNTACImpl.getType() == AMSPARENTTYPE_COMBO_IN
         && "R_CNTAC".startsWith("CVIN_"))
         {
             String ls = "CVEX_" + "R_CNTAC".substring(5);
             if(this.mvFailedComboExcludeParents.contains(ls))
             {
                 return;
             }
         }

 beforeParentCheck("R_CNTAC");

            if ((!R_CNTACImpl.getBehaviors().get(AMSBEHAVIOR_ALLOW_NULL_KEY_PARENT_LOOKUPS)
            &&   (!isNull("CNTAC_CD") )
            &&   (isInserted() || isUpdated()))
            ||  
                (R_CNTACImpl.getBehaviors().get(AMSBEHAVIOR_ALLOW_NULL_KEY_PARENT_LOOKUPS )
            &&   (isInserted() || isUpdated())))
            {
               if (isOldNull("CNTAC_CD") )
                  OrphanChildParenting = true;
               else
                  OrphanChildParenting = false;
               if ( isUpdated() && !OrphanChildParenting )

               {
                  // Argument value of false means get the old parent.
                  parent = this.getOldR_CNTAC28();
                  oldParent = parent ;
                  if (( parent != null ) && ( clientInitiatedUpdate() ))
                  {
                        if(isOverwriteableByReplicate("CNTAC_PH_NO")) this.forceOldValue("CNTAC_PH_NO", parent.getData("PH_NO"));
                        if(isOverwriteableByReplicate("CNTAC_PERSN")) this.forceOldValue("CNTAC_PERSN", parent.getData("CNTAC_PERSN"));
                        if(isOverwriteableByReplicate("CNTAC_PH_EXT")) this.forceOldValue("CNTAC_PH_EXT", parent.getData("PH_EXT"));
                        if(isOverwriteableByReplicate("CNTAC_EMAIL")) this.forceOldValue("CNTAC_EMAIL", parent.getData("EMAIL_AD"));
                  }
                  // See if the parent is null.

                  if ( parent == null ) // No parent found
                     ParentKeyChanged = true;
                  else
                     ParentKeyChanged = false;
               }

               parent = this.getR_CNTAC28();
               if ( ( oldParent != null ) && ( parent != null ) && ( oldParent == parent) &&
                    ( R_CNTACImpl.isBehaviorEnabled( AMSBEHAVIOR_EFFECTIVE_DATED ) ) &&
                    ( !AMSUtil.isEffectiveDatedValid( getSession(), parent ) ) )
               {
                  /*
                   * It is necessary to make this check because the call to this.getR_CNTAC28() 
                   * will not apply the effective date filter for its getObjectByKey call if the
                   * call to this.getOldR_CNTAC28() used the same foreign key
                   * and returned an instance of R_CNTACImpl.  This is because
                   * the call to this.getOldR_CNTAC28() temporarily disables
                   * the effective date filter and places the return data object in the transaction
                   * cache.  Then when the call to this.getR_CNTAC28() is made,
                   * the same R_CNTACImpl instance is returned from the transaction
                   * cache without going to the database using SQL where the effective date filter
                   * is applied.  Therefore, if both lookups return the same object and if effective
                   * dating is enabled, we check if the parent is valid using the effective dating
                   * logic and set it to null if it is not.
                   */
                  parent = null ;
               }
               this.parentCustom(parent);         
               if ( !ParentKeyChanged )
               {
                  if ( parent != null )
                  {

                        if (parent.isNull("PH_NO"))
                        {
                           if(isOverwriteableByReplicate("CNTAC_PH_NO"))
                              this.setValue("CNTAC_PH_NO", null);
                        }
                        else
                        {
                           if(isOverwriteableByReplicate("CNTAC_PH_NO"))
                              this.setCNTAC_PH_NO(parent.getPH_NO());
                        }

                        if (parent.isNull("CNTAC_PERSN"))
                        {
                           if(isOverwriteableByReplicate("CNTAC_PERSN"))
                              this.setValue("CNTAC_PERSN", null);
                        }
                        else
                        {
                           if(isOverwriteableByReplicate("CNTAC_PERSN"))
                              this.setCNTAC_PERSN(parent.getCNTAC_PERSN());
                        }

                        if (parent.isNull("PH_EXT"))
                        {
                           if(isOverwriteableByReplicate("CNTAC_PH_EXT"))
                              this.setValue("CNTAC_PH_EXT", null);
                        }
                        else
                        {
                           if(isOverwriteableByReplicate("CNTAC_PH_EXT"))
                              this.setCNTAC_PH_EXT(parent.getPH_EXT());
                        }

                        if (parent.isNull("EMAIL_AD"))
                        {
                           if(isOverwriteableByReplicate("CNTAC_EMAIL"))
                              this.setValue("CNTAC_EMAIL", null);
                        }
                        else
                        {
                           if(isOverwriteableByReplicate("CNTAC_EMAIL"))
                              this.setCNTAC_EMAIL(parent.getEMAIL_AD());
                        }
                  }
                  else 
                  {
                        if(nullParentReplWhenNoParentFound("CNTAC_PH_NO"))
                        {
                           if(isOverwriteableByReplicate("CNTAC_PH_NO")) this.setValue("CNTAC_PH_NO", null);
                        }
                        if(nullParentReplWhenNoParentFound("CNTAC_PERSN"))
                        {
                           if(isOverwriteableByReplicate("CNTAC_PERSN")) this.setValue("CNTAC_PERSN", null);
                        }
                        if(nullParentReplWhenNoParentFound("CNTAC_PH_EXT"))
                        {
                           if(isOverwriteableByReplicate("CNTAC_PH_EXT")) this.setValue("CNTAC_PH_EXT", null);
                        }
                        if(nullParentReplWhenNoParentFound("CNTAC_EMAIL"))
                        {
                           if(isOverwriteableByReplicate("CNTAC_EMAIL")) this.setValue("CNTAC_EMAIL", null);
                        }
                  }
               }
               else
               {
                  // Which means cascade
                  if ( parent != null )
                  {
                           if (parent.isNull("PH_NO"))
                           {
                              if(isOverwriteableByReplicate("CNTAC_PH_NO"))
                                 this.setValue("CNTAC_PH_NO", null);
                           }
                           else
                           {
                              if(isOverwriteableByReplicate("CNTAC_PH_NO"))
                                 this.setCNTAC_PH_NO(parent.getPH_NO());
                           }
                           if (parent.isNull("CNTAC_PERSN"))
                           {
                              if(isOverwriteableByReplicate("CNTAC_PERSN"))
                                 this.setValue("CNTAC_PERSN", null);
                           }
                           else
                           {
                              if(isOverwriteableByReplicate("CNTAC_PERSN"))
                                 this.setCNTAC_PERSN(parent.getCNTAC_PERSN());
                           }
                           if (parent.isNull("PH_EXT"))
                           {
                              if(isOverwriteableByReplicate("CNTAC_PH_EXT"))
                                 this.setValue("CNTAC_PH_EXT", null);
                           }
                           else
                           {
                              if(isOverwriteableByReplicate("CNTAC_PH_EXT"))
                                 this.setCNTAC_PH_EXT(parent.getPH_EXT());
                           }
                           if (parent.isNull("EMAIL_AD"))
                           {
                              if(isOverwriteableByReplicate("CNTAC_EMAIL"))
                                 this.setValue("CNTAC_EMAIL", null);
                           }
                           else
                           {
                              if(isOverwriteableByReplicate("CNTAC_EMAIL"))
                                 this.setCNTAC_EMAIL(parent.getEMAIL_AD());
                           }
                   }
                  else
                  {
                     if (!OrphanChildParenting)
                     {
                              if(nullParentReplWhenNoParentFound("CNTAC_PH_NO"))
                              {
                                 if(isOverwriteableByReplicate("CNTAC_PH_NO")) this.setValue("CNTAC_PH_NO", null);
                              }
                              if(nullParentReplWhenNoParentFound("CNTAC_PERSN"))
                              {
                                 if(isOverwriteableByReplicate("CNTAC_PERSN")) this.setValue("CNTAC_PERSN", null);
                              }
                              if(nullParentReplWhenNoParentFound("CNTAC_PH_EXT"))
                              {
                                 if(isOverwriteableByReplicate("CNTAC_PH_EXT")) this.setValue("CNTAC_PH_EXT", null);
                              }
                              if(nullParentReplWhenNoParentFound("CNTAC_EMAIL"))
                              {
                                 if(isOverwriteableByReplicate("CNTAC_EMAIL")) this.setValue("CNTAC_EMAIL", null);
                              }

                           if (nullParentForeignKeyWhenNoParentFound("CNTAC_CD"))
                           {
                              this.setValue("CNTAC_CD", null);
                           }
                     }
                  }
               }

               if ( isValidationRequired() )
               {

               if(!(R_CNTACImpl.getBehaviors().get(AMSBEHAVIOR_NO_CHILD_PREVENT)))
               {
                  if ( parent == null )
                  {

                        // 
                        // If parent is a combo, issue message
                        // only if there is at least one record
                        // with a predefined subcombination.
                        //
                        boolean lboolIssueMsg = true;
                        if(R_CNTACImpl.getBehaviors().get(AMSBEHAVIOR_COMBO))
                        {
                           SearchRequest lsr = this.buildAtLeastOneParentRequest( "R_CNTAC" );

                           if(lsr != null)
                           {
                              if( R_CNTACImpl.getObjectCount( lsr, this.getSession() ) < 1 )
                              {
                                 lboolIssueMsg = false;
                              }
                           }
                        }

                        if(lboolIssueMsg)
                        {
                              raiseException("%c:A761,v:Contact Code,v:Contact Table%","R_DEPT","CNTAC_CD");
                           // AMS BEGIN : TIMELINE
                           if( (isUpdated()) &&
                               ((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                               (R_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                           {
                              getTimeline().raiseOrphanMessage( "R_CNTAC", "CNTAC_CD",
                                    (new String[] {"CNTAC_CD" }) ) ;
                           }
                           // AMS END : TIMELINE
                        }

                  }

               }

               if  (parent != null 
               &&  R_CNTACImpl.getBehaviors().get(AMSBEHAVIOR_REVERSE_CHILD_PREVENT))
               {
                  //
                  // If an exclusion parent, add this failed parent to
                  // a list of failed exclusion parents.
                  //
                  if(R_CNTACImpl.getType() == AMSPARENTTYPE_COMBO_EX)
                  {
                      if(this.mvFailedComboExcludeParents == null)
                      {
                          this.mvFailedComboExcludeParents = new Vector(5);
                      }
                      this.mvFailedComboExcludeParents.addElement("R_CNTAC");
                  }

                        raiseException("%c:A761,v:Contact Code,v:Contact Table%","R_DEPT","CNTAC_CD");
               }

               }
            }
            else
            {
               if ( isUpdated()  && ( 
               (isChanged("CNTAC_CD"))
 ) &&
               (isNull("CNTAC_CD") ))
               {
                  parent = this.getOldR_CNTAC28();
                  if (( parent != null ) && ( clientInitiatedUpdate() ))
                  {
                        if(isOverwriteableByReplicate("CNTAC_PH_NO")) this.forceOldValue("CNTAC_PH_NO", parent.getData("PH_NO"));
                        if(isOverwriteableByReplicate("CNTAC_PERSN")) this.forceOldValue("CNTAC_PERSN", parent.getData("CNTAC_PERSN"));
                        if(isOverwriteableByReplicate("CNTAC_PH_EXT")) this.forceOldValue("CNTAC_PH_EXT", parent.getData("PH_EXT"));
                        if(isOverwriteableByReplicate("CNTAC_EMAIL")) this.forceOldValue("CNTAC_EMAIL", parent.getData("EMAIL_AD"));
                  }
                        if(nullParentReplWhenNoParentFound("CNTAC_PH_NO"))
                        {
                           if(isOverwriteableByReplicate("CNTAC_PH_NO")) this.setValue("CNTAC_PH_NO", null);
                        }
                        if(nullParentReplWhenNoParentFound("CNTAC_PERSN"))
                        {
                           if(isOverwriteableByReplicate("CNTAC_PERSN")) this.setValue("CNTAC_PERSN", null);
                        }
                        if(nullParentReplWhenNoParentFound("CNTAC_PH_EXT"))
                        {
                           if(isOverwriteableByReplicate("CNTAC_PH_EXT")) this.setValue("CNTAC_PH_EXT", null);
                        }
                        if(nullParentReplWhenNoParentFound("CNTAC_EMAIL"))
                        {
                           if(isOverwriteableByReplicate("CNTAC_EMAIL")) this.setValue("CNTAC_EMAIL", null);
                        }
               }
            }


    
         }
      finally { if (  tr != null ) tr.end( tr_id ); }
   }

   protected void parentCheckFor_DelegatedBuyer()
   {
      IVSTrace tr = null;  long tr_id = 0;
      if ( VSTrace.IS_ON ) {
         tr = VSTrace.get(); 
         tr_id = tr.beg(logger);
         tr.set(VST_CATEGORY,VST_RULE).set(VST_ACTION_NAME,"parentCheckFor_DelegatedBuyer").set(VST_OBJECT_NAME,"R_DEPT");
      }
      
      try {
       if(!isRelationshipEnabledfor_DelegatedBuyer(getSession()))
       {
           return;
       }
       
         R_BUYRImpl   parent = null;
         R_BUYRImpl   oldParent = null;
         boolean      ParentKeyChanged = false;
         boolean      OrphanChildParenting;

         ParentExtension loParent = (ParentExtension)myParents.get("R_BUYR");
         if(loParent != null)
         {
            Enumeration lenumExceptions = loParent.getExceptions();
            if(lenumExceptions != null)
            {
               while(lenumExceptions.hasMoreElements())
               {
                  String lsAttribute = (String)lenumExceptions.nextElement();
                  Data   loData      = this.getData(lsAttribute);
                  if(isExceptionAttributeApplicableForRole(
                     "DelegatedBuyer",
                     "R_BUYR",
                     lsAttribute,
                     loData.getString()))
                  {
                     if(loParent.isExceptional(
                        lsAttribute, 
                        ((loData.getString() == null) ? "" : loData.getString())))
                     {
                        return;
                     }
                  }
               }
            }
         }

         //
         // Is this an inclusion combo corresponding to an
         // already-failed exclusion combo?
         //
         if(this.mvFailedComboExcludeParents != null
         && R_BUYRImpl.getType() == AMSPARENTTYPE_COMBO_IN
         && "R_BUYR".startsWith("CVIN_"))
         {
             String ls = "CVEX_" + "R_BUYR".substring(5);
             if(this.mvFailedComboExcludeParents.contains(ls))
             {
                 return;
             }
         }

 beforeParentCheck("R_BUYR");

            if ((!R_BUYRImpl.getBehaviors().get(AMSBEHAVIOR_ALLOW_NULL_KEY_PARENT_LOOKUPS)
            &&   (!isNull("DLGTD_BUYR_ID") )
            &&   (isInserted() || isUpdated()))
            ||  
                (R_BUYRImpl.getBehaviors().get(AMSBEHAVIOR_ALLOW_NULL_KEY_PARENT_LOOKUPS )
            &&   (isInserted() || isUpdated())))
            {
               if (isOldNull("DLGTD_BUYR_ID") )
                  OrphanChildParenting = true;
               else
                  OrphanChildParenting = false;
               if ( isUpdated() && !OrphanChildParenting )

               {
                  // Argument value of false means get the old parent.
                  parent = this.getOldDelegatedBuyer();
                  oldParent = parent ;
                  if (( parent != null ) && ( clientInitiatedUpdate() ))
                  {
                        if(isOverwriteableByReplicate("DLGTD_BUYR_NM")) this.forceOldValue("DLGTD_BUYR_NM", parent.getData("BUYR_NM"));
                  }
                  // See if the parent is null.

                  if ( parent == null ) // No parent found
                     ParentKeyChanged = true;
                  else
                     ParentKeyChanged = false;
               }

               parent = this.getDelegatedBuyer();
               if ( ( oldParent != null ) && ( parent != null ) && ( oldParent == parent) &&
                    ( R_BUYRImpl.isBehaviorEnabled( AMSBEHAVIOR_EFFECTIVE_DATED ) ) &&
                    ( !AMSUtil.isEffectiveDatedValid( getSession(), parent ) ) )
               {
                  /*
                   * It is necessary to make this check because the call to this.getDelegatedBuyer() 
                   * will not apply the effective date filter for its getObjectByKey call if the
                   * call to this.getOldDelegatedBuyer() used the same foreign key
                   * and returned an instance of R_BUYRImpl.  This is because
                   * the call to this.getOldDelegatedBuyer() temporarily disables
                   * the effective date filter and places the return data object in the transaction
                   * cache.  Then when the call to this.getDelegatedBuyer() is made,
                   * the same R_BUYRImpl instance is returned from the transaction
                   * cache without going to the database using SQL where the effective date filter
                   * is applied.  Therefore, if both lookups return the same object and if effective
                   * dating is enabled, we check if the parent is valid using the effective dating
                   * logic and set it to null if it is not.
                   */
                  parent = null ;
               }
               this.parentCustom(parent);         
               if ( !ParentKeyChanged )
               {
                  if ( parent != null )
                  {

                        if (parent.isNull("BUYR_NM"))
                        {
                           if(isOverwriteableByReplicate("DLGTD_BUYR_NM"))
                              this.setValue("DLGTD_BUYR_NM", null);
                        }
                        else
                        {
                           if(isOverwriteableByReplicate("DLGTD_BUYR_NM"))
                              this.setDLGTD_BUYR_NM(parent.getBUYR_NM());
                        }
                  }
                  else 
                  {
                        if(nullParentReplWhenNoParentFound("DLGTD_BUYR_NM"))
                        {
                           if(isOverwriteableByReplicate("DLGTD_BUYR_NM")) this.setValue("DLGTD_BUYR_NM", null);
                        }
                  }
               }
               else
               {
                  // Which means cascade
                  if ( parent != null )
                  {
                           if (parent.isNull("BUYR_NM"))
                           {
                              if(isOverwriteableByReplicate("DLGTD_BUYR_NM"))
                                 this.setValue("DLGTD_BUYR_NM", null);
                           }
                           else
                           {
                              if(isOverwriteableByReplicate("DLGTD_BUYR_NM"))
                                 this.setDLGTD_BUYR_NM(parent.getBUYR_NM());
                           }
                   }
                  else
                  {
                     if (!OrphanChildParenting)
                     {
                              if(nullParentReplWhenNoParentFound("DLGTD_BUYR_NM"))
                              {
                                 if(isOverwriteableByReplicate("DLGTD_BUYR_NM")) this.setValue("DLGTD_BUYR_NM", null);
                              }

                           if (nullParentForeignKeyWhenNoParentFound("DLGTD_BUYR_ID"))
                           {
                              this.setValue("DLGTD_BUYR_ID", null);
                           }
                     }
                  }
               }

               if ( isValidationRequired() )
               {

               if(!(R_BUYRImpl.getBehaviors().get(AMSBEHAVIOR_NO_CHILD_PREVENT)))
               {
                  if ( parent == null )
                  {

                        // 
                        // If parent is a combo, issue message
                        // only if there is at least one record
                        // with a predefined subcombination.
                        //
                        boolean lboolIssueMsg = true;
                        if(R_BUYRImpl.getBehaviors().get(AMSBEHAVIOR_COMBO))
                        {
                           SearchRequest lsr = this.buildAtLeastOneParentRequest( "R_BUYR" );

                           if(lsr != null)
                           {
                              if( R_BUYRImpl.getObjectCount( lsr, this.getSession() ) < 1 )
                              {
                                 lboolIssueMsg = false;
                              }
                           }
                        }

                        if(lboolIssueMsg)
                        {
                              raiseException("%c:A761,v:Decentralized Buyer ID,v:Buyer Table%","R_DEPT","DLGTD_BUYR_ID");
                           // AMS BEGIN : TIMELINE
                           if( (isUpdated()) &&
                               ((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                               (R_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                           {
                              getTimeline().raiseOrphanMessage( "R_BUYR", "DLGTD_BUYR_ID",
                                    (new String[] {"DLGTD_BUYR_ID" }) ) ;
                           }
                           // AMS END : TIMELINE
                        }

                  }

               }

               if  (parent != null 
               &&  R_BUYRImpl.getBehaviors().get(AMSBEHAVIOR_REVERSE_CHILD_PREVENT))
               {
                  //
                  // If an exclusion parent, add this failed parent to
                  // a list of failed exclusion parents.
                  //
                  if(R_BUYRImpl.getType() == AMSPARENTTYPE_COMBO_EX)
                  {
                      if(this.mvFailedComboExcludeParents == null)
                      {
                          this.mvFailedComboExcludeParents = new Vector(5);
                      }
                      this.mvFailedComboExcludeParents.addElement("R_BUYR");
                  }

                        raiseException("%c:A761,v:Decentralized Buyer ID,v:Buyer Table%","R_DEPT","DLGTD_BUYR_ID");
               }

               }
            }
            else
            {
               if ( isUpdated()  && ( 
               (isChanged("DLGTD_BUYR_ID"))
 ) &&
               (isNull("DLGTD_BUYR_ID") ))
               {
                  parent = this.getOldDelegatedBuyer();
                  if (( parent != null ) && ( clientInitiatedUpdate() ))
                  {
                        if(isOverwriteableByReplicate("DLGTD_BUYR_NM")) this.forceOldValue("DLGTD_BUYR_NM", parent.getData("BUYR_NM"));
                  }
                        if(nullParentReplWhenNoParentFound("DLGTD_BUYR_NM"))
                        {
                           if(isOverwriteableByReplicate("DLGTD_BUYR_NM")) this.setValue("DLGTD_BUYR_NM", null);
                        }
               }
            }


    
         }
      finally { if (  tr != null ) tr.end( tr_id ); }
   }

   protected void parentCheckFor_Buyer()
   {
      IVSTrace tr = null;  long tr_id = 0;
      if ( VSTrace.IS_ON ) {
         tr = VSTrace.get(); 
         tr_id = tr.beg(logger);
         tr.set(VST_CATEGORY,VST_RULE).set(VST_ACTION_NAME,"parentCheckFor_Buyer").set(VST_OBJECT_NAME,"R_DEPT");
      }
      
      try {
       if(!isRelationshipEnabledfor_Buyer(getSession()))
       {
           return;
       }
       
         R_BUYRImpl   parent = null;
         R_BUYRImpl   oldParent = null;
         boolean      ParentKeyChanged = false;
         boolean      OrphanChildParenting;

         ParentExtension loParent = (ParentExtension)myParents.get("R_BUYR");
         if(loParent != null)
         {
            Enumeration lenumExceptions = loParent.getExceptions();
            if(lenumExceptions != null)
            {
               while(lenumExceptions.hasMoreElements())
               {
                  String lsAttribute = (String)lenumExceptions.nextElement();
                  Data   loData      = this.getData(lsAttribute);
                  if(isExceptionAttributeApplicableForRole(
                     "Buyer",
                     "R_BUYR",
                     lsAttribute,
                     loData.getString()))
                  {
                     if(loParent.isExceptional(
                        lsAttribute, 
                        ((loData.getString() == null) ? "" : loData.getString())))
                     {
                        return;
                     }
                  }
               }
            }
         }

         //
         // Is this an inclusion combo corresponding to an
         // already-failed exclusion combo?
         //
         if(this.mvFailedComboExcludeParents != null
         && R_BUYRImpl.getType() == AMSPARENTTYPE_COMBO_IN
         && "R_BUYR".startsWith("CVIN_"))
         {
             String ls = "CVEX_" + "R_BUYR".substring(5);
             if(this.mvFailedComboExcludeParents.contains(ls))
             {
                 return;
             }
         }

 beforeParentCheck("R_BUYR");

            if ((!R_BUYRImpl.getBehaviors().get(AMSBEHAVIOR_ALLOW_NULL_KEY_PARENT_LOOKUPS)
            &&   (!isNull("BUYR_ID") )
            &&   (isInserted() || isUpdated()))
            ||  
                (R_BUYRImpl.getBehaviors().get(AMSBEHAVIOR_ALLOW_NULL_KEY_PARENT_LOOKUPS )
            &&   (isInserted() || isUpdated())))
            {
               if (isOldNull("BUYR_ID") )
                  OrphanChildParenting = true;
               else
                  OrphanChildParenting = false;
               if ( isUpdated() && !OrphanChildParenting )

               {
                  // Argument value of false means get the old parent.
                  parent = this.getOldBuyer();
                  oldParent = parent ;
                  if (( parent != null ) && ( clientInitiatedUpdate() ))
                  {
                        if(isOverwriteableByReplicate("BUYR_NM")) this.forceOldValue("BUYR_NM", parent.getData("BUYR_NM"));
                  }
                  // See if the parent is null.

                  if ( parent == null ) // No parent found
                     ParentKeyChanged = true;
                  else
                     ParentKeyChanged = false;
               }

               parent = this.getBuyer();
               if ( ( oldParent != null ) && ( parent != null ) && ( oldParent == parent) &&
                    ( R_BUYRImpl.isBehaviorEnabled( AMSBEHAVIOR_EFFECTIVE_DATED ) ) &&
                    ( !AMSUtil.isEffectiveDatedValid( getSession(), parent ) ) )
               {
                  /*
                   * It is necessary to make this check because the call to this.getBuyer() 
                   * will not apply the effective date filter for its getObjectByKey call if the
                   * call to this.getOldBuyer() used the same foreign key
                   * and returned an instance of R_BUYRImpl.  This is because
                   * the call to this.getOldBuyer() temporarily disables
                   * the effective date filter and places the return data object in the transaction
                   * cache.  Then when the call to this.getBuyer() is made,
                   * the same R_BUYRImpl instance is returned from the transaction
                   * cache without going to the database using SQL where the effective date filter
                   * is applied.  Therefore, if both lookups return the same object and if effective
                   * dating is enabled, we check if the parent is valid using the effective dating
                   * logic and set it to null if it is not.
                   */
                  parent = null ;
               }
               this.parentCustom(parent);         
               if ( !ParentKeyChanged )
               {
                  if ( parent != null )
                  {

                        if (parent.isNull("BUYR_NM"))
                        {
                           if(isOverwriteableByReplicate("BUYR_NM"))
                              this.setValue("BUYR_NM", null);
                        }
                        else
                        {
                           if(isOverwriteableByReplicate("BUYR_NM"))
                              this.setBUYR_NM(parent.getBUYR_NM());
                        }
                  }
                  else 
                  {
                        if(nullParentReplWhenNoParentFound("BUYR_NM"))
                        {
                           if(isOverwriteableByReplicate("BUYR_NM")) this.setValue("BUYR_NM", null);
                        }
                  }
               }
               else
               {
                  // Which means cascade
                  if ( parent != null )
                  {
                           if (parent.isNull("BUYR_NM"))
                           {
                              if(isOverwriteableByReplicate("BUYR_NM"))
                                 this.setValue("BUYR_NM", null);
                           }
                           else
                           {
                              if(isOverwriteableByReplicate("BUYR_NM"))
                                 this.setBUYR_NM(parent.getBUYR_NM());
                           }
                   }
                  else
                  {
                     if (!OrphanChildParenting)
                     {
                              if(nullParentReplWhenNoParentFound("BUYR_NM"))
                              {
                                 if(isOverwriteableByReplicate("BUYR_NM")) this.setValue("BUYR_NM", null);
                              }

                           if (nullParentForeignKeyWhenNoParentFound("BUYR_ID"))
                           {
                              this.setValue("BUYR_ID", null);
                           }
                     }
                  }
               }

               if ( isValidationRequired() )
               {

               if(!(R_BUYRImpl.getBehaviors().get(AMSBEHAVIOR_NO_CHILD_PREVENT)))
               {
                  if ( parent == null )
                  {

                        // 
                        // If parent is a combo, issue message
                        // only if there is at least one record
                        // with a predefined subcombination.
                        //
                        boolean lboolIssueMsg = true;
                        if(R_BUYRImpl.getBehaviors().get(AMSBEHAVIOR_COMBO))
                        {
                           SearchRequest lsr = this.buildAtLeastOneParentRequest( "R_BUYR" );

                           if(lsr != null)
                           {
                              if( R_BUYRImpl.getObjectCount( lsr, this.getSession() ) < 1 )
                              {
                                 lboolIssueMsg = false;
                              }
                           }
                        }

                        if(lboolIssueMsg)
                        {
                              raiseException("%c:A761,v:Buyer,v:Buyer Table%","R_DEPT","BUYR_ID");
                           // AMS BEGIN : TIMELINE
                           if( (isUpdated()) &&
                               ((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                               (R_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                           {
                              getTimeline().raiseOrphanMessage( "R_BUYR", "BUYR_ID",
                                    (new String[] {"BUYR_ID" }) ) ;
                           }
                           // AMS END : TIMELINE
                        }

                  }

               }

               if  (parent != null 
               &&  R_BUYRImpl.getBehaviors().get(AMSBEHAVIOR_REVERSE_CHILD_PREVENT))
               {
                  //
                  // If an exclusion parent, add this failed parent to
                  // a list of failed exclusion parents.
                  //
                  if(R_BUYRImpl.getType() == AMSPARENTTYPE_COMBO_EX)
                  {
                      if(this.mvFailedComboExcludeParents == null)
                      {
                          this.mvFailedComboExcludeParents = new Vector(5);
                      }
                      this.mvFailedComboExcludeParents.addElement("R_BUYR");
                  }

                        raiseException("%c:A761,v:Buyer,v:Buyer Table%","R_DEPT","BUYR_ID");
               }

               }
            }
            else
            {
               if ( isUpdated()  && ( 
               (isChanged("BUYR_ID"))
 ) &&
               (isNull("BUYR_ID") ))
               {
                  parent = this.getOldBuyer();
                  if (( parent != null ) && ( clientInitiatedUpdate() ))
                  {
                        if(isOverwriteableByReplicate("BUYR_NM")) this.forceOldValue("BUYR_NM", parent.getData("BUYR_NM"));
                  }
                        if(nullParentReplWhenNoParentFound("BUYR_NM"))
                        {
                           if(isOverwriteableByReplicate("BUYR_NM")) this.setValue("BUYR_NM", null);
                        }
               }
            }


    
         }
      finally { if (  tr != null ) tr.end( tr_id ); }
   }

   protected void parentCheckFor_RdeptToRtrvlPol()
   {
      IVSTrace tr = null;  long tr_id = 0;
      if ( VSTrace.IS_ON ) {
         tr = VSTrace.get(); 
         tr_id = tr.beg(logger);
         tr.set(VST_CATEGORY,VST_RULE).set(VST_ACTION_NAME,"parentCheckFor_RdeptToRtrvlPol").set(VST_OBJECT_NAME,"R_DEPT");
      }
      
      try {
       if(!isRelationshipEnabledfor_RdeptToRtrvlPol(getSession()))
       {
           return;
       }
       
         R_TRVL_POLImpl   parent = null;
         R_TRVL_POLImpl   oldParent = null;
         boolean      ParentKeyChanged = false;
         boolean      OrphanChildParenting;

         ParentExtension loParent = (ParentExtension)myParents.get("R_TRVL_POL");
         if(loParent != null)
         {
            Enumeration lenumExceptions = loParent.getExceptions();
            if(lenumExceptions != null)
            {
               while(lenumExceptions.hasMoreElements())
               {
                  String lsAttribute = (String)lenumExceptions.nextElement();
                  Data   loData      = this.getData(lsAttribute);
                  if(isExceptionAttributeApplicableForRole(
                     "RdeptToRtrvlPol",
                     "R_TRVL_POL",
                     lsAttribute,
                     loData.getString()))
                  {
                     if(loParent.isExceptional(
                        lsAttribute, 
                        ((loData.getString() == null) ? "" : loData.getString())))
                     {
                        return;
                     }
                  }
               }
            }
         }

         //
         // Is this an inclusion combo corresponding to an
         // already-failed exclusion combo?
         //
         if(this.mvFailedComboExcludeParents != null
         && R_TRVL_POLImpl.getType() == AMSPARENTTYPE_COMBO_IN
         && "R_TRVL_POL".startsWith("CVIN_"))
         {
             String ls = "CVEX_" + "R_TRVL_POL".substring(5);
             if(this.mvFailedComboExcludeParents.contains(ls))
             {
                 return;
             }
         }

 beforeParentCheck("R_TRVL_POL");

            if ((!R_TRVL_POLImpl.getBehaviors().get(AMSBEHAVIOR_ALLOW_NULL_KEY_PARENT_LOOKUPS)
            &&   (!isNull("TRVL_POL") )
            &&   (isInserted() || isUpdated()))
            ||  
                (R_TRVL_POLImpl.getBehaviors().get(AMSBEHAVIOR_ALLOW_NULL_KEY_PARENT_LOOKUPS )
            &&   (isInserted() || isUpdated())))
            {
               parent = this.getRdeptToRtrvlPol();


               if ( isValidationRequired() )
               {

               this.parentCustom(parent);         
               if(!(R_TRVL_POLImpl.getBehaviors().get(AMSBEHAVIOR_NO_CHILD_PREVENT)))
               {
                  if ( parent == null )
                  {

                        // If parent is a combo, issue message
                        // only if there is at least one record
                        // with a predefined subcombination.
                        boolean lboolIssueMsg = true;
                        if(R_TRVL_POLImpl.getBehaviors().get(AMSBEHAVIOR_COMBO))
                        {
                           SearchRequest lsr = this.buildAtLeastOneParentRequest( "R_TRVL_POL" );

                           if(lsr != null)
                           {
                              if( R_TRVL_POLImpl.getObjectCount( lsr, this.getSession() ) < 1 )
                              {
                                 lboolIssueMsg = false;
                              }
                           }
                        }
                        if(lboolIssueMsg)
                        {
                              raiseException("%c:A761,v:[b:R_DEPT/TRVL_POL],v:Travel Policy table%","R_DEPT","TRVL_POL");
                        }

                  }
               }

               if  (parent != null 
               &&  R_TRVL_POLImpl.getBehaviors().get(AMSBEHAVIOR_REVERSE_CHILD_PREVENT))
               {
                  //
                  // If an exclusion parent, add this failed parent to
                  // a list of failed exclusion parents.
                  //
                  if(R_TRVL_POLImpl.getType() == AMSPARENTTYPE_COMBO_EX)
                  {
                      if(this.mvFailedComboExcludeParents == null)
                      {
                          this.mvFailedComboExcludeParents = new Vector(5);
                      }
                      this.mvFailedComboExcludeParents.addElement("R_TRVL_POL");
                  }

                        raiseException("%c:A761,v:[b:R_DEPT/TRVL_POL],v:Travel Policy table%","R_DEPT","TRVL_POL");
               }

               }

            }
    
         }
      finally { if (  tr != null ) tr.end( tr_id ); }
   }

   protected void parentCheckFor_ContactToDepartment()
   {
      IVSTrace tr = null;  long tr_id = 0;
      if ( VSTrace.IS_ON ) {
         tr = VSTrace.get(); 
         tr_id = tr.beg(logger);
         tr.set(VST_CATEGORY,VST_RULE).set(VST_ACTION_NAME,"parentCheckFor_ContactToDepartment").set(VST_OBJECT_NAME,"R_DEPT");
      }
      
      try {
       if(!isRelationshipEnabledfor_ContactToDepartment(getSession()))
       {
           return;
       }
       
         R_CNTACImpl   parent = null;
         R_CNTACImpl   oldParent = null;
         boolean      ParentKeyChanged = false;
         boolean      OrphanChildParenting;

         ParentExtension loParent = (ParentExtension)myParents.get("R_CNTAC");
         if(loParent != null)
         {
            Enumeration lenumExceptions = loParent.getExceptions();
            if(lenumExceptions != null)
            {
               while(lenumExceptions.hasMoreElements())
               {
                  String lsAttribute = (String)lenumExceptions.nextElement();
                  Data   loData      = this.getData(lsAttribute);
                  if(isExceptionAttributeApplicableForRole(
                     "ContactToDepartment",
                     "R_CNTAC",
                     lsAttribute,
                     loData.getString()))
                  {
                     if(loParent.isExceptional(
                        lsAttribute, 
                        ((loData.getString() == null) ? "" : loData.getString())))
                     {
                        return;
                     }
                  }
               }
            }
         }

         //
         // Is this an inclusion combo corresponding to an
         // already-failed exclusion combo?
         //
         if(this.mvFailedComboExcludeParents != null
         && R_CNTACImpl.getType() == AMSPARENTTYPE_COMBO_IN
         && "R_CNTAC".startsWith("CVIN_"))
         {
             String ls = "CVEX_" + "R_CNTAC".substring(5);
             if(this.mvFailedComboExcludeParents.contains(ls))
             {
                 return;
             }
         }

 beforeParentCheck("R_CNTAC");

            if ((!R_CNTACImpl.getBehaviors().get(AMSBEHAVIOR_ALLOW_NULL_KEY_PARENT_LOOKUPS)
            &&   (!isNull("DISB_CNTAC_CD") )
            &&   (isInserted() || isUpdated()))
            ||  
                (R_CNTACImpl.getBehaviors().get(AMSBEHAVIOR_ALLOW_NULL_KEY_PARENT_LOOKUPS )
            &&   (isInserted() || isUpdated())))
            {
               if (isOldNull("DISB_CNTAC_CD") )
                  OrphanChildParenting = true;
               else
                  OrphanChildParenting = false;
               if ( isUpdated() && !OrphanChildParenting )

               {
                  // Argument value of false means get the old parent.
                  parent = this.getOldContactToDepartment();
                  oldParent = parent ;
                  if (( parent != null ) && ( clientInitiatedUpdate() ))
                  {
                        if(isOverwriteableByReplicate("DISB_CNTAC_NM")) this.forceOldValue("DISB_CNTAC_NM", parent.getData("CNTAC_PERSN"));
                  }
                  // See if the parent is null.

                  if ( parent == null ) // No parent found
                     ParentKeyChanged = true;
                  else
                     ParentKeyChanged = false;
               }

               parent = this.getContactToDepartment();
               if ( ( oldParent != null ) && ( parent != null ) && ( oldParent == parent) &&
                    ( R_CNTACImpl.isBehaviorEnabled( AMSBEHAVIOR_EFFECTIVE_DATED ) ) &&
                    ( !AMSUtil.isEffectiveDatedValid( getSession(), parent ) ) )
               {
                  /*
                   * It is necessary to make this check because the call to this.getContactToDepartment() 
                   * will not apply the effective date filter for its getObjectByKey call if the
                   * call to this.getOldContactToDepartment() used the same foreign key
                   * and returned an instance of R_CNTACImpl.  This is because
                   * the call to this.getOldContactToDepartment() temporarily disables
                   * the effective date filter and places the return data object in the transaction
                   * cache.  Then when the call to this.getContactToDepartment() is made,
                   * the same R_CNTACImpl instance is returned from the transaction
                   * cache without going to the database using SQL where the effective date filter
                   * is applied.  Therefore, if both lookups return the same object and if effective
                   * dating is enabled, we check if the parent is valid using the effective dating
                   * logic and set it to null if it is not.
                   */
                  parent = null ;
               }
               this.parentCustom(parent);         
               if ( !ParentKeyChanged )
               {
                  if ( parent != null )
                  {

                        if (parent.isNull("CNTAC_PERSN"))
                        {
                           if(isOverwriteableByReplicate("DISB_CNTAC_NM"))
                              this.setValue("DISB_CNTAC_NM", null);
                        }
                        else
                        {
                           if(isOverwriteableByReplicate("DISB_CNTAC_NM"))
                              this.setDISB_CNTAC_NM(parent.getCNTAC_PERSN());
                        }
                  }
                  else 
                  {
                        if(nullParentReplWhenNoParentFound("DISB_CNTAC_NM"))
                        {
                           if(isOverwriteableByReplicate("DISB_CNTAC_NM")) this.setValue("DISB_CNTAC_NM", null);
                        }
                  }
               }
               else
               {
                  // Which means cascade
                  if ( parent != null )
                  {
                           if (parent.isNull("CNTAC_PERSN"))
                           {
                              if(isOverwriteableByReplicate("DISB_CNTAC_NM"))
                                 this.setValue("DISB_CNTAC_NM", null);
                           }
                           else
                           {
                              if(isOverwriteableByReplicate("DISB_CNTAC_NM"))
                                 this.setDISB_CNTAC_NM(parent.getCNTAC_PERSN());
                           }
                   }
                  else
                  {
                     if (!OrphanChildParenting)
                     {
                              if(nullParentReplWhenNoParentFound("DISB_CNTAC_NM"))
                              {
                                 if(isOverwriteableByReplicate("DISB_CNTAC_NM")) this.setValue("DISB_CNTAC_NM", null);
                              }

                           if (nullParentForeignKeyWhenNoParentFound("DISB_CNTAC_CD"))
                           {
                              this.setValue("DISB_CNTAC_CD", null);
                           }
                     }
                  }
               }

               if ( isValidationRequired() )
               {

               if(!(R_CNTACImpl.getBehaviors().get(AMSBEHAVIOR_NO_CHILD_PREVENT)))
               {
                  if ( parent == null )
                  {

                        // 
                        // If parent is a combo, issue message
                        // only if there is at least one record
                        // with a predefined subcombination.
                        //
                        boolean lboolIssueMsg = true;
                        if(R_CNTACImpl.getBehaviors().get(AMSBEHAVIOR_COMBO))
                        {
                           SearchRequest lsr = this.buildAtLeastOneParentRequest( "R_CNTAC" );

                           if(lsr != null)
                           {
                              if( R_CNTACImpl.getObjectCount( lsr, this.getSession() ) < 1 )
                              {
                                 lboolIssueMsg = false;
                              }
                           }
                        }

                        if(lboolIssueMsg)
                        {
                              raiseException("%c:A761,v:Disbursement Contact Code,v:Contact Table%","R_DEPT","DISB_CNTAC_CD");
                           // AMS BEGIN : TIMELINE
                           if( (isUpdated()) &&
                               ((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                               (R_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                           {
                              getTimeline().raiseOrphanMessage( "R_CNTAC", "DISB_CNTAC_CD",
                                    (new String[] {"DISB_CNTAC_CD" }) ) ;
                           }
                           // AMS END : TIMELINE
                        }

                  }

               }

               if  (parent != null 
               &&  R_CNTACImpl.getBehaviors().get(AMSBEHAVIOR_REVERSE_CHILD_PREVENT))
               {
                  //
                  // If an exclusion parent, add this failed parent to
                  // a list of failed exclusion parents.
                  //
                  if(R_CNTACImpl.getType() == AMSPARENTTYPE_COMBO_EX)
                  {
                      if(this.mvFailedComboExcludeParents == null)
                      {
                          this.mvFailedComboExcludeParents = new Vector(5);
                      }
                      this.mvFailedComboExcludeParents.addElement("R_CNTAC");
                  }

                        raiseException("%c:A761,v:Disbursement Contact Code,v:Contact Table%","R_DEPT","DISB_CNTAC_CD");
               }

               }
            }
            else
            {
               if ( isUpdated()  && ( 
               (isChanged("DISB_CNTAC_CD"))
 ) &&
               (isNull("DISB_CNTAC_CD") ))
               {
                  parent = this.getOldContactToDepartment();
                  if (( parent != null ) && ( clientInitiatedUpdate() ))
                  {
                        if(isOverwriteableByReplicate("DISB_CNTAC_NM")) this.forceOldValue("DISB_CNTAC_NM", parent.getData("CNTAC_PERSN"));
                  }
                        if(nullParentReplWhenNoParentFound("DISB_CNTAC_NM"))
                        {
                           if(isOverwriteableByReplicate("DISB_CNTAC_NM")) this.setValue("DISB_CNTAC_NM", null);
                        }
               }
            }


    
         }
      finally { if (  tr != null ) tr.end( tr_id ); }
   }



   private void parentCustom( AMSDataObject parent )
   {
      if(parent == null)
      {
         return;
      }

      // 
      // If the child is an accounting line and the parent is
      // an inference, then replicate all same-named non-key
      // from the inference to the accounting line. 
      // 

      // Is parent inference         and child accounting line?
      // Or parent required elements and child accounting line?

      if((myBehavior.get(AMSBEHAVIOR_CHILD_OF_INFERENCE)
      &&  parent.getBehaviorsNotStatic().get(AMSBEHAVIOR_INFERENCE)
      &&  isInferenceRequired())
      || (myBehavior.get(AMSBEHAVIOR_CHILD_OF_REQUIRED_ELEMENTS)
      &&  parent.getBehaviorsNotStatic().get(AMSBEHAVIOR_REQUIRED_ELEMENTS)))
      {
         // Load parent/child VSMetaQuery, get column counts
         VSMetaQuery mqParent = parent.getMetaQueryNotStatic();
         VSMetaQuery mqChild  = getMetaQuery();
         int parentColCount   = mqParent.getColumnCount();
         int childColCount    = mqChild.getColumnCount();
         VSMetaColumn mcParent = null;
         VSMetaColumn mcChild  = null;

         // Loop through parent's attributes looking for nonkeys.
         for(int i = 1; i <= parentColCount; i++)
         {
            // Get the name of the current parent attribute
            mcParent = mqParent.getMetaColumn(i);
            String sCurrentAttribute = mcParent.getName();
   
            // Is it a nonkey?
            if(!mcParent.isUniqueKeyColumn())
            {
               // is there a same-named attribute on the child?
               mcChild = mqChild.getMetaColumn(mcParent.getName());
               if(mcChild != null)
               {
                  // Get the Data object from the source attribute
                  Data dataFrom = parent.getData(sCurrentAttribute);
                  // Get the Data object from the destination attribute
                  Data dataTo   = getData(sCurrentAttribute);
                  // Do inference
                  if(parent.getBehaviorsNotStatic().get(AMSDataObject.AMSBEHAVIOR_INFERENCE))
                  {
                     String sCurrentValue = dataTo.getString();
                     if(sCurrentValue == null) sCurrentValue = "";
                     if(sCurrentValue.trim().length() == 0
                     || parent.getBehaviorsNotStatic().get(AMSDataObject.AMSBEHAVIOR_INFERENCE_WITH_POWER))
                     {
                        dataTo.setData(dataFrom);
                        dataTo.setInitialized(true);
                        if(AMS_DEBUG)addTrace("INFER just inferred", dataFrom + " ",Session.INFO_EVENT);
                     }
                     else
                     {
                        if(AMS_DEBUG)addTrace("INFER decided not to infer on top of existing non-blank value", dataTo + "",Session.INFO_EVENT);
                     }
                  }
                  // Do required element
                  else
                  {
                     String sRule      = dataFrom.getString();
                     String sTarget    = dataTo.getString();
                     String sCaption   = dataTo.getMetaColumn().getCaption().trim();
                     if(sRule   == null)        sRule   = "";
                     if(sTarget == null)        sTarget = "";
                     if(sCaption.length() == 0) sCaption = sCurrentAttribute;
                     char cRule        = (  sRule.trim()).length() > 0 ? sRule.charAt(0) : AMSDataObject.AMSREQUIREDRULE_DONTCARE;
                     boolean bHasValue = (sTarget.trim()).length() > 0; 
                     switch(cRule)
                     {
                        case AMSDataObject.AMSREQUIREDRULE_PROHIBITED:
                           if(AMS_DEBUG)addTrace("RE: in prohibit case", "no detail", Session.INFO_EVENT);
                           if(bHasValue) raiseException( sCaption + " is prohibited.","R_DEPT",sCurrentAttribute );
                           break;
                        case AMSDataObject.AMSREQUIREDRULE_REQUIRED:
                           if(AMS_DEBUG)addTrace("RE: in required case", "no detail", Session.INFO_EVENT);
                           if(!bHasValue) raiseException( sCaption + " is required.","R_DEPT",sCurrentAttribute  );
                           break;
                        default:
                           if(AMS_DEBUG)addTrace("RE: in don't care case", "no detail", Session.INFO_EVENT);
                           break;
                     }   
                  }
               }
            } 
         }
      }

      //
      // Custom replicates
      //
      ParentExtension lpeParent = (ParentExtension)this.myParents.get(parent.getComponentName());
      if(lpeParent != null)
      {
         Enumeration lenumReplicates = lpeParent.getReplicates();
         if(lenumReplicates != null)
         {
            AttributePair lapCurrent;
            while(lenumReplicates.hasMoreElements())
            {
               lapCurrent = (AttributePair)lenumReplicates.nextElement();
               if(isOverwriteableByReplicate( lapCurrent.getAttribute2() ))
               {
                  Data loFrom = parent.getData(lapCurrent.getAttribute1());
                  Data loTo   = this.  getData(lapCurrent.getAttribute2());
                  loTo.setData(loFrom);
                  loTo.setInitialized(true);
               }
            }
         }
      }
   }


   protected void childCascadeFor_DeptCAToARRADocOngoing()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptCAToARRADocOngoing(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (ARRA_DOC_ONGOINGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:ARRA Document Ongoing record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptCAToARRADocOngoing())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptCAToARRADocOngoing");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptCAToARRADocOngoing();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (ARRA_DOC_ONGOINGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:ARRA Document Ongoing record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        ARRA_DOC_ONGOINGBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (ARRA_DOC_ONGOINGBaseImpl)children.nextElement();
                           child.setCA_DEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("CA_DEPT_NM").setValue(null);
                                 child.getData("CA_DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("CA_DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("CA_DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setCA_DEPT_NM(this.getDEPT_NM());
                                    child.getData("CA_DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToCAMMjrProgDoc()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToCAMMjrProgDoc(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (CAM_DOC_MJRPROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:CAM Document [b:CAM_DOC_MJRPROG/MJR_PROG_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToCAMMjrProgDoc())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToCAMMjrProgDoc");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToCAMMjrProgDoc();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (CAM_DOC_MJRPROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:CAM Document [b:CAM_DOC_MJRPROG/MJR_PROG_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        CAM_DOC_MJRPROGBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (CAM_DOC_MJRPROGBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToCASMjrProgDoc()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToCASMjrProgDoc(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (CAS_DOC_MJRPROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:CAS Document [b:CAS_DOC_MJRPROG/MJR_PROG_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToCASMjrProgDoc())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToCASMjrProgDoc");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToCASMjrProgDoc();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (CAS_DOC_MJRPROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:CAS Document [b:CAS_DOC_MJRPROG/MJR_PROG_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        CAS_DOC_MJRPROGBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (CAS_DOC_MJRPROGBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_CVEX_FUND_DEPTs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldCVEX_FUND_DEPTs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (CVEX_FUND_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Invalid [b:CVEX_FUND_DEPT/FUND_CD] [b:CVEX_FUND_DEPT/DEPT_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_CVEX_FUND_DEPTs())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : CVEX_FUND_DEPTs");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldCVEX_FUND_DEPTs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (CVEX_FUND_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Invalid [b:CVEX_FUND_DEPT/FUND_CD] [b:CVEX_FUND_DEPT/DEPT_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        CVEX_FUND_DEPTBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (CVEX_FUND_DEPTBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_CVIN_FUND_DEPTs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldCVIN_FUND_DEPTs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (CVIN_FUND_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Valid [b:CVIN_FUND_DEPT/FUND_CD] [b:CVIN_FUND_DEPT/DEPT_CD] Combination record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_CVIN_FUND_DEPTs())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : CVIN_FUND_DEPTs");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldCVIN_FUND_DEPTs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (CVIN_FUND_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Valid [b:CVIN_FUND_DEPT/FUND_CD] [b:CVIN_FUND_DEPT/DEPT_CD] Combination record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        CVIN_FUND_DEPTBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (CVIN_FUND_DEPTBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToCvinStru44L3Req()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToCvinStru44L3Req(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (CVIN_STRU44L3_REQImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Budget 44 Level 3 Requirements record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToCvinStru44L3Req();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (CVIN_STRU44L3_REQImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Budget 44 Level 3 Requirements record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToCvinStru45L3Req()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToCvinStru45L3Req(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (CVIN_STRU45L3_REQImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Budget 45 Level 3 Requirements record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToCvinStru45L3Req())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToCvinStru45L3Req");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToCvinStru45L3Req();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (CVIN_STRU45L3_REQImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Budget 45 Level 3 Requirements record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        CVIN_STRU45L3_REQBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (CVIN_STRU45L3_REQBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToUnitProg()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToUnitProg(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (CVIN_UNIT_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Valid [b:CVIN_UNIT_PROG/UNIT_CD] [b:CVIN_UNIT_PROG/PROG_CD] Combination record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToUnitProg())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToUnitProg");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToUnitProg();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (CVIN_UNIT_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Valid [b:CVIN_UNIT_PROG/UNIT_CD] [b:CVIN_UNIT_PROG/PROG_CD] Combination record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        CVIN_UNIT_PROGBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (CVIN_UNIT_PROGBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DOC_COAs28()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("ACT_FL")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDOC_COAs28(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (DOC_COAImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Document Chart of Accounts record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DOC_COAs28())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DOC_COAs28");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDOC_COAs28();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (DOC_COAImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Document Chart of Accounts record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        DOC_COABaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (DOC_COABaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("ACT_FL"))
                              {
                                 child.getData("DEPT_ACT_FL").setValue(null);
                                 child.getData("DEPT_ACT_FL").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("ACT_FL") && !child.getData("DEPT_ACT_FL").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_ACT_FL").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_ACT_FL(this.getACT_FL());
                                    child.getData("DEPT_ACT_FL").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptDocIntCoa()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("ACT_FL")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptDocIntCoa(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (DOC_INT_COAImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:DOC_INT_COA/IG_DEPT_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptDocIntCoa())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptDocIntCoa");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptDocIntCoa();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (DOC_INT_COAImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v: [b:DOC_INT_COA/IG_DEPT_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        DOC_INT_COABaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (DOC_INT_COABaseImpl)children.nextElement();
                           child.setIG_DEPT_CD(this.getDEPT_CD());
                              if (isNull("ACT_FL"))
                              {
                                 child.getData("IG_DEPT_ACT_FL").setValue(null);
                                 child.getData("IG_DEPT_ACT_FL").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("ACT_FL") && !child.getData("IG_DEPT_ACT_FL").getMetaColumn().isVirtual())
                                 {
                                    child.getData("IG_DEPT_ACT_FL").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setIG_DEPT_ACT_FL(this.getACT_FL());
                                    child.getData("IG_DEPT_ACT_FL").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToGtDocComn()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToGtDocComn(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (GT_DOC_COMNImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Document record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_RDeptToGtDocComn())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : RDeptToGtDocComn");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldRDeptToGtDocComn();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (GT_DOC_COMNImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Document record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        GT_DOC_COMNBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (GT_DOC_COMNBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToGtDocNotifUsr()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToGtDocNotifUsr(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (GT_DOC_NOTIFUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Document Notification User record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToGtDocNotifUsr())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToGtDocNotifUsr");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToGtDocNotifUsr();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (GT_DOC_NOTIFUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Document Notification User record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        GT_DOC_NOTIFUSRBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (GT_DOC_NOTIFUSRBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToGtDocOpty()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToGtDocOpty(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (GT_DOC_OPTYImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Document Opportunity record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToGtDocOpty())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToGtDocOpty");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToGtDocOpty();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (GT_DOC_OPTYImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Document Opportunity record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        GT_DOC_OPTYBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (GT_DOC_OPTYBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToGtDocResp()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToGtDocResp(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (GT_DOC_RESPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Document Response record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToGtDocResp())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToGtDocResp");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToGtDocResp();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (GT_DOC_RESPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Document Response record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        GT_DOC_RESPBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (GT_DOC_RESPBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToInfApprFuncOtyp()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_SH_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToInfApprFuncOtyp(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_APPR_FUNC_OTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v: Appropriation Unit Inference record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToInfApprFuncOtyp())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToInfApprFuncOtyp");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToInfApprFuncOtyp();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_APPR_FUNC_OTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v: Appropriation Unit Inference record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_APPR_FUNC_OTYPBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_APPR_FUNC_OTYPBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_SH_NM"))
                              {
                                 child.getData("DEPT_SH_NM").setValue(null);
                                 child.getData("DEPT_SH_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_SH_NM") && !child.getData("DEPT_SH_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_SH_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_SH_NM(this.getDEPT_SH_NM());
                                    child.getData("DEPT_SH_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_RsrcApprInfRecs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRsrcApprInfRecs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_APPR_RSRCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:INF_APPR_RSRC/RSRC_CD] [b:INF_APPR_RSRC/APPR_CD] Inference record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_RsrcApprInfRecs())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : RsrcApprInfRecs");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldRsrcApprInfRecs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_APPR_RSRCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:INF_APPR_RSRC/RSRC_CD] [b:INF_APPR_RSRC/APPR_CD] Inference record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_APPR_RSRCBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_APPR_RSRCBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_INF_BFYs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldINF_BFYs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_BFYImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Inference Budget Fiscal Year record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_INF_BFYs1())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : INF_BFYs1");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldINF_BFYs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_BFYImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Inference Budget Fiscal Year record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_BFYBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_BFYBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_InfDeptUnitToDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldInfDeptUnitToDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_DEPT_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Inference [b:INF_DEPT_UNIT/DEPT_CD],[b:INF_DEPT_UNIT/UNIT_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_InfDeptUnitToDept())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : InfDeptUnitToDept");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldInfDeptUnitToDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_DEPT_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Inference [b:INF_DEPT_UNIT/DEPT_CD],[b:INF_DEPT_UNIT/UNIT_CD] record Record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_DEPT_UNITBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_DEPT_UNITBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToInfFpi6()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToInfFpi6(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_FPI_6Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:INF_FPI_6/FPRFL_CD] Inference 6 record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToInfFpi6())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToInfFpi6");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToInfFpi6();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_FPI_6Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:INF_FPI_6/FPRFL_CD] Inference 6 record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_FPI_6BaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_FPI_6BaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_INF_FPRL_12()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldINF_FPRL_12(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_FPRL_1Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:INF_FPRL_1/FPRFL_CD] Inference 1 record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_INF_FPRL_12())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : INF_FPRL_12");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldINF_FPRL_12();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_FPRL_1Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:INF_FPRL_1/FPRFL_CD] Inference 1 record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_FPRL_1BaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_FPRL_1BaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_INF_FPRL_21()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldINF_FPRL_21(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_FPRL_2Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:INF_FPRL_2/FPRFL_CD] Inference 2 record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_INF_FPRL_21())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : INF_FPRL_21");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldINF_FPRL_21();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_FPRL_2Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:INF_FPRL_2/FPRFL_CD] Inference 2 record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_FPRL_2BaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_FPRL_2BaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_INF_FPRL_32()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldINF_FPRL_32(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_FPRL_3Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:INF_FPRL_3/FPRFL_CD] Inference 3 record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_INF_FPRL_32())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : INF_FPRL_32");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldINF_FPRL_32();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_FPRL_3Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:INF_FPRL_3/FPRFL_CD] Inference 3 record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_FPRL_3BaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_FPRL_3BaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_InfFprfl4Recs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldInfFprfl4Recs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_FPRL_4Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_FPRFL/FPRFL_CD] Inference 4 record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_InfFprfl4Recs())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : InfFprfl4Recs");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldInfFprfl4Recs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_FPRL_4Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_FPRFL/FPRFL_CD] Inference 4 record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_FPRL_4BaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_FPRL_4BaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToInfFprl5()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_SH_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToInfFprl5(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_FPRL_5Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Funding Profile Inference 5 record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToInfFprl5())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToInfFprl5");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToInfFprl5();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_FPRL_5Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Funding Profile Inference 5 record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_FPRL_5BaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_FPRL_5BaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_SH_NM"))
                              {
                                 child.getData("DEPT_SH_NM").setValue(null);
                                 child.getData("DEPT_SH_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_SH_NM") && !child.getData("DEPT_SH_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_SH_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_SH_NM(this.getDEPT_SH_NM());
                                    child.getData("DEPT_SH_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToInfFprlO()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToInfFprlO(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_FPRL_OImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:INF_FPRL_O/FPRFL_CD] Inference By Object record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_RDeptToInfFprlO())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : RDeptToInfFprlO");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldRDeptToInfFprlO();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_FPRL_OImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:INF_FPRL_O/FPRFL_CD] Inference By Object record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_FPRL_OBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_FPRL_OBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToInfFprlActToLcn()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToInfFprlActToLcn(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_FPRL_ACTV_LOCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:INF_FPRL_ACTV_LOC/DEPT_CD] Funding Profile Inference by Activity & Location record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToInfFprlActToLcn())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToInfFprlActToLcn");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToInfFprlActToLcn();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_FPRL_ACTV_LOCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v: Funding Profile Inference by Activity & Location record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_FPRL_ACTV_LOCBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_FPRL_ACTV_LOCBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToInfFuncFundProg()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_SH_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToInfFuncFundProg(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_FUNC_FUND_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Activity Inference record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToInfFuncFundProg())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToInfFuncFundProg");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToInfFuncFundProg();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_FUNC_FUND_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v: Activity Inference record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_FUNC_FUND_PROGBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_FUNC_FUND_PROGBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_SH_NM"))
                              {
                                 child.getData("DEPT_SH_NM").setValue(null);
                                 child.getData("DEPT_SH_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_SH_NM") && !child.getData("DEPT_SH_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_SH_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_SH_NM(this.getDEPT_SH_NM());
                                    child.getData("DEPT_SH_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_INF_FUND_FUNC_ACTVs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldINF_FUND_FUNC_ACTVs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_FUND_FUNC_ACTVImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Inference [b:INF_FUND_FUNC_ACTV/FUND_CD] [b:INF_FUND_FUNC_ACTV/FUNC_CD] [b:INF_FUND_FUNC_ACTV/ACTV_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_INF_FUND_FUNC_ACTVs1())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : INF_FUND_FUNC_ACTVs1");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldINF_FUND_FUNC_ACTVs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_FUND_FUNC_ACTVImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Inference [b:INF_FUND_FUNC_ACTV/FUND_CD] [b:INF_FUND_FUNC_ACTV/FUNC_CD] [b:INF_FUND_FUNC_ACTV/ACTV_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_FUND_FUNC_ACTVBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_FUND_FUNC_ACTVBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_GFPIToDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_SH_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldGFPIToDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_GRNT_FPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v: Grant Funding Profile Inference Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_GFPIToDept())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : GFPIToDept");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldGFPIToDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_GRNT_FPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Funding Profile Inference Record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_GRNT_FPBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_GRNT_FPBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_SH_NM"))
                              {
                                 child.getData("DEPT_SH_NM").setValue(null);
                                 child.getData("DEPT_SH_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_SH_NM") && !child.getData("DEPT_SH_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_SH_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_SH_NM(this.getDEPT_SH_NM());
                                    child.getData("DEPT_SH_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_InfObjOtypToDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_SH_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldInfObjOtypToDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_OBJ_OTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Detail Object Inference record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_InfObjOtypToDept())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : InfObjOtypToDept");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldInfObjOtypToDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_OBJ_OTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v: Detail Object Inference record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_OBJ_OTYPBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_OBJ_OTYPBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_SH_NM"))
                              {
                                 child.getData("DEPT_SH_NM").setValue(null);
                                 child.getData("DEPT_SH_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_SH_NM") && !child.getData("DEPT_SH_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_SH_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_SH_NM(this.getDEPT_SH_NM());
                                    child.getData("DEPT_SH_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_INF_PHASE_PROGs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldINF_PHASE_PROGs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_PHASE_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:INF_PHASE_PROG/PHASE_CD] [b:INF_PHASE_PROG/PROG_CD] Inference record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_INF_PHASE_PROGs())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : INF_PHASE_PROGs");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldINF_PHASE_PROGs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_PHASE_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:INF_PHASE_PROG/PHASE_CD] [b:INF_PHASE_PROG/PROG_CD] Inference record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_PHASE_PROGBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_PHASE_PROGBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_PFPIToDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_SH_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldPFPIToDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_PROJ_FPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v: Project Funding Profile Inference Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_PFPIToDept())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : PFPIToDept");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldPFPIToDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_PROJ_FPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Project Funding Profile Inference Record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_PROJ_FPBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_PROJ_FPBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_SH_NM"))
                              {
                                 child.getData("DEPT_SH_NM").setValue(null);
                                 child.getData("DEPT_SH_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_SH_NM") && !child.getData("DEPT_SH_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_SH_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_SH_NM(this.getDEPT_SH_NM());
                                    child.getData("DEPT_SH_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_RevSrcInfToDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRevSrcInfToDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_REV_SRCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v: Revenue Source Inference  record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_RevSrcInfToDept())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : RevSrcInfToDept");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldRevSrcInfToDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_REV_SRCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v: Revenue Source Inference  record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_REV_SRCBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_REV_SRCBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToInfUnit()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_SH_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToInfUnit(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:District Location Unit Inference record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToInfUnit())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToInfUnit");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToInfUnit();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v:District Location Unit Inference record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        INF_UNITBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (INF_UNITBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_SH_NM"))
                              {
                                 child.getData("DEPT_SH_NM").setValue(null);
                                 child.getData("DEPT_SH_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_SH_NM") && !child.getData("DEPT_SH_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_SH_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_SH_NM(this.getDEPT_SH_NM());
                                    child.getData("DEPT_SH_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptMaAuthDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptMaAuthDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (MA_DOC_AUTHDEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Master Agreement Document Authorised Department record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptMaAuthDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (MA_DOC_AUTHDEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Master Agreement Document Authorised Department record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToActgPrfl()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToActgPrfl(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_ACTG_PRFLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_ACTG_PRFL/ACTG_PRFL_ID] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToActgPrfl();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_ACTG_PRFLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_ACTG_PRFL/ACTG_PRFL_ID] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_ACTG_TMPLs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_SH_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_ACTG_TMPLs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_ACTG_TMPLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Accounting Template record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_R_ACTG_TMPLs())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : R_ACTG_TMPLs");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldR_ACTG_TMPLs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_ACTG_TMPLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Accounting Template record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_ACTG_TMPLBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_ACTG_TMPLBaseImpl)children.nextElement();
                           child.setSECU_DEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_SH_NM"))
                              {
                                 child.getData("SECU_DEPT_SH_NM").setValue(null);
                                 child.getData("SECU_DEPT_SH_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_SH_NM") && !child.getData("SECU_DEPT_SH_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("SECU_DEPT_SH_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setSECU_DEPT_SH_NM(this.getDEPT_SH_NM());
                                    child.getData("SECU_DEPT_SH_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToStructDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToStructDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_ALT_ORG_STRUCTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Alternate Organizational Structure record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToStructDept())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToStructDept");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToStructDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
                     while (children.hasMoreElements())
                     {
                        R_ALT_ORG_STRUCTBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_ALT_ORG_STRUCTBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
         }
      }
   

   }
   protected void childCascadeFor_DeptToApCwHdr()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_SH_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToApCwHdr(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_AP_CW_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:CW Header Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToApCwHdr())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToApCwHdr");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToApCwHdr();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_AP_CW_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:CW Header Record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_AP_CW_HDRBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_AP_CW_HDRBaseImpl)children.nextElement();
                           child.setCW_DEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_SH_NM"))
                              {
                                 child.getData("CW_DEPT_NM").setValue(null);
                                 child.getData("CW_DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_SH_NM") && !child.getData("CW_DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("CW_DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setCW_DEPT_NM(this.getDEPT_SH_NM());
                                    child.getData("CW_DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_R_AP_INCT_RQSTs2()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_AP_INCT_RQSTs2(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_AP_INCT_RQSTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Intercept Request record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_AP_INCT_RQSTs2();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_AP_INCT_RQSTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Intercept Request record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRApdDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRApdDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_APD_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Accounting Period Department Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_RDeptToRApdDept())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : RDeptToRApdDept");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldRDeptToRApdDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_APD_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Accounting Period Department Record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_APD_DEPTBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_APD_DEPTBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToCitedAuth()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_SH_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToCitedAuth(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_CITED_AUTHImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_CITED_AUTH/CITED_AUTH] Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToCitedAuth())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToCitedAuth");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToCitedAuth();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_CITED_AUTHImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_CITED_AUTH/CITED_AUTH] Record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_CITED_AUTHBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_CITED_AUTHBaseImpl)children.nextElement();
                           child.setDOC_DEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_SH_NM"))
                              {
                                 child.getData("DOC_DEPT_SH_NM").setValue(null);
                                 child.getData("DOC_DEPT_SH_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_SH_NM") && !child.getData("DOC_DEPT_SH_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DOC_DEPT_SH_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDOC_DEPT_SH_NM(this.getDEPT_SH_NM());
                                    child.getData("DOC_DEPT_SH_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToCntac()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToCntac(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_CNTACImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Department record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToCntac();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_CNTACImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759, v:[b: R_DEPT /DEPT_CD] ,v:Deapartment Table Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_COMM_FA_THLDs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_COMM_FA_THLDs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_COMM_FA_THLDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Commodity Fixed Asset Threshold record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_R_COMM_FA_THLDs1())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : R_COMM_FA_THLDs1");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldR_COMM_FA_THLDs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_COMM_FA_THLDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Commodity Fixed Asset Threshold record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_COMM_FA_THLDBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_COMM_FA_THLDBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_R_COMM_OBJs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_COMM_OBJs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_COMM_OBJImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Commodity Object record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_R_COMM_OBJs1())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : R_COMM_OBJs1");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldR_COMM_OBJs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
                     while (children.hasMoreElements())
                     {
                        R_COMM_OBJBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_COMM_OBJBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
         }
      }
   

   }
   protected void childCascadeFor_DeptToDeptFY()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToDeptFY(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DEPT_FYImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_DEPT_FY/DEPT_CD]record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToDeptFY())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToDeptFY");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToDeptFY();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DEPT_FYImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[R_DEPT_FY/DEPT_CD]record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_DEPT_FYBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_DEPT_FYBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRDeptObjPymtCtrl()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRDeptObjPymtCtrl(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DEPT_OBJ_PYCTRLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Department Object Payment Control table.","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_RDeptToRDeptObjPymtCtrl())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : RDeptToRDeptObjPymtCtrl");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldRDeptToRDeptObjPymtCtrl();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DEPT_OBJ_PYCTRLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Department Object Payment Control table.%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_DEPT_OBJ_PYCTRLBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_DEPT_OBJ_PYCTRLBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToDISCIV()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_SH_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToDISCIV(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DISCIVImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Disbursement Category Inference and Combination Validation Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToDISCIV())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToDISCIV");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToDISCIV();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DISCIVImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v:Disbursement Category Inference and Combination Validation Record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_DISCIVBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_DISCIVBaseImpl)children.nextElement();
                           child.setDOC_DEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_SH_NM"))
                              {
                                 child.getData("DOC_DEPT_SH_NM").setValue(null);
                                 child.getData("DOC_DEPT_SH_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_SH_NM") && !child.getData("DOC_DEPT_SH_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DOC_DEPT_SH_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDOC_DEPT_SH_NM(this.getDEPT_SH_NM());
                                    child.getData("DOC_DEPT_SH_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToDrwdwnGrp()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToDrwdwnGrp(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DRWDWN_GRPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_DRWDWN_GRP/DRWDWN_GRP] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToDrwdwnGrp())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToDrwdwnGrp");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToDrwdwnGrp();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DRWDWN_GRPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_DRWDWN_GRP/DRWDWN_GRP] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_DRWDWN_GRPBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_DRWDWN_GRPBaseImpl)children.nextElement();
                           child.setDRWDWN_DEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DRWDWN_DEPT_NM").setValue(null);
                                 child.getData("DRWDWN_DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DRWDWN_DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DRWDWN_DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDRWDWN_DEPT_NM(this.getDEPT_NM());
                                    child.getData("DRWDWN_DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToEscrowDef()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToEscrowDef(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_ESCROW_DEFImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Escrow Definition Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToEscrowDef())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToEscrowDef");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToEscrowDef();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_ESCROW_DEFImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Escrow Definition Record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_ESCROW_DEFBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_ESCROW_DEFBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRFesReq()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRFesReq(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FESREQImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:FESREQ record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_RDeptToRFesReq())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : RDeptToRFesReq");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldRDeptToRFesReq();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FESREQImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:FESREQ record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_FESREQBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_FESREQBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRFndgAlloc()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRFndgAlloc(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FNDG_ALLOCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Funding Allocation Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRFndgAlloc();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FNDG_ALLOCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Funding Allocation Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRFyDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRFyDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FY_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Fiscal Year Department Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_RDeptToRFyDept())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : RDeptToRFyDept");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldRDeptToRFyDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FY_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Fiscal Year Department Record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_FY_DEPTBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_FY_DEPTBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRGrntAppl()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRGrntAppl(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_GRNT_APPLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Application record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_RDeptToRGrntAppl())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : RDeptToRGrntAppl");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldRDeptToRGrntAppl();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_GRNT_APPLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Application record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_GRNT_APPLBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_GRNT_APPLBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRGrntDtTmpl()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRGrntDtTmpl(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_GRNT_DT_TMPLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Date Definition Template record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRGrntDtTmpl();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_GRNT_DT_TMPLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Date Definition Template record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToGrntOpty()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToGrntOpty(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_GRNT_OPTYImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToGrntOpty())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToGrntOpty");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToGrntOpty();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_GRNT_OPTYImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Opportunity record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_GRNT_OPTYBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_GRNT_OPTYBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToGrntResp()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToGrntResp(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_GRNT_RESPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Response record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToGrntResp())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToGrntResp");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToGrntResp();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_GRNT_RESPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Response record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_GRNT_RESPBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_GRNT_RESPBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToGrntUser()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToGrntUser(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_GRNT_USERImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Require [b:R_GRNT_USER/DEPT_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToGrntUser())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToGrntUser");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToGrntUser();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_GRNT_USERImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A1713,v:Current Fiscal Year, [b:R_DEPT/DEPT_CD],v:Require [b:R_GRNT_USER/DEPT_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_GRNT_USERBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_GRNT_USERBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_R_INTG_CTRL()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_INTG_CTRL(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_INTG_CTRLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A3519%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_R_INTG_CTRL())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : R_INTG_CTRL");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldR_INTG_CTRL();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_INTG_CTRLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A3519%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_INTG_CTRLBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_INTG_CTRLBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_R_MJR_PROGs3()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_MJR_PROGs3(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_MJR_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_MJR_PROG/MJR_PROG_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_R_MJR_PROGs3())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : R_MJR_PROGs3");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldR_MJR_PROGs3();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_MJR_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_MJR_PROG/MJR_PROG_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_MJR_PROGBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_MJR_PROGBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DepartmentToOnGoingAwardInfo()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDepartmentToOnGoingAwardInfo(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_ONGOING_AWD_INFOImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Ongoing Award Information record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DepartmentToOnGoingAwardInfo())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DepartmentToOnGoingAwardInfo");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDepartmentToOnGoingAwardInfo();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_ONGOING_AWD_INFOImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Ongoing Award Information record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_ONGOING_AWD_INFOBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_ONGOING_AWD_INFOBaseImpl)children.nextElement();
                           child.setCA_DEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("CA_DEPT_NM").setValue(null);
                                 child.getData("CA_DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("CA_DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("CA_DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setCA_DEPT_NM(this.getDEPT_NM());
                                    child.getData("CA_DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_PerfEvalEvaluator()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldPerfEvalEvaluator(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PE_EVALRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Performance Evaluation Evaluator record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldPerfEvalEvaluator();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PE_EVALRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Performance Evaluation Evaluator record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_StateInstances()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldStateInstances(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PRCU_STImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Procurement State record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_StateInstances())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : StateInstances");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldStateInstances();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PRCU_STImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Procurement State record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_PRCU_STBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_PRCU_STBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRPayHldByDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRPayHldByDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PYMT_HLD_TYP_DPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException(" %c:A760,v:Department%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRPayHldByDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PYMT_HLD_TYP_DPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v:Payment Hold By Department%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_STPF()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_STPF(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_STPFImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_STPF/STPF_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_R_STPF())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : R_STPF");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldR_STPF();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_STPFImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_STPF/STPF_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_STPFBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_STPFBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_UniversalRequestorControls()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_SH_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldUniversalRequestorControls(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_UR_CTRLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Universal Requestor Control record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_UniversalRequestorControls())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : UniversalRequestorControls");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldUniversalRequestorControls();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_UR_CTRLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Universal Requestor Control record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_UR_CTRLBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_UR_CTRLBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_SH_NM"))
                              {
                                 child.getData("DEPT_SH_NM").setValue(null);
                                 child.getData("DEPT_SH_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_SH_NM") && !child.getData("DEPT_SH_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_SH_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_SH_NM(this.getDEPT_SH_NM());
                                    child.getData("DEPT_SH_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_UserGrpTmplToDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldUserGrpTmplToDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_USER_GRP_TMPLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Require [b:R_USER_GRP_TMPL/DEPT_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_UserGrpTmplToDept())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : UserGrpTmplToDept");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldUserGrpTmplToDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_USER_GRP_TMPLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A1713,v:Current Fiscal Year, [b:R_DEPT/DEPT_CD],v:Require [b:R_USER_GRP_TMPL/DEPT_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        R_USER_GRP_TMPLBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_USER_GRP_TMPLBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_R_VEND_LSTs2()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_VEND_LSTs2(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_VEND_LSTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Vendor List record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_R_VEND_LSTs2())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : R_VEND_LSTs2");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldR_VEND_LSTs2();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
                     while (children.hasMoreElements())
                     {
                        R_VEND_LSTBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_VEND_LSTBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
         }
      }
   

   }
   protected void childCascadeFor_REQ_ACTV_SACTVs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldREQ_ACTV_SACTVs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (REQ_ACTV_SACTVImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Require [b:REQ_ACTV_SACTV/ACTV_CD] [b:REQ_ACTV_SACTV/SACTV_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_REQ_ACTV_SACTVs())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : REQ_ACTV_SACTVs");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldREQ_ACTV_SACTVs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (REQ_ACTV_SACTVImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A1713,v:[b:R_DEPT/DEPT_CD],v:Require [b:REQ_ACTV_SACTV/ACTV_CD] [b:REQ_ACTV_SACTV/SACTV_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        REQ_ACTV_SACTVBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (REQ_ACTV_SACTVBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_REQ_DEPT_OBJ_REVs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldREQ_DEPT_OBJ_REVs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (REQ_DEPT_OBJ_REVImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Required [b:REQ_DEPT_OBJ_REV/DEPT_CD] [b:REQ_DEPT_OBJ_REV/DOBJ_CD] [b:REQ_DEPT_OBJ_REV/DRSRC_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_REQ_DEPT_OBJ_REVs())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : REQ_DEPT_OBJ_REVs");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldREQ_DEPT_OBJ_REVs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (REQ_DEPT_OBJ_REVImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Required [b:REQ_DEPT_OBJ_REV/DEPT_CD] [b:REQ_DEPT_OBJ_REV/DOBJ_CD] [b:REQ_DEPT_OBJ_REV/DRSRC_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        REQ_DEPT_OBJ_REVBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (REQ_DEPT_OBJ_REVBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_ReqFundDeptToRDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldReqFundDeptToRDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (REQ_FUND_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:REQ_FUND_DEPT/DEPT_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_ReqFundDeptToRDept())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : ReqFundDeptToRDept");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldReqFundDeptToRDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (REQ_FUND_DEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:REQ_FUND_DEPT/DEPT_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        REQ_FUND_DEPTBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (REQ_FUND_DEPTBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_REQ_FUND_UNIT_OBJs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldREQ_FUND_UNIT_OBJs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (REQ_FUND_UNIT_OBJImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Require [b:REQ_FUND_UNIT_OBJ/RPT_CD] by [b:REQ_FUND_UNIT_OBJ/OBJ_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_REQ_FUND_UNIT_OBJs())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : REQ_FUND_UNIT_OBJs");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldREQ_FUND_UNIT_OBJs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (REQ_FUND_UNIT_OBJImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Require [b:REQ_FUND_UNIT_OBJ/RPT_CD] by [b:REQ_FUND_UNIT_OBJ/OBJ_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        REQ_FUND_UNIT_OBJBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (REQ_FUND_UNIT_OBJBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_REQ_FUND_UNIT_RSRCs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldREQ_FUND_UNIT_RSRCs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (REQ_FUND_UNIT_RSRCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Require [b:REQ_FUND_UNIT_RSRC/RPT_CD] by [b:REQ_FUND_UNIT_RSRC/RSRC_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_REQ_FUND_UNIT_RSRCs())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : REQ_FUND_UNIT_RSRCs");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldREQ_FUND_UNIT_RSRCs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (REQ_FUND_UNIT_RSRCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Require [b:REQ_FUND_UNIT_RSRC/RPT_CD] by [b:REQ_FUND_UNIT_RSRC/RSRC_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        REQ_FUND_UNIT_RSRCBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (REQ_FUND_UNIT_RSRCBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_REQ_UNITs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldREQ_UNITs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (REQ_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Require [b:REQ_UNIT/SUNIT_CD] by [b:REQ_UNIT/UNIT_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_REQ_UNITs())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : REQ_UNITs");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldREQ_UNITs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (REQ_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Require [b:REQ_UNIT/SUNIT_CD] by [b:REQ_UNIT/UNIT_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        REQ_UNITBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (REQ_UNITBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToReqUnitProg()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToReqUnitProg(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (REQ_UNIT_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:REQ_UNIT_PROG/UNIT_CD] [b:REQ_UNIT_PROG/PROG_CD] Required Element record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_DeptToReqUnitProg())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : DeptToReqUnitProg");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldDeptToReqUnitProg();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (REQ_UNIT_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:REQ_UNIT_PROG/UNIT_CD] [b:REQ_UNIT_PROG/PROG_CD] Required Element record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        REQ_UNIT_PROGBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (REQ_UNIT_PROGBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_REQ_UNIT_SUNITs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   
   
         // See if the maintained replicate needs to be cascaded i.e. if it has changed.
         if (( isUpdated() ) && ( 1 == 0
 || (isChanged("DEPT_NM")) ))
            ReplChanged = true;
         else
            ReplChanged = false;

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldREQ_UNIT_SUNITs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (REQ_UNIT_SUNITImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:REQ_UNIT_SUNIT/UNIT_CD] [b:REQ_UNIT_SUNIT/SUNIT_CD] Requirement record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
  
          try
          {
             if(ReplChanged)
             {
               // Prevent non-persistent maintained parent replication when any attribute is set for 
               // PARENT_REPLICATE_SKIP_LOGIC (for more details search keyword PARENT_REPLICATE_SKIP_LOGIC in AMSDataObject.java)
               if(isPrevMaintNonPersReplicateSet(getSession(),"R_DEPT"))
               {
           moAMSLog.debug(" Prevent Maintained Non-Persistent Replication property is set on :: R_DEPT ");
               
           //Check if the logic to fetch children Dataobjects and update them with replicated
           //value on their non-persistent attributes should be skipped or not.
           if(preventReplicatePushFor_REQ_UNIT_SUNITs())
           {
              moAMSLog.debug(" Performing parent replicate skip logic : REQ_UNIT_SUNITs");
              return;
           }               
               }
             }
          }
          catch ( Exception ex )
          {
             ex.printStackTrace();
             raiseException( "Error while performing skip logic for parent replicates ", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
          }
         children = getOldREQ_UNIT_SUNITs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (REQ_UNIT_SUNITImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:REQ_UNIT_SUNIT/UNIT_CD] [b:REQ_UNIT_SUNIT/SUNIT_CD] Requirement record%","R_DEPT","DEPT_CD");
                     }
                  }
                     // At this point we know there is a maintained replicate.
                     while (children.hasMoreElements())
                     {
                        REQ_UNIT_SUNITBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (REQ_UNIT_SUNITBaseImpl)children.nextElement();
                           child.setDEPT_CD(this.getDEPT_CD());
                              if (isNull("DEPT_NM"))
                              {
                                 child.getData("DEPT_NM").setValue(null);
                                 child.getData("DEPT_NM").setPushPending(true);
                              }
                              else
                              {
                                 if(!isChanged("DEPT_NM") && !child.getData("DEPT_NM").getMetaColumn().isVirtual())
                                 {
                                    child.getData("DEPT_NM").setPushPending(false); //MD!!!
                                 }
                                 else
                                 {
                                    child.setDEPT_NM(this.getDEPT_NM());
                                    child.getData("DEPT_NM").setPushPending(true);
                                 }
                              }
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
            
         }
      }
   

   }
   protected void childCascadeFor_R_OTPT_PARM_DETs3()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_OTPT_PARM_DETs3(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_OTPT_PARM_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Reimbursement Output Parameter%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_OTPT_PARM_DETs3();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_OTPT_PARM_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A1713,v:[b:R_DEPT/DEPT_CD],v:Reimbursement Output Parameter%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRGrntrEvntSched2()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRGrntrEvntSched2(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_GRNTR_EVNT_SCHEDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Events Schedule record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRGrntrEvntSched2();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_GRNTR_EVNT_SCHEDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Events Schedule record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_FARO_PARMs3()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_FARO_PARMs3(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FARO_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Fixed Assets Reorganization record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_FARO_PARMs3();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FARO_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Fixed Assets Reorganization record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToClmtrk1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToClmtrk1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_CLMTRKImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_CLMTRK/ AWD_DOC_DEPT_CD], Claims Tracking%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToClmtrk1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_CLMTRKImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD], Claims Tracking%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToGtDocProgMgmtUsr()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToGtDocProgMgmtUsr(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (GT_DOC_PMGMTUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Document Program Management User record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToGtDocProgMgmtUsr();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (GT_DOC_PMGMTUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Document Program Management User record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_ACRL_CLR_EXCL()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldACRL_CLR_EXCL(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (ACRL_CLR_EXCLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Appropriation Unit Attributes table record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldACRL_CLR_EXCL();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (ACRL_CLR_EXCLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A1713,v:[b:R_APPR/APPR_CD],v:Appropriation Unit Attributes record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RQ_DOC_CMPSHT()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRQ_DOC_CMPSHT(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (RQ_DOC_CMPSHTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("Delete Rejected because there are RQ_DOC_CMPSHT found for R_DEPT");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRQ_DOC_CMPSHT();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (RQ_DOC_CMPSHTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("Update Rejected because there are RQ_DOC_CMPSHT found for R_DEPT");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_MJR_PGRPs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_MJR_PGRPs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_MJR_PGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_MJR_PGRP/MJR_PGRP_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_MJR_PGRPs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_MJR_PGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_MJR_PGRP/MJR_PGRP_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_IntrActgToDocDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldIntrActgToDocDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_INTR_ACTG_CRSWLKImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Interest Accounting Line Crosswalk Table record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldIntrActgToDocDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_INTR_ACTG_CRSWLKImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DOC_DEPT_CD],Interest Accounting Line Crosswalk Table record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_FacpatToDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldFacpatToDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FACPATImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Fixed Asset Construction Program Allocation Total Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldFacpatToDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FACPATImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Fixed Asset Construction Program Allocation Total Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_FacpadToDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldFacpadToDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FACPADImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Fixed Asset Construction Program Allocation Detail Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldFacpadToDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FACPADImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Fixed Asset Construction Program Allocation Detail Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_DOCATs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_DOCATs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DOCATImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_DOCAT/DOCAT_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_DOCATs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DOCATImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_DOCAT/DOCAT_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDept_RBfyStpfSpnd()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDept_RBfyStpfSpnd(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_BFY_STPF_SPNDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Budget Fiscal Year Staging Profile Spending Line%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDept_RBfyStpfSpnd();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_BFY_STPF_SPNDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Budget Fiscal Year Staging Profile Spending Line%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_AP_DISB_PARMs3()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_AP_DISB_PARMs3(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_AP_DISB_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Disbursement Parameters record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_AP_DISB_PARMs3();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_AP_DISB_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Disbursement Parameters record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_MMRDocHdrDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldMMRDocHdrDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (MMR_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("Delete Rejected because there are MMR_DOC_HDR found for R_DEPT");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldMMRDocHdrDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (MMR_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("Update Rejected because there are MMR_DOC_HDR found for R_DEPT");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToMaSrtyIns()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToMaSrtyIns(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (MA_DOC_SRTYINSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Master Agreement Document Surety Insurance record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToMaSrtyIns();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (MA_DOC_SRTYINSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Holding Department,v:Master Agreement Document Surety Insurance record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToFndCDocFndC()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToFndCDocFndC(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (FNDC_DOC_FNDCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Funding Control Document Funding Control record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToFndCDocFndC();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (FNDC_DOC_FNDCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Funding Control Document Funding Control record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RqstDeptToCMRDocHdr()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRqstDeptToCMRDocHdr(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (CMR_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("Delete Rejected because there are CMR_DOC_HDR found for R_DEPT");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRqstDeptToCMRDocHdr();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (CMR_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("Update Rejected because there are CMR_DOC_HDR found for R_DEPT");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_TASKs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_TASKs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_TASKImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_TASK/TASK_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_TASKs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_TASKImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_TASK/TASK_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRPayHldTin()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRPayHldTin(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PYMT_HLD_TINImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Department%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRPayHldTin();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PYMT_HLD_TINImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v:Payment Hold TIN record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRFsc()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRFsc(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FSCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Funding Source Control record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRFsc();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FSCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Funding Source Control record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_FIN_CHRG_SETP()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_FIN_CHRG_SETP(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FIN_CHRG_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Finance Charge Setup Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_FIN_CHRG_SETP();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FIN_CHRG_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Finance Charge Setup record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_FARO_PARMs2()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_FARO_PARMs2(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FARO_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Fixed Assets Reorganization record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_FARO_PARMs2();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FARO_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Fixed Assets Reorganization record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRCntrcGlln1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRCntrcGlln1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_CNTRC_GOAL_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Department%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRCntrcGlln1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_CNTRC_GOAL_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v:Contract Goal Line record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDept_RBfyStpfBsa()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDept_RBfyStpfBsa(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_BFY_STPF_BSAImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Budget Fiscal Year Staging Profile Balance Sheet Line%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDept_RBfyStpfBsa();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_BFY_STPF_BSAImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Budget Fiscal Year Staging Profile Balance Sheet Line%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRAdcParm()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRAdcParm(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_ADC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Automatic Document Correction Parameters record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRAdcParm();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_ADC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Automatic Document Correction Parameters record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToGtDocPrtnrUsr()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToGtDocPrtnrUsr(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (GT_DOC_PRTNRUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:GT_DOC_PRTNRUSR/GRNT_USER_ID] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToGtDocPrtnrUsr();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (GT_DOC_PRTNRUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:GT_DOC_PRTNRUSR/GRNT_USER_ID] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RdeptToCsalProcParm()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRdeptToCsalProcParm(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (CSAL_PROC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Cost Allocation Process Parameters%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRdeptToCsalProcParm();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (CSAL_PROC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Cost Allocation Process Parameters%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_VmPrvntDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldVmPrvntDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (VCM_DOC_PRVNTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v: Vendor Customer Modify Document Prevent Spending component record %","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldVmPrvntDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (VCM_DOC_PRVNTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v: Department,v: Vendor Customer Modify Document Prevent Spending component record %","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRUtlyActgPrfl()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRUtlyActgPrfl(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_UTLY_ACTG_PRFLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Utility Billing Profile record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRUtlyActgPrfl();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_UTLY_ACTG_PRFLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Utility Billing Profile record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_UNITs2()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_UNITs2(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_UNIT/UNIT_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_UNITs2();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_UNITImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_UNIT/UNIT_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_TASK_ORDs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_TASK_ORDs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_TASK_ORDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_TASK_ORD/TASK_ORD_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_TASK_ORDs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_TASK_ORDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_TASK_ORD/TASK_ORD_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRRgn()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRRgn(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_RGNImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Region record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRRgn();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_RGNImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Region record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_PGRPs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_PGRPs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_PGRP/PGRP_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_PGRPs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_PGRP/PGRP_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToPartUsg()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToPartUsg(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PART_USGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Part Usage record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToPartUsg();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PART_USGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Part Usage record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_MJR_PTYPs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_MJR_PTYPs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_MJR_PTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_MJR_PTYP/MJR_PTYP_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_MJR_PTYPs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_MJR_PTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_MJR_PTYP/MJR_PTYP_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_DSTCs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_DSTCs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DSTCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_DSTC/DSTC_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_DSTCs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DSTCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_DSTC/DSTC_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRCntrcGlln()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRCntrcGlln(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_CNTRC_GOAL_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Department%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRCntrcGlln();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_CNTRC_GOAL_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v:Contract Goal Line record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RCashSweepToRDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRCashSweepToRDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_CASH_SW_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Cash Sweep record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRCashSweepToRDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_CASH_SW_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Cash Sweep record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_AP_CLM_ACCTs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_AP_CLM_ACCTs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_AP_CLM_ACCTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Claim Account record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_AP_CLM_ACCTs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_AP_CLM_ACCTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Claim Account record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToAltDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToAltDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_ALT_ORG_STRUCTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Alternate Organizational Structure record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToAltDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
                     while (children.hasMoreElements())
                     {
                        R_ALT_ORG_STRUCTBaseImpl   child = null;
                        // The getChildren function returns the child objects on the right context.
                        child = (R_ALT_ORG_STRUCTBaseImpl)children.nextElement();
                           child.setALT_DEPT_CD(this.getDEPT_CD());
                        notifyUpdatingChild((AMSDataObject)child);                        
                        child.setUpdate();
                        child.executeRules();
                     }
         }
      }
   

   }
   protected void childCascadeFor_ONLN_PRN_BAT_PARM1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldONLN_PRN_BAT_PARM1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (ONLN_PRN_BAT_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("Delete Rejected because there are ONLN_PRN_BAT_PARM found for R_DEPT");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldONLN_PRN_BAT_PARM1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (ONLN_PRN_BAT_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("Update Rejected because there are ONLN_PRN_BAT_PARM found for R_DEPT");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_INF_APPRs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldINF_APPRs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_APPRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:INF_APPR/FUND_CD] [b:INF_APPR/UNIT_CD] [b:INF_APPR/OBJ_CD] Inference record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldINF_APPRs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_APPRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:INF_APPR/FUND_CD] [b:INF_APPR/UNIT_CD] [b:INF_APPR/OBJ_CD] Inference record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToGtDocRptuser()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToGtDocRptuser(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (GT_DOC_RPTUSERImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Document Reporting User record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToGtDocRptuser();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (GT_DOC_RPTUSERImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Document Reporting User record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DOC_HDRs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDOC_HDRs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Document Header record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDOC_HDRs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Document Header record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_VmAuthDeptDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldVmAuthDeptDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (VCM_DOC_AUTHDEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v: Vendor Customer Modify Document Vendor Authorized Department component record %","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldVmAuthDeptDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (VCM_DOC_AUTHDEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v: Department,v: Vendor Customer Modify Document Vendor Authorized Department component record %","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_PRVNT_SPNDs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_PRVNT_SPNDs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PRVNT_SPNDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Prevent Spending record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_PRVNT_SPNDs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PRVNT_SPNDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Prevent Spending record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToPartRf()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToPartRf(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PART_RFImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Part Reference record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToPartRf();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PART_RFImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Part Reference record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRGrntrRpt()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRGrntrRpt(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_GRNTR_RPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Report record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRGrntrRpt();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_GRNTR_RPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Report record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToDebtAuth()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToDebtAuth(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DEBT_AUTHImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Debt Authorization record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToDebtAuth();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DEBT_AUTHImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Debt Authorization record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RdeptToRcsalSrctrSetp()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRdeptToRcsalSrctrSetp(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_CSAL_SRCTR_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Cost Allocation Series Setup%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRdeptToRcsalSrctrSetp();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_CSAL_SRCTR_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Cost Allocation Series Setup%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRApUprocPrcuAl()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRApUprocPrcuAl(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_AP_UPROC_PRCU_ALImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Unprocessed Procurement Card Activity Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRApUprocPrcuAl();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_AP_UPROC_PRCU_ALImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Unprocessed Procurement Card Activity Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToApCwChk()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToApCwChk(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_AP_CW_CHK_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:CW Pre-Assigned Check Number Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToApCwChk();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_AP_CW_CHK_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:CW Pre-Assigned Check Number Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDept1ToRAdcParm1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDept1ToRAdcParm1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_ADC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Automatic Document Correction Parameters record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDept1ToRAdcParm1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_ADC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Automatic Document Correction Parameters record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToMDHdr()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToMDHdr(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (MD_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:MD Header Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToMDHdr();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (MD_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:MD Header Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToCamProcParm()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToCamProcParm(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (CAM_PROC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Clearing Account Maintenance Parameter Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToCamProcParm();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (CAM_PROC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Clearing Account Maintenance Parameter Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RdeptToRstatUnitSetp()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRdeptToRstatUnitSetp(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_STAT_UNIT_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Statistical Unit%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRdeptToRstatUnitSetp();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_STAT_UNIT_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Statistical Unit%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToProgSta()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToProgSta(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PROG_STAImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Program Status record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToProgSta();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PROG_STAImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Program Status record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_PROGs2()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_PROGs2(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_PROG/PROG_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_PROGs2();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PROGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_PROG/PROG_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToOnGoingAwardInfo()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToOnGoingAwardInfo(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_ONGOING_AWD_INFOImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Ongoing Award Information record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToOnGoingAwardInfo();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_ONGOING_AWD_INFOImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Ongoing Award Information record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_NegDrawExcpDtlRecs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldNegDrawExcpDtlRecs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_NEG_DRW_EXCP_DTLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Negative Draw Exception Table%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldNegDrawExcpDtlRecs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_NEG_DRW_EXCP_DTLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Negative Draw Exception Table%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_LCLSs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_LCLSs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_LCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_LCLS/LCLS_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_LCLSs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_LCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_LCLS/LCLS_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToGrntNotifUsr()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToGrntNotifUsr(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_GRNT_NOTIFUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Notification User record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToGrntNotifUsr();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_GRNT_NOTIFUSRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Notification User record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDept2ToRAdcParm2()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDept2ToRAdcParm2(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_ADC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Automatic Document Correction Parameters record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDept2ToRAdcParm2();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_ADC_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Automatic Document Correction Parameters record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_ACATs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_ACATs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_ACATImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_ACAT/ACAT_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_ACATs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_ACATImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_ACAT/ACAT_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_LrdsToDept1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldLrdsToDept1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (LIC_RNEW_DT_STRGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:License Renewal Data Storage Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldLrdsToDept1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (LIC_RNEW_DT_STRGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:License Renewal Data Storage Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_LrdsToDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldLrdsToDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (LIC_RNEW_DT_STRGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:License Renewal Data Storage Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldLrdsToDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (LIC_RNEW_DT_STRGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:License Renewal Data Storage Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToARRADocSRcpQtr()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToARRADocSRcpQtr(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (ARRA_DOC_SRCPQTRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:ARRA Document Sub-Recipient Quarterly record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToARRADocSRcpQtr();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (ARRA_DOC_SRCPQTRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:ARRA Document Sub-Recipient Quarterly record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_ACRL_CLR_MGMT_2()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldACRL_CLR_MGMT_2(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (ACRL_CLR_MGMTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("Delete Rejected because there are ACRL_CLR_MGMT found for R_DEPT");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldACRL_CLR_MGMT_2();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (ACRL_CLR_MGMTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("Update Rejected because there are ACRL_CLR_MGMT found for R_DEPT");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_TRVLCoaOVrdToRDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldTRVLCoaOVrdToRDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (TRVL_COA_OVRDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Travel COA Override%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldTRVLCoaOVrdToRDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (TRVL_COA_OVRDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v:Travel COA Override%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToSrcOfFund()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToSrcOfFund(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_SRC_OF_FUNDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Source of Funds Record %","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToSrcOfFund();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_SRC_OF_FUNDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Source of Funds Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_REIM_GEN_PARAM()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_REIM_GEN_PARAM(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_REIM_GEN_PARAMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("Delete Rejected because there are R_REIM_GEN_PARAM found for R_DEPT");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_REIM_GEN_PARAM();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_REIM_GEN_PARAMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("Update Rejected because there are R_REIM_GEN_PARAM found for R_DEPT");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DocDeptToReimExpAdj()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDocDeptToReimExpAdj(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_REIM_EXP_ADJImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Reimbursable Expense Adjustment record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDocDeptToReimExpAdj();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_REIM_EXP_ADJImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Reimbursable Expense Adjustment Parameter record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RFAIntnExcepToRDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRFAIntnExcepToRDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FA_INTN_EXCEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Fixed Asset Intent Exception Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRFAIntnExcepToRDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FA_INTN_EXCEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Fixed Asset Intent Exception Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToDebtHist1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToDebtHist1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DEBT_HISTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Debt History%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToDebtHist1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DEBT_HISTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEBT_HIST/RESP_DEPT_CD],v:Debt History%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_CORSPDs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_CORSPDs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_CORSPDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Correspondence record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_CORSPDs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_CORSPDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Correspondence record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToCWCanParm()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToCWCanParm(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_AP_CWCAN_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:CW Cancellation Parameter Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToCWCanParm();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_AP_CWCAN_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:CW Cancellation Parameter Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToAutoCano()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToAutoCano(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (AUTO_CA_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v: Cost Accounting Auto Numbering Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToAutoCano();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (AUTO_CA_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v: Cost Accounting Auto Numbering Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_TRVLCoaOvrdToDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldTRVLCoaOvrdToDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (TRVL_COA_OVRDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Travel COA Override%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldTRVLCoaOvrdToDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (TRVL_COA_OVRDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v:Travel COA Override%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_Dept1ToTaskOrdBuyrLn1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDept1ToTaskOrdBuyrLn1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_TASK_ORD_BUYR_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_TASK_ORD_BUYR_LN/TASK_ORD] Buyer Line Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDept1ToTaskOrdBuyrLn1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_TASK_ORD_BUYR_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_TASK_ORD_BUYR_LN/TASK_ORD] Buyer Line Table%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToTaskOrdBuyrLn()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToTaskOrdBuyrLn(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_TASK_ORD_BUYR_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_TASK_ORD_BUYR_LN/TASK_ORD] Buyer Line Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToTaskOrdBuyrLn();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_TASK_ORD_BUYR_LNImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_TASK_ORD_BUYR_LN/TASK_ORD] Buyer Line Table%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_SYS_CROSWALKs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_SYS_CROSWALKs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_SYS_CROSWALKImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:System Crosswalk record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_SYS_CROSWALKs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_SYS_CROSWALKImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:System Crosswalk record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_PTYPs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_PTYPs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_PTYP/PTYP_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_PTYPs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_PTYP/PTYP_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RdeptToRplbsOfstReq()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRdeptToRplbsOfstReq(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PLBS_OFST_REQImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Pool/Base Offset Requirement%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRdeptToRplbsOfstReq();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PLBS_OFST_REQImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Pool/Base Offset Requirement%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RdeptToRplbsDist()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRdeptToRplbsDist(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PLBS_DISTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Pool/Base Distribution%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRdeptToRplbsDist();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PLBS_DISTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Pool/Base Distribution%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRGrntrRpt1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRGrntrRpt1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_GRNTR_RPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Report record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRGrntrRpt1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_GRNTR_RPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Report record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_FNCATs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_FNCATs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FNCATImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_FNCAT/FNCAT_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_FNCATs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FNCATImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_FNCAT/FNCAT_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RdeptToRcsalStpctrSetp()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRdeptToRcsalStpctrSetp(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_CSAL_STPCTR_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Cost Allocation Step Setup%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRdeptToRcsalStpctrSetp();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_CSAL_STPCTR_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Cost Allocation Step Setup%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_BURs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_BURs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_BURImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_BUR/BUR_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_BURs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_BURImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_BUR/BUR_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDept_RBfyStpfNactg()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDept_RBfyStpfNactg(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_BFY_STPF_NACTGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Budget Fiscal Year Staging Profile Non-accounting Line%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDept_RBfyStpfNactg();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_BFY_STPF_NACTGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Budget Fiscal Year Staging Profile Non-accounting Line%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_AUTO_DOC_NOs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldAUTO_DOC_NOs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (AUTO_DOC_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Automatic Document Number record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldAUTO_DOC_NOs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (AUTO_DOC_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Automatic Document Number record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptVcVcust()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptVcVcust(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (VCC_DOC_VCUSTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Vendor/Customer record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptVcVcust();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (VCC_DOC_VCUSTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Vendor/Customer record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptVcAuthDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptVcAuthDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (VCC_DOC_AUTHDEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("Delete Rejected because there are VCC_DOC_AUTHDEPT found for R_DEPT");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptVcAuthDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (VCC_DOC_AUTHDEPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("Update Rejected because there are VCC_DOC_AUTHDEPT found for R_DEPT");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RQ_DOC_HDR()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRQ_DOC_HDR(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (RQ_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("Delete Rejected because there are RQ_DOC_HDR found for R_DEPT");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRQ_DOC_HDR();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (RQ_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("Update Rejected because there are RQ_DOC_HDR found for R_DEPT");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_ReimReqRcycSelToDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldReimReqRcycSelToDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_REIMRQD_RCYCSELImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Reimbursement Request Recycling Selection Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldReimReqRcycSelToDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_REIMRQD_RCYCSELImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Reimbursement Request Recycling Selection Table%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRPrtst()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRPrtst(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PRTSTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Protest Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRPrtst();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PRTSTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Protest Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_LOC_TBLs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_LOC_TBLs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_LOC_TBLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_LOC_TBL/LOC_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_LOC_TBLs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_LOC_TBLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_LOC_TBL/LOC_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDept1ToRIntCst()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDept1ToRIntCst(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_INT_CST_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Internal Cost Parameter record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDept1ToRIntCst();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_INT_CST_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DOC_DEPT_CD],v:Internal Cost Parameter record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRGrntrEvntSched()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRGrntrEvntSched(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_GRNTR_EVNT_SCHEDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Events Schedule record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRGrntrEvntSched();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_GRNTR_EVNT_SCHEDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Events Schedule record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToEscrowHist()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToEscrowHist(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_ESCROW_HISTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_ESCROW_HIST/DOC_DEPT_CD]Escrow History Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToEscrowHist();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_ESCROW_HISTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DOC_DEPT_CD],v:Escrow History Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_DISB_MGMT_RSTRs2()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_DISB_MGMT_RSTRs2(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DISB_MGMT_RSTRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Disbursement Hold Exclusion record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_DISB_MGMT_RSTRs2();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DISB_MGMT_RSTRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Disbursement Hold Exclusion record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToDebtDocDebtInst()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToDebtDocDebtInst(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (DEBT_DOC_DEBTINSTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Debt Document Debt Instrument record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToDebtDocDebtInst();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (DEBT_DOC_DEBTINSTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Debt Document Debt Instrument record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_SO_DOC_HDRs2()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldSO_DOC_HDRs2(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (SO_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Solicitation Document Header record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldSO_DOC_HDRs2();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (SO_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Solicitation Document Header record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToREquip()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToREquip(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_EQUIPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Equipment ID record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToREquip();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_EQUIPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Equipment ID record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_DRSCLSs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_DRSCLSs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DRSCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_DRSCLS/DRSCLS_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_DRSCLSs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DRSCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_DRSCLS/DRSCLS_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_DIVs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_DIVs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DIVImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_DIV/DIV_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_DIVs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DIVImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_DIV/DIV_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToPHMDocLn()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToPHMDocLn(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (PHM_DOC_LINEImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException(" %c:A760,v:Department%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToPHMDocLn();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (PHM_DOC_LINEImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v:Payment Hold By Department%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToInfApBY2()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToInfApBY2(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_APBY2Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:INF_APBY2/FUND_CD] [b:INF_APBY2/UNIT_CD] [b:INF_APBY2/OBJ_CD] Inference record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToInfApBY2();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_APBY2Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:INF_APBY2/FUND_CD] [b:INF_ APBY2/UNIT_CD] [b:INF_APBY2/OBJ_CD] Inference record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToApEdiHdr()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToApEdiHdr(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (AP_EDI_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("Delete Rejected because there are AP_EDI_HDR found for R_DEPT");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToApEdiHdr();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (AP_EDI_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("Update Rejected because there are AP_EDI_HDR found for R_DEPT");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToReimExpAdj()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToReimExpAdj(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_REIM_EXP_ADJImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Reimbursable Expense Adjustment Parameter record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToReimExpAdj();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_REIM_EXP_ADJImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Reimbursable Expense Adjustment Parameter record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_PrgDocCrsRefToDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldPrgDocCrsRefToDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PROG_DOC_CRSREFImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Program Document Cross Reference Record %","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldPrgDocCrsRefToDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PROG_DOC_CRSREFImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Program Document Cross Reference Record %","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_PHASEs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_PHASEs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PHASEImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_PHASE/PHASE_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_PHASEs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PHASEImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_PHASE/PHASE_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_LOCs2()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_LOCs2(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_LOCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_LOC/LOC_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_LOCs2();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_LOCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_LOC/LOC_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRGrntDtDet()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRGrntDtDet(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_GRNT_DT_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Date Definition Template record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRGrntDtDet();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_GRNT_DT_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Date Definition Template Details record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRGrntrEvntSched1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRGrntrEvntSched1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_GRNTR_EVNT_SCHEDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Grant Events Schedule record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRGrntrEvntSched1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_GRNTR_EVNT_SCHEDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Grant Events Schedule record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToFDTOpt()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToFDTOpt(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FDT_OPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Department Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToFDTOpt();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FDT_OPTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_FDT_OPT/DEPT_CD],v:Department Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_DRSRCs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_DRSRCs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DRSRCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_DRSRC/DRSRC_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_DRSRCs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DRSRCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_DRSRC/DRSRC_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_DOCLSs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_DOCLSs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DOCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_DOCLS/DOCLS_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_DOCLSs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DOCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_DOCLS/DOCLS_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RdeptToRcsalCtrlSetp()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRdeptToRcsalCtrlSetp(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_CSAL_CTRL_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Cost Allocation Control Setup%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRdeptToRcsalCtrlSetp();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_CSAL_CTRL_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Cost Allocation Control Setup%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_BUYR_FLINEs2()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_BUYR_FLINEs2(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_BUYR_FLINEImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Buyer [b:R_BUYR_FLINE/FLINE_CD] Line record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_BUYR_FLINEs2();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_BUYR_FLINEImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Buyer [b:R_BUYR_FLINE/FLINE_CD] Line record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToAlwPymntByDebt()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToAlwPymntByDebt(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_ALW_PYMT_DBTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Allow Payment By Debt Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToAlwPymntByDebt();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_ALW_PYMT_DBTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Allow Payment By Debt Record%]","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_GnBudRuleToDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldGnBudRuleToDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (GN_BUD_RULEImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Required Budget record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldGnBudRuleToDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (GN_BUD_RULEImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Required Budget record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_RSTR_USEs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_RSTR_USEs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_RSTR_USEImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Restricted Use record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_RSTR_USEs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_RSTR_USEImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Restricted Use record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_FACCs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_FACCs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FACCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:FA Capitalization Criteria record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_FACCs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FACCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:FA Capitalization Criteria record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_ECRTToDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldECRTToDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_EXTR_CASH_RECTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:External Cash Receipt Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldECRTToDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_EXTR_CASH_RECTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:External Cash Receipt Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_DOGRPs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_DOGRPs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DOGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_DOGRP/DOGRP_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_DOGRPs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DOGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_DOGRP/DOGRP_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToClmtrk()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToClmtrk(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_CLMTRKImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_CLMTRK/ RC_DOC_DEPT_CD] Claims Tracking%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToClmtrk();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_CLMTRKImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD], Claims Tracking%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToCADocHist()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToCADocHist(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_CA_DOC_HISTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_DEPT/DEPT_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToCADocHist();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_CA_DOC_HISTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:CA Document History record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToDisbExcp()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToDisbExcp(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_AP_DISB_EXCPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Intercept Disbursement Exception Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToDisbExcp();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_AP_DISB_EXCPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Intercept Disbursement Exception Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_ACLSs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_ACLSs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_ACLSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_ACLS/ACLS_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_ACLSs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_ACLSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_ACLS/ACLS_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DepartmentToElectronicFederalTaxPaymentSystem()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDepartmentToElectronicFederalTaxPaymentSystem(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (ELEC_FED_TAXP_SYSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Electronic Federal Tax Payment System%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDepartmentToElectronicFederalTaxPaymentSystem();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (ELEC_FED_TAXP_SYSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v:Electronic Federal Tax Payment System%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_ACRL_CLR_MGMT_1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldACRL_CLR_MGMT_1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (ACRL_CLR_MGMTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("Delete Rejected because there are ACRL_CLR_MGMT found for R_DEPT");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldACRL_CLR_MGMT_1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (ACRL_CLR_MGMTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("Update Rejected because there are ACRL_CLR_MGMT found for R_DEPT");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_SECTs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_SECTs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_SECTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_SECT/SECT_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_SECTs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_SECTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_SECT/SECT_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_PrgDocCrsRef1ToDept_1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldPrgDocCrsRef1ToDept_1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PROG_DOC_CRSREFImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Program Document Cross Reference Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldPrgDocCrsRef1ToDept_1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PROG_DOC_CRSREFImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Program Document Cross Reference Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_IntrActgToDept()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldIntrActgToDept(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_INTR_ACTG_CRSWLKImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Interest Accounting Line Crosswalk Table record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldIntrActgToDept();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_INTR_ACTG_CRSWLKImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],Interest Accounting Line Crosswalk Table record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_DOTYPs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_DOTYPs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DOTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_DOTYP/DOTYP_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_DOTYPs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DOTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_DOTYP/DOTYP_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RqstDeptToMaDocHdr()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRqstDeptToMaDocHdr(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (MA_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Master Agreement Document Header record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRqstDeptToMaDocHdr();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (MA_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Requestor Department,v:Master Agreement Document Header record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToInfAppr2()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToInfAppr2(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_APPR2Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:INF_APPR/FUND_CD] [b:INF_APPR2/UNIT_CD] [b:INF_APPR2/OBJ_CD] Inference record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToInfAppr2();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_APPR2Impl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:INF_APPR2/FUND_CD] [b:INF_ APPR2/UNIT_CD] [b:INF_APPR2/OBJ_CD] Inference record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToGRDocHdr()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToGRDocHdr(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (GR_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:General Routing Document Header record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToGRDocHdr();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (GR_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:General Routing Document Header record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToDebtDocAuth()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToDebtDocAuth(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (DEBT_DOC_AUTHImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Debt Document Authorization record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToDebtDocAuth();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (DEBT_DOC_AUTHImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Debt Document Authorization record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToAutoPartNo()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToAutoPartNo(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (AUTO_PART_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Automatic Part Number record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToAutoPartNo();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (AUTO_PART_NOImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Automatic Part Number record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToADHdr()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToADHdr(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (AD_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:AD Header Record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToADHdr();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (AD_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:AD Header Record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RCLS_PARM_DTL1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRCLS_PARM_DTL1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (RCLS_PARM_DTLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Reporting Class Parameter Details record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRCLS_PARM_DTL1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (RCLS_PARM_DTLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Reporting Class Parameter Details record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToVcust()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToVcust(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_VEND_CUSTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:VENDOR CUSTOMER RECORD%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToVcust();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_VEND_CUSTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:VENDOR CUSTOMER RECORD%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToMsmals()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToMsmals(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_MSMALSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Mandatory Source Master Agreement Lines%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToMsmals();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_MSMALSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],Mandatory Source Master Agreement Lines%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRIntCst()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRIntCst(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_INT_CST_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Internal Cost Parameter record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRIntCst();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_INT_CST_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Internal Cost Parameter record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_FUNCs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_FUNCs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FUNCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_FUNC/FUNC_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_FUNCs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FUNCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_FUNC/FUNC_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRFac()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRFac(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FACImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Funding Allocation Control record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRFac();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FACImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Funding  Allocation Control record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToREmpInfo()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToREmpInfo(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_EMP_INFOImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:EMPID record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToREmpInfo();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_EMP_INFOImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:EMPID record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToDeptTrvlxpPol()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToDeptTrvlxpPol(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DEPT_TRVLXP_POLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Department Travel Policy by Expense Type  record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToDeptTrvlxpPol();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DEPT_TRVLXP_POLImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT_TRVLXP_POL/DEPT_CD],v:Department Travel Policy by Expense Type  record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToDebtDebtInst()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToDebtDebtInst(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DEBT_DEBTINSTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Debt Instrument record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToDebtDebtInst();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DEBT_DEBTINSTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Debt Instrument record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRCntrcGlhd()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRCntrcGlhd(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_CNTRC_GOAL_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Department%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRCntrcGlhd();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_CNTRC_GOAL_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v:Contract Goal Header record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_ACRL_CLR_MGMT()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldACRL_CLR_MGMT(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (ACRL_CLR_MGMTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("Delete Rejected because there are ACRL_CLR_MGMT found for R_DEPT");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldACRL_CLR_MGMT();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (ACRL_CLR_MGMTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("Update Rejected because there are ACRL_CLR_MGMT found for R_DEPT");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToABSHdr()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToABSHdr(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (ABS_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("Delete Rejected because there are ABS_DOC_HDR found for R_DEPT");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToABSHdr();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (ABS_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("Update Rejected because there are ABS_DOC_HDR found for R_DEPT");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToTrvlDocVend()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToTrvlDocVend(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (TRVL_DOC_VENDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Travel Document Traveler component%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToTrvlDocVend();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (TRVL_DOC_VENDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Travel Document Traveler component%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_REIM_FREQ_DTs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_REIM_FREQ_DTs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_REIM_FREQ_DTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Reimbursement Frequency Date record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_REIM_FREQ_DTs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_REIM_FREQ_DTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Reimbursement Frequency Date record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_OTPT_PARM_DETs5()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_OTPT_PARM_DETs5(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_OTPT_PARM_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Reimbursement Output Parameter%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_OTPT_PARM_DETs5();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_OTPT_PARM_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A1713,v:[b:R_DEPT/DEPT_CD],v:Reimbursement Output Parameter%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_MGR()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_MGR(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_MGRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Manager record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_MGR();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_MGRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Manager record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_GPs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_GPs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_GPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_GP/GP_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_GPs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_GPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_GP/GP_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToREmplBenMulti()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToREmplBenMulti(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_EMPL_BEN_MULTIImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Employee Benefits Multiplier record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToREmplBenMulti();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_EMPL_BEN_MULTIImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Employee Benefits Multiplier record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_DRSGRPs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_DRSGRPs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DRSGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_DRSGRP/DRSGRP_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_DRSGRPs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DRSGRPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_DRSGRP/DRSGRP_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_DOBJs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_DOBJs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DOBJImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_DOBJ/DOBJ_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_DOBJs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DOBJImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_DOBJ/DOBJ_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_PO_DOC_HDR()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldPO_DOC_HDR(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (PO_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("Delete Rejected because there are PO_DOC_HDR found for R_DEPT");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldPO_DOC_HDR();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (PO_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A1571,v:Requesting Dept.%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptVcPrvnt()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptVcPrvnt(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (VCC_DOC_PRVNTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("Delete Rejected because there are VCC_DOC_PRVNT found for R_DEPT");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptVcPrvnt();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (VCC_DOC_PRVNTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("Update Rejected because there are VCC_DOC_PRVNT found for R_DEPT");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_PROG_GIS_LOC()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_PROG_GIS_LOC(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PROG_GIS_LOCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Program GIS Location (PGL) record that references that Department code%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_PROG_GIS_LOC();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PROG_GIS_LOCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Program GIS Location (PGL) record that references that Department code.%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToPartTyp()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToPartTyp(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PART_TYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Part Type record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToPartTyp();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PART_TYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Part Type record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_LCATs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_LCATs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_LCATImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_LCAT/LCAT_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_LCATs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_LCATImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_LCAT/LCAT_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRGrntAlrtUser()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRGrntAlrtUser(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_GRNT_ALRT_USERImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_GRNT_ALRT_USER/GRNT_USER_ID] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRGrntAlrtUser();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_GRNT_ALRT_USERImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_GRNT_ALRT_USER/GRNT_USER_ID] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRFndgGrp()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRFndgGrp(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FNDG_GRPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Funding Group record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRFndgGrp();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FNDG_GRPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Funding Group record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToRFgc()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToRFgc(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FGCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Funding Group Control record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToRFgc();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FGCImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Funding Group Control record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToFarHdr()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToFarHdr(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FAR_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:FAR Header record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToFarHdr();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FAR_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:FAR Header record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_DRSTYPs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_DRSTYPs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DRSTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_DRSTYP/DRSTYP_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_DRSTYPs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DRSTYPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_DRSTYP/DRSTYP_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_DRSCATs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_DRSCATs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DRSCATImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_DRSCAT/DRSCAT_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_DRSCATs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DRSCATImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_DRSCAT/DRSCAT_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_ACTVs6()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_ACTVs6(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_ACTVImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_ACTV/ACTV_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_ACTVs6();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_ACTVImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_ACTV/ACTV_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToPoSrtyIns()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToPoSrtyIns(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (PO_DOC_SRTYINSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Purchase Order Document Surety Insurance record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToPoSrtyIns();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (PO_DOC_SRTYINSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Holding Department,v:Purchase Order Document Surety Insurance record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDptToROnPrnParmDflt()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDptToROnPrnParmDflt(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (ONLN_PRN_PARM_DFLTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Online Printing Parameters Default Reference Table record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDptToROnPrnParmDflt();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (ONLN_PRN_PARM_DFLTImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Online Printing Parameters Default Reference Table record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToInfApBY()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToInfApBY(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (INF_APBYImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:INF_APBY/FUND_CD] [b:INF_APBY/UNIT_CD] [b:INF_APBY/OBJ_CD] Inference record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToInfApBY();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (INF_APBYImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:INF_APBY/FUND_CD] [b:INF_APBY/UNIT_CD] [b:INF_APBY/OBJ_CD] Inference record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDeptToGtDocAlrtuser()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDeptToGtDocAlrtuser(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (GT_DOC_ALRTUSERImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:GT_DOC_ALRTUSER/GRNT_USER_ID] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDeptToGtDocAlrtuser();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (GT_DOC_ALRTUSERImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:GT_DOC_ALRTUSER/GRNT_USER_ID] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_FA_DOC_HDRs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldFA_DOC_HDRs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (FA_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:FA Header record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldFA_DOC_HDRs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (FA_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:FA Header record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToARRADocOngoing()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToARRADocOngoing(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (ARRA_DOC_ONGOINGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:ARRA Document Ongoing record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToARRADocOngoing();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (ARRA_DOC_ONGOINGImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:ARRA Document Ongoing record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DepartmentToSubRcpntQtrlyAwd()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDepartmentToSubRcpntQtrlyAwd(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_SRCPNT_QTRLY_AWDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Sub-Recipient Quarterly Award Information record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDepartmentToSubRcpntQtrlyAwd();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_SRCPNT_QTRLY_AWDImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Sub-Recipient Quarterly Award Information record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RdeptToRplbsSetp()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRdeptToRplbsSetp(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_PLBS_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Pool/Base Setup%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRdeptToRplbsSetp();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_PLBS_SETPImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Pool/Base Setup%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_OTPT_PARM_DETs4()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_OTPT_PARM_DETs4(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_OTPT_PARM_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Reimbursement Output Parameter%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_OTPT_PARM_DETs4();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_OTPT_PARM_DETImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A1713,v:[b:R_DEPT/DEPT_CD],v:Reimbursement Output Parameter%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RIntCstOtMultiToRDept1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRIntCstOtMultiToRDept1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_INT_CST_OT_MULTIImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:ICOM record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRIntCstOtMultiToRDept1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_INT_CST_OT_MULTIImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:ICOM record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_FNCLSs1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_FNCLSs1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_FNCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:[b:R_FNCLS/FNCLS_CD] record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_FNCLSs1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_FNCLSImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:[b:R_FNCLS/FNCLS_CD] record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_DISB_MGMT_RSTR_1()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_DISB_MGMT_RSTR_1(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DISB_MGMT_RSTRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Department%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_DISB_MGMT_RSTR_1();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DISB_MGMT_RSTRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v:Disbursement Hold Exclusion record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_DISB_MGMT_RSTR()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_DISB_MGMT_RSTR(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_DISB_MGMT_RSTRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Department%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_DISB_MGMT_RSTR();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_DISB_MGMT_RSTRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:Department,v:Disbursement Hold Exclusion record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_R_CMIA_INTR_PARMs()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldR_CMIA_INTR_PARMs(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_CMIA_INTR_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:CMIA Interest Parameter%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldR_CMIA_INTR_PARMs();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_CMIA_INTR_PARMImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A1713,v:[b:R_DEPT/DEPT_CD],v:CMIA Interest Parameter%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_RDept_RBfyStpfRev()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldRDept_RBfyStpfRev(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (R_BFY_STPF_REVImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:Budget Fiscal Year Staging Profile Revenue Line%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldRDept_RBfyStpfRev();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (R_BFY_STPF_REVImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:Budget Fiscal Year Staging Profile Revenue Line%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }
   protected void childCascadeFor_DeptToIctDocActg()
   {
      IVSTrace tr = null;  long tr_id = 0;
      boolean PKeyChanged = false;
      boolean ReplChanged = false;
      Enumeration   children;
      // First find out if the Primary key has changed.
      if (( isUpdated() == true ) &&
      ( (isChanged("DEPT_CD")) ))
         PKeyChanged = true;
      else
         PKeyChanged = false;
   

      // Now do the Cascade.
      if ( isDeleted() )
      {
         // no need to load all children into cache for a delete
         children = getOldDeptToIctDocActg(false);

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }

         if ( children.hasMoreElements() ) // There are children found
         {
               //Skip the RI Checking for Timeline Data Objects 
               // AMS BEGIN : TIMELINE
               if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                     (ICT_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
               // AMS END : TIMELINE
               {
                        raiseException("%c:A760,v:ICT DOC record%","R_DEPT","DEPT_CD");
               }
         }
      }
      else if ( PKeyChanged || ReplChanged )
      {
         children = getOldDeptToIctDocActg();

         // Check to see if children should be sorted
         if ( mboolChildCascadeSorted )
         {
            if ( children.hasMoreElements() ) // There are children to sort
            {
               Vector lvChildren = new Vector() ;

               while ( children.hasMoreElements() )
               {
                  lvChildren.addElement((AMSDataObject)children.nextElement() ) ;
               }

               // Get cascade sort criteria from the child
               Vector lvSortAttr = ((AMSDataObject)lvChildren.firstElement()).getChildCascadeSortCriteria((AMSDataObject)this ) ;
               try
               {
                  lvChildren = AMSDataObject.sort( lvChildren, 
                              lvSortAttr, 
                              miChildCascadeSortedOrder ) ;
                  children = lvChildren.elements() ; 
               }
               catch ( Exception ex )
               {
                  raiseException( "Error while sorting children", 
                        AMSMsgUtil.SEVERITY_LEVEL_SEVERE ) ;
                  ex.printStackTrace() ;
               }
            }
         }


         if ( children.hasMoreElements() ) // There are children found
         {
               // This is the case for an Update.
 
                  if (PKeyChanged)   
                  {
                     // AMS BEGIN : TIMELINE
                     if( !((isBehaviorEnabled(AMSBEHAVIOR_TIMELINE)) &&  
                           (ICT_DOC_HDRImpl.isBehaviorEnabled(AMSBEHAVIOR_TIMELINE))) )
                     // AMS END : TIMELINE                     
                     {
                           raiseException("%c:A759,v:[b:R_DEPT/DEPT_CD],v:ICT DOC record%","R_DEPT","DEPT_CD");
                     }
                  }
            
         }
      }
   

   }

   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptCAToARRADocOngoing()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("CA_DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"ARRA_DOC_ONGOING","DeptCAToARRADocOngoing", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToCAMMjrProgDoc()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"CAM_DOC_MJRPROG","DeptToCAMMjrProgDoc", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToCASMjrProgDoc()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"CAS_DOC_MJRPROG","DeptToCASMjrProgDoc", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_CVEX_FUND_DEPTs()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"CVEX_FUND_DEPT","CVEX_FUND_DEPTs", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_CVIN_FUND_DEPTs()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"CVIN_FUND_DEPT","CVIN_FUND_DEPTs", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToCvinStru45L3Req()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"CVIN_STRU45L3_REQ","DeptToCvinStru45L3Req", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToUnitProg()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"CVIN_UNIT_PROG","DeptToUnitProg", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DOC_COAs28()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_ACT_FL");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("ACT_FL");         
         return preventParentReplicatePush(getSession(),childAttrList,"DOC_COA","DOC_COAs28", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptDocIntCoa()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("IG_DEPT_ACT_FL");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("ACT_FL");         
         return preventParentReplicatePush(getSession(),childAttrList,"DOC_INT_COA","DeptDocIntCoa", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_RDeptToGtDocComn()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"GT_DOC_COMN","RDeptToGtDocComn", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToGtDocNotifUsr()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"GT_DOC_NOTIFUSR","DeptToGtDocNotifUsr", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToGtDocOpty()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"GT_DOC_OPTY","DeptToGtDocOpty", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToGtDocResp()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"GT_DOC_RESP","DeptToGtDocResp", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToInfApprFuncOtyp()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_SH_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_SH_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_APPR_FUNC_OTYP","DeptToInfApprFuncOtyp", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_RsrcApprInfRecs()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_APPR_RSRC","RsrcApprInfRecs", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_INF_BFYs1()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_BFY","INF_BFYs1", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_InfDeptUnitToDept()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_DEPT_UNIT","InfDeptUnitToDept", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToInfFpi6()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_FPI_6","DeptToInfFpi6", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_INF_FPRL_12()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_FPRL_1","INF_FPRL_12", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_INF_FPRL_21()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_FPRL_2","INF_FPRL_21", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_INF_FPRL_32()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_FPRL_3","INF_FPRL_32", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_InfFprfl4Recs()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_FPRL_4","InfFprfl4Recs", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToInfFprl5()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_SH_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_SH_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_FPRL_5","DeptToInfFprl5", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_RDeptToInfFprlO()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_FPRL_O","RDeptToInfFprlO", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToInfFprlActToLcn()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_FPRL_ACTV_LOC","DeptToInfFprlActToLcn", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToInfFuncFundProg()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_SH_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_SH_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_FUNC_FUND_PROG","DeptToInfFuncFundProg", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_INF_FUND_FUNC_ACTVs1()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_FUND_FUNC_ACTV","INF_FUND_FUNC_ACTVs1", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_GFPIToDept()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_SH_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_SH_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_GRNT_FP","GFPIToDept", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_InfObjOtypToDept()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_SH_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_SH_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_OBJ_OTYP","InfObjOtypToDept", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_INF_PHASE_PROGs()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_PHASE_PROG","INF_PHASE_PROGs", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_PFPIToDept()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_SH_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_SH_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_PROJ_FP","PFPIToDept", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_RevSrcInfToDept()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_REV_SRC","RevSrcInfToDept", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToInfUnit()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_SH_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_SH_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"INF_UNIT","DeptToInfUnit", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_R_ACTG_TMPLs()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("SECU_DEPT_SH_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_SH_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_ACTG_TMPL","R_ACTG_TMPLs", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToStructDept()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_ALT_ORG_STRUCT","DeptToStructDept", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToApCwHdr()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("CW_DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_SH_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_AP_CW_HDR","DeptToApCwHdr", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_RDeptToRApdDept()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_APD_DEPT","RDeptToRApdDept", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToCitedAuth()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DOC_DEPT_SH_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_SH_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_CITED_AUTH","DeptToCitedAuth", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_R_COMM_FA_THLDs1()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_COMM_FA_THLD","R_COMM_FA_THLDs1", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_R_COMM_OBJs1()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_COMM_OBJ","R_COMM_OBJs1", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToDeptFY()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_DEPT_FY","DeptToDeptFY", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_RDeptToRDeptObjPymtCtrl()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_DEPT_OBJ_PYCTRL","RDeptToRDeptObjPymtCtrl", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToDISCIV()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DOC_DEPT_SH_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_SH_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_DISCIV","DeptToDISCIV", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToDrwdwnGrp()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DRWDWN_DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_DRWDWN_GRP","DeptToDrwdwnGrp", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToEscrowDef()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_ESCROW_DEF","DeptToEscrowDef", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_RDeptToRFesReq()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_FESREQ","RDeptToRFesReq", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_RDeptToRFyDept()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_FY_DEPT","RDeptToRFyDept", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_RDeptToRGrntAppl()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_GRNT_APPL","RDeptToRGrntAppl", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToGrntOpty()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_GRNT_OPTY","DeptToGrntOpty", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToGrntResp()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_GRNT_RESP","DeptToGrntResp", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToGrntUser()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_GRNT_USER","DeptToGrntUser", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_R_INTG_CTRL()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_INTG_CTRL","R_INTG_CTRL", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_R_MJR_PROGs3()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_MJR_PROG","R_MJR_PROGs3", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DepartmentToOnGoingAwardInfo()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("CA_DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_ONGOING_AWD_INFO","DepartmentToOnGoingAwardInfo", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_StateInstances()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_PRCU_ST","StateInstances", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_R_STPF()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_STPF","R_STPF", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_UniversalRequestorControls()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_SH_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_SH_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_UR_CTRL","UniversalRequestorControls", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_UserGrpTmplToDept()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_USER_GRP_TMPL","UserGrpTmplToDept", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_R_VEND_LSTs2()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"R_VEND_LST","R_VEND_LSTs2", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_REQ_ACTV_SACTVs()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"REQ_ACTV_SACTV","REQ_ACTV_SACTVs", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_REQ_DEPT_OBJ_REVs()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"REQ_DEPT_OBJ_REV","REQ_DEPT_OBJ_REVs", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_ReqFundDeptToRDept()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"REQ_FUND_DEPT","ReqFundDeptToRDept", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_REQ_FUND_UNIT_OBJs()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"REQ_FUND_UNIT_OBJ","REQ_FUND_UNIT_OBJs", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_REQ_FUND_UNIT_RSRCs()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"REQ_FUND_UNIT_RSRC","REQ_FUND_UNIT_RSRCs", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_REQ_UNITs()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"REQ_UNIT","REQ_UNITs", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_DeptToReqUnitProg()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"REQ_UNIT_PROG","DeptToReqUnitProg", "R_DEPT",parentAttrList);
       
   }
   /**     
    * Returns true to indicate that the logic to fetch children Dataobjects to update replicated value
    * on their non-persistent attributes should be skipped. For complete details search for keyword
    * PARENT_REPLICATE_SKIP_LOGIC on AMSDataObject java file and read
    * the associated documentation.
    * @return boolean 
    */
   protected boolean preventReplicatePushFor_REQ_UNIT_SUNITs()
         throws Exception
   {
         ArrayList<String> childAttrList = new ArrayList<String>();                 
         childAttrList.add("DEPT_NM");         
         ArrayList<String> parentAttrList = new ArrayList<String>();                 
         parentAttrList.add("DEPT_NM");         
         return preventParentReplicatePush(getSession(),childAttrList,"REQ_UNIT_SUNIT","REQ_UNIT_SUNITs", "R_DEPT",parentAttrList);
       
   }





   
   
   
   
   
   
   

   protected void codeTableCheck(String colName)
   {
      DataObject   codeTablObj = null;
      Parameter param = null;
      SearchRequest searchReq = new SearchRequest();
         if ( colName.equals("REST_BUYR_UNIT") && isChanged("REST_BUYR_UNIT") ) 
         {
            // Try to get see if the value exists in the code table
            param = new Parameter();
            param.objName = "CVL_REST_BUYR_UNIT";
            param.fieldName = "REST_BUYR_UNIT_SV";
            param.value = getData(miREST_BUYR_UNIT).getString();
            searchReq.add(param);
            codeTablObj = CVL_REST_BUYR_UNITBaseImpl.getObjectByKey(searchReq ,getSession());
            if ( codeTablObj == null ) // Code table not found
            {
               
               raiseException("Invalid value in 'REST_BUYR_UNIT'.","R_DEPT","REST_BUYR_UNIT");
            }
            
         }
         if ( colName.equals("AR_UNIT_INFR") && isChanged("AR_UNIT_INFR") ) 
         {
            // Try to get see if the value exists in the code table
            param = new Parameter();
            param.objName = "CVL_INFR_DP_UN";
            param.fieldName = "CVL_INFR_DP_UN_SV";
            param.value = getData(miAR_UNIT_INFR).getString();
            searchReq.add(param);
            codeTablObj = CVL_INFR_DP_UNBaseImpl.getObjectByKey(searchReq ,getSession());
            if ( codeTablObj == null ) // Code table not found
            {
               
               raiseException("Invalid value in 'AR_UNIT_INFR'.","R_DEPT","AR_UNIT_INFR");
            }
            
         }
   }
   

   
   
      private ObjectHashtable DeptCAToARRADocOngoingCache = null;
        
      /**     
      * <br>
      * method to retrieve the ARRA_DOC_ONGOING objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of ARRA_DOC_ONGOING objects.
      */
      public Enumeration getDeptCAToARRADocOngoing()
      {
      
         if (getSession().getProperty("CacheDeptCAToARRADocOngoing").equals("true"))
      
         {
            if ( DeptCAToARRADocOngoingCache != null ) return DeptCAToARRADocOngoingCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ARRA_DOC_ONGOING";
            param.fieldName = "CA_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptCAToARRADocOngoing").equals("true"))
         {
            DeptCAToARRADocOngoingCache = new ObjectHashtable();
            for (Enumeration e = (ARRA_DOC_ONGOINGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptCAToARRADocOngoingCache.put(pkey,cacheBO);                        
            }
         
            return (DeptCAToARRADocOngoingCache.elements());
         }
         else
         {
            return (ARRA_DOC_ONGOINGBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToCAMMjrProgDocCache = null;
        
      /**     
      * <br>
      * method to retrieve the CAM_DOC_MJRPROG objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of CAM_DOC_MJRPROG objects.
      */
      public Enumeration getDeptToCAMMjrProgDoc()
      {
      
         if (getSession().getProperty("CacheDeptToCAMMjrProgDoc").equals("true"))
      
         {
            if ( DeptToCAMMjrProgDocCache != null ) return DeptToCAMMjrProgDocCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CAM_DOC_MJRPROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCAMMjrProgDoc").equals("true"))
         {
            DeptToCAMMjrProgDocCache = new ObjectHashtable();
            for (Enumeration e = (CAM_DOC_MJRPROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCAMMjrProgDocCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCAMMjrProgDocCache.elements());
         }
         else
         {
            return (CAM_DOC_MJRPROGBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToCASMjrProgDocCache = null;
        
      /**     
      * <br>
      * method to retrieve the CAS_DOC_MJRPROG objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of CAS_DOC_MJRPROG objects.
      */
      public Enumeration getDeptToCASMjrProgDoc()
      {
      
         if (getSession().getProperty("CacheDeptToCASMjrProgDoc").equals("true"))
      
         {
            if ( DeptToCASMjrProgDocCache != null ) return DeptToCASMjrProgDocCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CAS_DOC_MJRPROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCASMjrProgDoc").equals("true"))
         {
            DeptToCASMjrProgDocCache = new ObjectHashtable();
            for (Enumeration e = (CAS_DOC_MJRPROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCASMjrProgDocCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCASMjrProgDocCache.elements());
         }
         else
         {
            return (CAS_DOC_MJRPROGBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable CVEX_FUND_DEPTsCache = null;
        
      /**     
      * <br>
      * method to retrieve the CVEX_FUND_DEPT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of CVEX_FUND_DEPT objects.
      */
      public Enumeration getCVEX_FUND_DEPTs()
      {
      
         if (getSession().getProperty("CacheCVEX_FUND_DEPTs").equals("true"))
      
         {
            if ( CVEX_FUND_DEPTsCache != null ) return CVEX_FUND_DEPTsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CVEX_FUND_DEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheCVEX_FUND_DEPTs").equals("true"))
         {
            CVEX_FUND_DEPTsCache = new ObjectHashtable();
            for (Enumeration e = (CVEX_FUND_DEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               CVEX_FUND_DEPTsCache.put(pkey,cacheBO);                        
            }
         
            return (CVEX_FUND_DEPTsCache.elements());
         }
         else
         {
            return (CVEX_FUND_DEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable CVIN_FUND_DEPTsCache = null;
        
      /**     
      * <br>
      * method to retrieve the CVIN_FUND_DEPT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of CVIN_FUND_DEPT objects.
      */
      public Enumeration getCVIN_FUND_DEPTs()
      {
      
         if (getSession().getProperty("CacheCVIN_FUND_DEPTs").equals("true"))
      
         {
            if ( CVIN_FUND_DEPTsCache != null ) return CVIN_FUND_DEPTsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CVIN_FUND_DEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheCVIN_FUND_DEPTs").equals("true"))
         {
            CVIN_FUND_DEPTsCache = new ObjectHashtable();
            for (Enumeration e = (CVIN_FUND_DEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               CVIN_FUND_DEPTsCache.put(pkey,cacheBO);                        
            }
         
            return (CVIN_FUND_DEPTsCache.elements());
         }
         else
         {
            return (CVIN_FUND_DEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToCvinStru44L3ReqCache = null;
        
      /**     
      * <br>
      * method to retrieve the CVIN_STRU44L3_REQ objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of CVIN_STRU44L3_REQ objects.
      */
      public Enumeration getRDeptToCvinStru44L3Req()
      {
      
         if (getSession().getProperty("CacheRDeptToCvinStru44L3Req").equals("true"))
      
         {
            if ( RDeptToCvinStru44L3ReqCache != null ) return RDeptToCvinStru44L3ReqCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CVIN_STRU44L3_REQ";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToCvinStru44L3Req").equals("true"))
         {
            RDeptToCvinStru44L3ReqCache = new ObjectHashtable();
            for (Enumeration e = (CVIN_STRU44L3_REQBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToCvinStru44L3ReqCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToCvinStru44L3ReqCache.elements());
         }
         else
         {
            return (CVIN_STRU44L3_REQBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToCvinStru45L3ReqCache = null;
        
      /**     
      * <br>
      * method to retrieve the CVIN_STRU45L3_REQ objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of CVIN_STRU45L3_REQ objects.
      */
      public Enumeration getDeptToCvinStru45L3Req()
      {
      
         if (getSession().getProperty("CacheDeptToCvinStru45L3Req").equals("true"))
      
         {
            if ( DeptToCvinStru45L3ReqCache != null ) return DeptToCvinStru45L3ReqCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CVIN_STRU45L3_REQ";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCvinStru45L3Req").equals("true"))
         {
            DeptToCvinStru45L3ReqCache = new ObjectHashtable();
            for (Enumeration e = (CVIN_STRU45L3_REQBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCvinStru45L3ReqCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCvinStru45L3ReqCache.elements());
         }
         else
         {
            return (CVIN_STRU45L3_REQBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToUnitProgCache = null;
        
      /**     
      * <br>
      * method to retrieve the CVIN_UNIT_PROG objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of CVIN_UNIT_PROG objects.
      */
      public Enumeration getDeptToUnitProg()
      {
      
         if (getSession().getProperty("CacheDeptToUnitProg").equals("true"))
      
         {
            if ( DeptToUnitProgCache != null ) return DeptToUnitProgCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CVIN_UNIT_PROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToUnitProg").equals("true"))
         {
            DeptToUnitProgCache = new ObjectHashtable();
            for (Enumeration e = (CVIN_UNIT_PROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToUnitProgCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToUnitProgCache.elements());
         }
         else
         {
            return (CVIN_UNIT_PROGBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DOC_COAs28Cache = null;
        
      /**     
      * <br>
      * method to retrieve the DOC_COA objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of DOC_COA objects.
      */
      public Enumeration getDOC_COAs28()
      {
      
         if (getSession().getProperty("CacheDOC_COAs28").equals("true"))
      
         {
            if ( DOC_COAs28Cache != null ) return DOC_COAs28Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "DOC_COA";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDOC_COAs28").equals("true"))
         {
            DOC_COAs28Cache = new ObjectHashtable();
            for (Enumeration e = (DOC_COABaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DOC_COAs28Cache.put(pkey,cacheBO);                        
            }
         
            return (DOC_COAs28Cache.elements());
         }
         else
         {
            return (DOC_COABaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptDocIntCoaCache = null;
        
      /**     
      * <br>
      * method to retrieve the DOC_INT_COA objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of DOC_INT_COA objects.
      */
      public Enumeration getDeptDocIntCoa()
      {
      
         if (getSession().getProperty("CacheDeptDocIntCoa").equals("true"))
      
         {
            if ( DeptDocIntCoaCache != null ) return DeptDocIntCoaCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "DOC_INT_COA";
            param.fieldName = "IG_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptDocIntCoa").equals("true"))
         {
            DeptDocIntCoaCache = new ObjectHashtable();
            for (Enumeration e = (DOC_INT_COABaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptDocIntCoaCache.put(pkey,cacheBO);                        
            }
         
            return (DeptDocIntCoaCache.elements());
         }
         else
         {
            return (DOC_INT_COABaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToGtDocComnCache = null;
        
      /**     
      * <br>
      * method to retrieve the GT_DOC_COMN objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of GT_DOC_COMN objects.
      */
      public Enumeration getRDeptToGtDocComn()
      {
      
         if (getSession().getProperty("CacheRDeptToGtDocComn").equals("true"))
      
         {
            if ( RDeptToGtDocComnCache != null ) return RDeptToGtDocComnCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_COMN";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToGtDocComn").equals("true"))
         {
            RDeptToGtDocComnCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_COMNBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToGtDocComnCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToGtDocComnCache.elements());
         }
         else
         {
            return (GT_DOC_COMNBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToGtDocNotifUsrCache = null;
        
      /**     
      * <br>
      * method to retrieve the GT_DOC_NOTIFUSR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of GT_DOC_NOTIFUSR objects.
      */
      public Enumeration getDeptToGtDocNotifUsr()
      {
      
         if (getSession().getProperty("CacheDeptToGtDocNotifUsr").equals("true"))
      
         {
            if ( DeptToGtDocNotifUsrCache != null ) return DeptToGtDocNotifUsrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_NOTIFUSR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGtDocNotifUsr").equals("true"))
         {
            DeptToGtDocNotifUsrCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_NOTIFUSRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGtDocNotifUsrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGtDocNotifUsrCache.elements());
         }
         else
         {
            return (GT_DOC_NOTIFUSRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToGtDocOptyCache = null;
        
      /**     
      * <br>
      * method to retrieve the GT_DOC_OPTY objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of GT_DOC_OPTY objects.
      */
      public Enumeration getDeptToGtDocOpty()
      {
      
         if (getSession().getProperty("CacheDeptToGtDocOpty").equals("true"))
      
         {
            if ( DeptToGtDocOptyCache != null ) return DeptToGtDocOptyCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_OPTY";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGtDocOpty").equals("true"))
         {
            DeptToGtDocOptyCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_OPTYBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGtDocOptyCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGtDocOptyCache.elements());
         }
         else
         {
            return (GT_DOC_OPTYBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToGtDocRespCache = null;
        
      /**     
      * <br>
      * method to retrieve the GT_DOC_RESP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of GT_DOC_RESP objects.
      */
      public Enumeration getDeptToGtDocResp()
      {
      
         if (getSession().getProperty("CacheDeptToGtDocResp").equals("true"))
      
         {
            if ( DeptToGtDocRespCache != null ) return DeptToGtDocRespCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_RESP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGtDocResp").equals("true"))
         {
            DeptToGtDocRespCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_RESPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGtDocRespCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGtDocRespCache.elements());
         }
         else
         {
            return (GT_DOC_RESPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToInfApprFuncOtypCache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_APPR_FUNC_OTYP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_APPR_FUNC_OTYP objects.
      */
      public Enumeration getDeptToInfApprFuncOtyp()
      {
      
         if (getSession().getProperty("CacheDeptToInfApprFuncOtyp").equals("true"))
      
         {
            if ( DeptToInfApprFuncOtypCache != null ) return DeptToInfApprFuncOtypCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_APPR_FUNC_OTYP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfApprFuncOtyp").equals("true"))
         {
            DeptToInfApprFuncOtypCache = new ObjectHashtable();
            for (Enumeration e = (INF_APPR_FUNC_OTYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfApprFuncOtypCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfApprFuncOtypCache.elements());
         }
         else
         {
            return (INF_APPR_FUNC_OTYPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RsrcApprInfRecsCache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_APPR_RSRC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_APPR_RSRC objects.
      */
      public Enumeration getRsrcApprInfRecs()
      {
      
         if (getSession().getProperty("CacheRsrcApprInfRecs").equals("true"))
      
         {
            if ( RsrcApprInfRecsCache != null ) return RsrcApprInfRecsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_APPR_RSRC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRsrcApprInfRecs").equals("true"))
         {
            RsrcApprInfRecsCache = new ObjectHashtable();
            for (Enumeration e = (INF_APPR_RSRCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RsrcApprInfRecsCache.put(pkey,cacheBO);                        
            }
         
            return (RsrcApprInfRecsCache.elements());
         }
         else
         {
            return (INF_APPR_RSRCBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable INF_BFYs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_BFY objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_BFY objects.
      */
      public Enumeration getINF_BFYs1()
      {
      
         if (getSession().getProperty("CacheINF_BFYs1").equals("true"))
      
         {
            if ( INF_BFYs1Cache != null ) return INF_BFYs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_BFY";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheINF_BFYs1").equals("true"))
         {
            INF_BFYs1Cache = new ObjectHashtable();
            for (Enumeration e = (INF_BFYBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               INF_BFYs1Cache.put(pkey,cacheBO);                        
            }
         
            return (INF_BFYs1Cache.elements());
         }
         else
         {
            return (INF_BFYBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable InfDeptUnitToDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_DEPT_UNIT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_DEPT_UNIT objects.
      */
      public Enumeration getInfDeptUnitToDept()
      {
      
         if (getSession().getProperty("CacheInfDeptUnitToDept").equals("true"))
      
         {
            if ( InfDeptUnitToDeptCache != null ) return InfDeptUnitToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_DEPT_UNIT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheInfDeptUnitToDept").equals("true"))
         {
            InfDeptUnitToDeptCache = new ObjectHashtable();
            for (Enumeration e = (INF_DEPT_UNITBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               InfDeptUnitToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (InfDeptUnitToDeptCache.elements());
         }
         else
         {
            return (INF_DEPT_UNITBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToInfFpi6Cache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_FPI_6 objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_FPI_6 objects.
      */
      public Enumeration getDeptToInfFpi6()
      {
      
         if (getSession().getProperty("CacheDeptToInfFpi6").equals("true"))
      
         {
            if ( DeptToInfFpi6Cache != null ) return DeptToInfFpi6Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPI_6";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfFpi6").equals("true"))
         {
            DeptToInfFpi6Cache = new ObjectHashtable();
            for (Enumeration e = (INF_FPI_6BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfFpi6Cache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfFpi6Cache.elements());
         }
         else
         {
            return (INF_FPI_6BaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable INF_FPRL_12Cache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_FPRL_1 objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_FPRL_1 objects.
      */
      public Enumeration getINF_FPRL_12()
      {
      
         if (getSession().getProperty("CacheINF_FPRL_12").equals("true"))
      
         {
            if ( INF_FPRL_12Cache != null ) return INF_FPRL_12Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPRL_1";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheINF_FPRL_12").equals("true"))
         {
            INF_FPRL_12Cache = new ObjectHashtable();
            for (Enumeration e = (INF_FPRL_1BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               INF_FPRL_12Cache.put(pkey,cacheBO);                        
            }
         
            return (INF_FPRL_12Cache.elements());
         }
         else
         {
            return (INF_FPRL_1BaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable INF_FPRL_21Cache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_FPRL_2 objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_FPRL_2 objects.
      */
      public Enumeration getINF_FPRL_21()
      {
      
         if (getSession().getProperty("CacheINF_FPRL_21").equals("true"))
      
         {
            if ( INF_FPRL_21Cache != null ) return INF_FPRL_21Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPRL_2";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheINF_FPRL_21").equals("true"))
         {
            INF_FPRL_21Cache = new ObjectHashtable();
            for (Enumeration e = (INF_FPRL_2BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               INF_FPRL_21Cache.put(pkey,cacheBO);                        
            }
         
            return (INF_FPRL_21Cache.elements());
         }
         else
         {
            return (INF_FPRL_2BaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable INF_FPRL_32Cache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_FPRL_3 objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_FPRL_3 objects.
      */
      public Enumeration getINF_FPRL_32()
      {
      
         if (getSession().getProperty("CacheINF_FPRL_32").equals("true"))
      
         {
            if ( INF_FPRL_32Cache != null ) return INF_FPRL_32Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPRL_3";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheINF_FPRL_32").equals("true"))
         {
            INF_FPRL_32Cache = new ObjectHashtable();
            for (Enumeration e = (INF_FPRL_3BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               INF_FPRL_32Cache.put(pkey,cacheBO);                        
            }
         
            return (INF_FPRL_32Cache.elements());
         }
         else
         {
            return (INF_FPRL_3BaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable InfFprfl4RecsCache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_FPRL_4 objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_FPRL_4 objects.
      */
      public Enumeration getInfFprfl4Recs()
      {
      
         if (getSession().getProperty("CacheInfFprfl4Recs").equals("true"))
      
         {
            if ( InfFprfl4RecsCache != null ) return InfFprfl4RecsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPRL_4";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheInfFprfl4Recs").equals("true"))
         {
            InfFprfl4RecsCache = new ObjectHashtable();
            for (Enumeration e = (INF_FPRL_4BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               InfFprfl4RecsCache.put(pkey,cacheBO);                        
            }
         
            return (InfFprfl4RecsCache.elements());
         }
         else
         {
            return (INF_FPRL_4BaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToInfFprl5Cache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_FPRL_5 objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_FPRL_5 objects.
      */
      public Enumeration getDeptToInfFprl5()
      {
      
         if (getSession().getProperty("CacheDeptToInfFprl5").equals("true"))
      
         {
            if ( DeptToInfFprl5Cache != null ) return DeptToInfFprl5Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPRL_5";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfFprl5").equals("true"))
         {
            DeptToInfFprl5Cache = new ObjectHashtable();
            for (Enumeration e = (INF_FPRL_5BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfFprl5Cache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfFprl5Cache.elements());
         }
         else
         {
            return (INF_FPRL_5BaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToInfFprlOCache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_FPRL_O objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_FPRL_O objects.
      */
      public Enumeration getRDeptToInfFprlO()
      {
      
         if (getSession().getProperty("CacheRDeptToInfFprlO").equals("true"))
      
         {
            if ( RDeptToInfFprlOCache != null ) return RDeptToInfFprlOCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPRL_O";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToInfFprlO").equals("true"))
         {
            RDeptToInfFprlOCache = new ObjectHashtable();
            for (Enumeration e = (INF_FPRL_OBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToInfFprlOCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToInfFprlOCache.elements());
         }
         else
         {
            return (INF_FPRL_OBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToInfFprlActToLcnCache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_FPRL_ACTV_LOC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_FPRL_ACTV_LOC objects.
      */
      public Enumeration getDeptToInfFprlActToLcn()
      {
      
         if (getSession().getProperty("CacheDeptToInfFprlActToLcn").equals("true"))
      
         {
            if ( DeptToInfFprlActToLcnCache != null ) return DeptToInfFprlActToLcnCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPRL_ACTV_LOC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfFprlActToLcn").equals("true"))
         {
            DeptToInfFprlActToLcnCache = new ObjectHashtable();
            for (Enumeration e = (INF_FPRL_ACTV_LOCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfFprlActToLcnCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfFprlActToLcnCache.elements());
         }
         else
         {
            return (INF_FPRL_ACTV_LOCBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToInfFuncFundProgCache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_FUNC_FUND_PROG objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_FUNC_FUND_PROG objects.
      */
      public Enumeration getDeptToInfFuncFundProg()
      {
      
         if (getSession().getProperty("CacheDeptToInfFuncFundProg").equals("true"))
      
         {
            if ( DeptToInfFuncFundProgCache != null ) return DeptToInfFuncFundProgCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FUNC_FUND_PROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfFuncFundProg").equals("true"))
         {
            DeptToInfFuncFundProgCache = new ObjectHashtable();
            for (Enumeration e = (INF_FUNC_FUND_PROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfFuncFundProgCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfFuncFundProgCache.elements());
         }
         else
         {
            return (INF_FUNC_FUND_PROGBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable INF_FUND_FUNC_ACTVs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_FUND_FUNC_ACTV objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_FUND_FUNC_ACTV objects.
      */
      public Enumeration getINF_FUND_FUNC_ACTVs1()
      {
      
         if (getSession().getProperty("CacheINF_FUND_FUNC_ACTVs1").equals("true"))
      
         {
            if ( INF_FUND_FUNC_ACTVs1Cache != null ) return INF_FUND_FUNC_ACTVs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FUND_FUNC_ACTV";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheINF_FUND_FUNC_ACTVs1").equals("true"))
         {
            INF_FUND_FUNC_ACTVs1Cache = new ObjectHashtable();
            for (Enumeration e = (INF_FUND_FUNC_ACTVBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               INF_FUND_FUNC_ACTVs1Cache.put(pkey,cacheBO);                        
            }
         
            return (INF_FUND_FUNC_ACTVs1Cache.elements());
         }
         else
         {
            return (INF_FUND_FUNC_ACTVBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable GFPIToDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_GRNT_FP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_GRNT_FP objects.
      */
      public Enumeration getGFPIToDept()
      {
      
         if (getSession().getProperty("CacheGFPIToDept").equals("true"))
      
         {
            if ( GFPIToDeptCache != null ) return GFPIToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_GRNT_FP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheGFPIToDept").equals("true"))
         {
            GFPIToDeptCache = new ObjectHashtable();
            for (Enumeration e = (INF_GRNT_FPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               GFPIToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (GFPIToDeptCache.elements());
         }
         else
         {
            return (INF_GRNT_FPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable InfObjOtypToDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_OBJ_OTYP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_OBJ_OTYP objects.
      */
      public Enumeration getInfObjOtypToDept()
      {
      
         if (getSession().getProperty("CacheInfObjOtypToDept").equals("true"))
      
         {
            if ( InfObjOtypToDeptCache != null ) return InfObjOtypToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_OBJ_OTYP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheInfObjOtypToDept").equals("true"))
         {
            InfObjOtypToDeptCache = new ObjectHashtable();
            for (Enumeration e = (INF_OBJ_OTYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               InfObjOtypToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (InfObjOtypToDeptCache.elements());
         }
         else
         {
            return (INF_OBJ_OTYPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable INF_PHASE_PROGsCache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_PHASE_PROG objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_PHASE_PROG objects.
      */
      public Enumeration getINF_PHASE_PROGs()
      {
      
         if (getSession().getProperty("CacheINF_PHASE_PROGs").equals("true"))
      
         {
            if ( INF_PHASE_PROGsCache != null ) return INF_PHASE_PROGsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_PHASE_PROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheINF_PHASE_PROGs").equals("true"))
         {
            INF_PHASE_PROGsCache = new ObjectHashtable();
            for (Enumeration e = (INF_PHASE_PROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               INF_PHASE_PROGsCache.put(pkey,cacheBO);                        
            }
         
            return (INF_PHASE_PROGsCache.elements());
         }
         else
         {
            return (INF_PHASE_PROGBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable PFPIToDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_PROJ_FP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_PROJ_FP objects.
      */
      public Enumeration getPFPIToDept()
      {
      
         if (getSession().getProperty("CachePFPIToDept").equals("true"))
      
         {
            if ( PFPIToDeptCache != null ) return PFPIToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_PROJ_FP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCachePFPIToDept").equals("true"))
         {
            PFPIToDeptCache = new ObjectHashtable();
            for (Enumeration e = (INF_PROJ_FPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               PFPIToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (PFPIToDeptCache.elements());
         }
         else
         {
            return (INF_PROJ_FPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RevSrcInfToDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_REV_SRC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_REV_SRC objects.
      */
      public Enumeration getRevSrcInfToDept()
      {
      
         if (getSession().getProperty("CacheRevSrcInfToDept").equals("true"))
      
         {
            if ( RevSrcInfToDeptCache != null ) return RevSrcInfToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_REV_SRC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRevSrcInfToDept").equals("true"))
         {
            RevSrcInfToDeptCache = new ObjectHashtable();
            for (Enumeration e = (INF_REV_SRCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RevSrcInfToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (RevSrcInfToDeptCache.elements());
         }
         else
         {
            return (INF_REV_SRCBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToInfUnitCache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_UNIT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_UNIT objects.
      */
      public Enumeration getDeptToInfUnit()
      {
      
         if (getSession().getProperty("CacheDeptToInfUnit").equals("true"))
      
         {
            if ( DeptToInfUnitCache != null ) return DeptToInfUnitCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_UNIT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfUnit").equals("true"))
         {
            DeptToInfUnitCache = new ObjectHashtable();
            for (Enumeration e = (INF_UNITBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfUnitCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfUnitCache.elements());
         }
         else
         {
            return (INF_UNITBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptMaAuthDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the MA_DOC_AUTHDEPT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of MA_DOC_AUTHDEPT objects.
      */
      public Enumeration getDeptMaAuthDept()
      {
      
         if (getSession().getProperty("CacheDeptMaAuthDept").equals("true"))
      
         {
            if ( DeptMaAuthDeptCache != null ) return DeptMaAuthDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "MA_DOC_AUTHDEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptMaAuthDept").equals("true"))
         {
            DeptMaAuthDeptCache = new ObjectHashtable();
            for (Enumeration e = (MA_DOC_AUTHDEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptMaAuthDeptCache.put(pkey,cacheBO);                        
            }
         
            return (DeptMaAuthDeptCache.elements());
         }
         else
         {
            return (MA_DOC_AUTHDEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToActgPrflCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_ACTG_PRFL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_ACTG_PRFL objects.
      */
      public Enumeration getDeptToActgPrfl()
      {
      
         if (getSession().getProperty("CacheDeptToActgPrfl").equals("true"))
      
         {
            if ( DeptToActgPrflCache != null ) return DeptToActgPrflCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ACTG_PRFL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToActgPrfl").equals("true"))
         {
            DeptToActgPrflCache = new ObjectHashtable();
            for (Enumeration e = (R_ACTG_PRFLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToActgPrflCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToActgPrflCache.elements());
         }
         else
         {
            return (R_ACTG_PRFLBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_ACTG_TMPLsCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_ACTG_TMPL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_ACTG_TMPL objects.
      */
      public Enumeration getR_ACTG_TMPLs()
      {
      
         if (getSession().getProperty("CacheR_ACTG_TMPLs").equals("true"))
      
         {
            if ( R_ACTG_TMPLsCache != null ) return R_ACTG_TMPLsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ACTG_TMPL";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_ACTG_TMPLs").equals("true"))
         {
            R_ACTG_TMPLsCache = new ObjectHashtable();
            for (Enumeration e = (R_ACTG_TMPLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_ACTG_TMPLsCache.put(pkey,cacheBO);                        
            }
         
            return (R_ACTG_TMPLsCache.elements());
         }
         else
         {
            return (R_ACTG_TMPLBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToStructDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_ALT_ORG_STRUCT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_ALT_ORG_STRUCT objects.
      */
      public Enumeration getDeptToStructDept()
      {
      
         if (getSession().getProperty("CacheDeptToStructDept").equals("true"))
      
         {
            if ( DeptToStructDeptCache != null ) return DeptToStructDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ALT_ORG_STRUCT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToStructDept").equals("true"))
         {
            DeptToStructDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_ALT_ORG_STRUCTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToStructDeptCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToStructDeptCache.elements());
         }
         else
         {
            return (R_ALT_ORG_STRUCTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToApCwHdrCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_AP_CW_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_AP_CW_HDR objects.
      */
      public Enumeration getDeptToApCwHdr()
      {
      
         if (getSession().getProperty("CacheDeptToApCwHdr").equals("true"))
      
         {
            if ( DeptToApCwHdrCache != null ) return DeptToApCwHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_CW_HDR";
            param.fieldName = "CW_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToApCwHdr").equals("true"))
         {
            DeptToApCwHdrCache = new ObjectHashtable();
            for (Enumeration e = (R_AP_CW_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToApCwHdrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToApCwHdrCache.elements());
         }
         else
         {
            return (R_AP_CW_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_AP_INCT_RQSTs2Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_AP_INCT_RQST objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_AP_INCT_RQST objects.
      */
      public Enumeration getR_AP_INCT_RQSTs2()
      {
      
         if (getSession().getProperty("CacheR_AP_INCT_RQSTs2").equals("true"))
      
         {
            if ( R_AP_INCT_RQSTs2Cache != null ) return R_AP_INCT_RQSTs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_INCT_RQST";
            param.fieldName = "CLM_DEPT";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_AP_INCT_RQSTs2").equals("true"))
         {
            R_AP_INCT_RQSTs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_AP_INCT_RQSTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_AP_INCT_RQSTs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_AP_INCT_RQSTs2Cache.elements());
         }
         else
         {
            return (R_AP_INCT_RQSTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRApdDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_APD_DEPT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_APD_DEPT objects.
      */
      public Enumeration getRDeptToRApdDept()
      {
      
         if (getSession().getProperty("CacheRDeptToRApdDept").equals("true"))
      
         {
            if ( RDeptToRApdDeptCache != null ) return RDeptToRApdDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_APD_DEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRApdDept").equals("true"))
         {
            RDeptToRApdDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_APD_DEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRApdDeptCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRApdDeptCache.elements());
         }
         else
         {
            return (R_APD_DEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToCitedAuthCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_CITED_AUTH objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_CITED_AUTH objects.
      */
      public Enumeration getDeptToCitedAuth()
      {
      
         if (getSession().getProperty("CacheDeptToCitedAuth").equals("true"))
      
         {
            if ( DeptToCitedAuthCache != null ) return DeptToCitedAuthCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CITED_AUTH";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCitedAuth").equals("true"))
         {
            DeptToCitedAuthCache = new ObjectHashtable();
            for (Enumeration e = (R_CITED_AUTHBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCitedAuthCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCitedAuthCache.elements());
         }
         else
         {
            return (R_CITED_AUTHBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToCntacCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_CNTAC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_CNTAC objects.
      */
      public Enumeration getDeptToCntac()
      {
      
         if (getSession().getProperty("CacheDeptToCntac").equals("true"))
      
         {
            if ( DeptToCntacCache != null ) return DeptToCntacCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CNTAC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCntac").equals("true"))
         {
            DeptToCntacCache = new ObjectHashtable();
            for (Enumeration e = (R_CNTACBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCntacCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCntacCache.elements());
         }
         else
         {
            return (R_CNTACBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_COMM_FA_THLDs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_COMM_FA_THLD objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_COMM_FA_THLD objects.
      */
      public Enumeration getR_COMM_FA_THLDs1()
      {
      
         if (getSession().getProperty("CacheR_COMM_FA_THLDs1").equals("true"))
      
         {
            if ( R_COMM_FA_THLDs1Cache != null ) return R_COMM_FA_THLDs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_COMM_FA_THLD";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_COMM_FA_THLDs1").equals("true"))
         {
            R_COMM_FA_THLDs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_COMM_FA_THLDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_COMM_FA_THLDs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_COMM_FA_THLDs1Cache.elements());
         }
         else
         {
            return (R_COMM_FA_THLDBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_COMM_OBJs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_COMM_OBJ objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_COMM_OBJ objects.
      */
      public Enumeration getR_COMM_OBJs1()
      {
      
         if (getSession().getProperty("CacheR_COMM_OBJs1").equals("true"))
      
         {
            if ( R_COMM_OBJs1Cache != null ) return R_COMM_OBJs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_COMM_OBJ";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_COMM_OBJs1").equals("true"))
         {
            R_COMM_OBJs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_COMM_OBJBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_COMM_OBJs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_COMM_OBJs1Cache.elements());
         }
         else
         {
            return (R_COMM_OBJBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToDeptFYCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DEPT_FY objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DEPT_FY objects.
      */
      public Enumeration getDeptToDeptFY()
      {
      
         if (getSession().getProperty("CacheDeptToDeptFY").equals("true"))
      
         {
            if ( DeptToDeptFYCache != null ) return DeptToDeptFYCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DEPT_FY";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDeptFY").equals("true"))
         {
            DeptToDeptFYCache = new ObjectHashtable();
            for (Enumeration e = (R_DEPT_FYBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDeptFYCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDeptFYCache.elements());
         }
         else
         {
            return (R_DEPT_FYBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRDeptObjPymtCtrlCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DEPT_OBJ_PYCTRL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DEPT_OBJ_PYCTRL objects.
      */
      public Enumeration getRDeptToRDeptObjPymtCtrl()
      {
      
         if (getSession().getProperty("CacheRDeptToRDeptObjPymtCtrl").equals("true"))
      
         {
            if ( RDeptToRDeptObjPymtCtrlCache != null ) return RDeptToRDeptObjPymtCtrlCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DEPT_OBJ_PYCTRL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRDeptObjPymtCtrl").equals("true"))
         {
            RDeptToRDeptObjPymtCtrlCache = new ObjectHashtable();
            for (Enumeration e = (R_DEPT_OBJ_PYCTRLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRDeptObjPymtCtrlCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRDeptObjPymtCtrlCache.elements());
         }
         else
         {
            return (R_DEPT_OBJ_PYCTRLBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToDISCIVCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DISCIV objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DISCIV objects.
      */
      public Enumeration getDeptToDISCIV()
      {
      
         if (getSession().getProperty("CacheDeptToDISCIV").equals("true"))
      
         {
            if ( DeptToDISCIVCache != null ) return DeptToDISCIVCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DISCIV";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDISCIV").equals("true"))
         {
            DeptToDISCIVCache = new ObjectHashtable();
            for (Enumeration e = (R_DISCIVBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDISCIVCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDISCIVCache.elements());
         }
         else
         {
            return (R_DISCIVBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToDrwdwnGrpCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DRWDWN_GRP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DRWDWN_GRP objects.
      */
      public Enumeration getDeptToDrwdwnGrp()
      {
      
         if (getSession().getProperty("CacheDeptToDrwdwnGrp").equals("true"))
      
         {
            if ( DeptToDrwdwnGrpCache != null ) return DeptToDrwdwnGrpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DRWDWN_GRP";
            param.fieldName = "DRWDWN_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDrwdwnGrp").equals("true"))
         {
            DeptToDrwdwnGrpCache = new ObjectHashtable();
            for (Enumeration e = (R_DRWDWN_GRPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDrwdwnGrpCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDrwdwnGrpCache.elements());
         }
         else
         {
            return (R_DRWDWN_GRPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToEscrowDefCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_ESCROW_DEF objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_ESCROW_DEF objects.
      */
      public Enumeration getDeptToEscrowDef()
      {
      
         if (getSession().getProperty("CacheDeptToEscrowDef").equals("true"))
      
         {
            if ( DeptToEscrowDefCache != null ) return DeptToEscrowDefCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ESCROW_DEF";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToEscrowDef").equals("true"))
         {
            DeptToEscrowDefCache = new ObjectHashtable();
            for (Enumeration e = (R_ESCROW_DEFBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToEscrowDefCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToEscrowDefCache.elements());
         }
         else
         {
            return (R_ESCROW_DEFBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRFesReqCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FESREQ objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FESREQ objects.
      */
      public Enumeration getRDeptToRFesReq()
      {
      
         if (getSession().getProperty("CacheRDeptToRFesReq").equals("true"))
      
         {
            if ( RDeptToRFesReqCache != null ) return RDeptToRFesReqCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FESREQ";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRFesReq").equals("true"))
         {
            RDeptToRFesReqCache = new ObjectHashtable();
            for (Enumeration e = (R_FESREQBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRFesReqCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRFesReqCache.elements());
         }
         else
         {
            return (R_FESREQBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRFndgAllocCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FNDG_ALLOC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FNDG_ALLOC objects.
      */
      public Enumeration getRDeptToRFndgAlloc()
      {
      
         if (getSession().getProperty("CacheRDeptToRFndgAlloc").equals("true"))
      
         {
            if ( RDeptToRFndgAllocCache != null ) return RDeptToRFndgAllocCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FNDG_ALLOC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRFndgAlloc").equals("true"))
         {
            RDeptToRFndgAllocCache = new ObjectHashtable();
            for (Enumeration e = (R_FNDG_ALLOCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRFndgAllocCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRFndgAllocCache.elements());
         }
         else
         {
            return (R_FNDG_ALLOCBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRFyDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FY_DEPT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FY_DEPT objects.
      */
      public Enumeration getRDeptToRFyDept()
      {
      
         if (getSession().getProperty("CacheRDeptToRFyDept").equals("true"))
      
         {
            if ( RDeptToRFyDeptCache != null ) return RDeptToRFyDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FY_DEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRFyDept").equals("true"))
         {
            RDeptToRFyDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_FY_DEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRFyDeptCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRFyDeptCache.elements());
         }
         else
         {
            return (R_FY_DEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRGrntApplCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_GRNT_APPL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_GRNT_APPL objects.
      */
      public Enumeration getRDeptToRGrntAppl()
      {
      
         if (getSession().getProperty("CacheRDeptToRGrntAppl").equals("true"))
      
         {
            if ( RDeptToRGrntApplCache != null ) return RDeptToRGrntApplCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_APPL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntAppl").equals("true"))
         {
            RDeptToRGrntApplCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_APPLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntApplCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntApplCache.elements());
         }
         else
         {
            return (R_GRNT_APPLBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRGrntDtTmplCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_GRNT_DT_TMPL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_GRNT_DT_TMPL objects.
      */
      public Enumeration getRDeptToRGrntDtTmpl()
      {
      
         if (getSession().getProperty("CacheRDeptToRGrntDtTmpl").equals("true"))
      
         {
            if ( RDeptToRGrntDtTmplCache != null ) return RDeptToRGrntDtTmplCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_DT_TMPL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntDtTmpl").equals("true"))
         {
            RDeptToRGrntDtTmplCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_DT_TMPLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntDtTmplCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntDtTmplCache.elements());
         }
         else
         {
            return (R_GRNT_DT_TMPLBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToGrntOptyCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_GRNT_OPTY objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_GRNT_OPTY objects.
      */
      public Enumeration getDeptToGrntOpty()
      {
      
         if (getSession().getProperty("CacheDeptToGrntOpty").equals("true"))
      
         {
            if ( DeptToGrntOptyCache != null ) return DeptToGrntOptyCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_OPTY";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGrntOpty").equals("true"))
         {
            DeptToGrntOptyCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_OPTYBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGrntOptyCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGrntOptyCache.elements());
         }
         else
         {
            return (R_GRNT_OPTYBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToGrntRespCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_GRNT_RESP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_GRNT_RESP objects.
      */
      public Enumeration getDeptToGrntResp()
      {
      
         if (getSession().getProperty("CacheDeptToGrntResp").equals("true"))
      
         {
            if ( DeptToGrntRespCache != null ) return DeptToGrntRespCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_RESP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGrntResp").equals("true"))
         {
            DeptToGrntRespCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_RESPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGrntRespCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGrntRespCache.elements());
         }
         else
         {
            return (R_GRNT_RESPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToGrntUserCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_GRNT_USER objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_GRNT_USER objects.
      */
      public Enumeration getDeptToGrntUser()
      {
      
         if (getSession().getProperty("CacheDeptToGrntUser").equals("true"))
      
         {
            if ( DeptToGrntUserCache != null ) return DeptToGrntUserCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_USER";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGrntUser").equals("true"))
         {
            DeptToGrntUserCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_USERBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGrntUserCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGrntUserCache.elements());
         }
         else
         {
            return (R_GRNT_USERBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_INTG_CTRLCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_INTG_CTRL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_INTG_CTRL objects.
      */
      public Enumeration getR_INTG_CTRL()
      {
      
         if (getSession().getProperty("CacheR_INTG_CTRL").equals("true"))
      
         {
            if ( R_INTG_CTRLCache != null ) return R_INTG_CTRLCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_INTG_CTRL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_INTG_CTRL").equals("true"))
         {
            R_INTG_CTRLCache = new ObjectHashtable();
            for (Enumeration e = (R_INTG_CTRLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_INTG_CTRLCache.put(pkey,cacheBO);                        
            }
         
            return (R_INTG_CTRLCache.elements());
         }
         else
         {
            return (R_INTG_CTRLBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_MJR_PROGs3Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_MJR_PROG objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_MJR_PROG objects.
      */
      public Enumeration getR_MJR_PROGs3()
      {
      
         if (getSession().getProperty("CacheR_MJR_PROGs3").equals("true"))
      
         {
            if ( R_MJR_PROGs3Cache != null ) return R_MJR_PROGs3Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_MJR_PROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_MJR_PROGs3").equals("true"))
         {
            R_MJR_PROGs3Cache = new ObjectHashtable();
            for (Enumeration e = (R_MJR_PROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_MJR_PROGs3Cache.put(pkey,cacheBO);                        
            }
         
            return (R_MJR_PROGs3Cache.elements());
         }
         else
         {
            return (R_MJR_PROGBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DepartmentToOnGoingAwardInfoCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_ONGOING_AWD_INFO objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_ONGOING_AWD_INFO objects.
      */
      public Enumeration getDepartmentToOnGoingAwardInfo()
      {
      
         if (getSession().getProperty("CacheDepartmentToOnGoingAwardInfo").equals("true"))
      
         {
            if ( DepartmentToOnGoingAwardInfoCache != null ) return DepartmentToOnGoingAwardInfoCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ONGOING_AWD_INFO";
            param.fieldName = "CA_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDepartmentToOnGoingAwardInfo").equals("true"))
         {
            DepartmentToOnGoingAwardInfoCache = new ObjectHashtable();
            for (Enumeration e = (R_ONGOING_AWD_INFOBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DepartmentToOnGoingAwardInfoCache.put(pkey,cacheBO);                        
            }
         
            return (DepartmentToOnGoingAwardInfoCache.elements());
         }
         else
         {
            return (R_ONGOING_AWD_INFOBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable PerfEvalEvaluatorCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PE_EVALR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PE_EVALR objects.
      */
      public Enumeration getPerfEvalEvaluator()
      {
      
         if (getSession().getProperty("CachePerfEvalEvaluator").equals("true"))
      
         {
            if ( PerfEvalEvaluatorCache != null ) return PerfEvalEvaluatorCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PE_EVALR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCachePerfEvalEvaluator").equals("true"))
         {
            PerfEvalEvaluatorCache = new ObjectHashtable();
            for (Enumeration e = (R_PE_EVALRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               PerfEvalEvaluatorCache.put(pkey,cacheBO);                        
            }
         
            return (PerfEvalEvaluatorCache.elements());
         }
         else
         {
            return (R_PE_EVALRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable StateInstancesCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PRCU_ST objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PRCU_ST objects.
      */
      public Enumeration getStateInstances()
      {
      
         if (getSession().getProperty("CacheStateInstances").equals("true"))
      
         {
            if ( StateInstancesCache != null ) return StateInstancesCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PRCU_ST";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheStateInstances").equals("true"))
         {
            StateInstancesCache = new ObjectHashtable();
            for (Enumeration e = (R_PRCU_STBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               StateInstancesCache.put(pkey,cacheBO);                        
            }
         
            return (StateInstancesCache.elements());
         }
         else
         {
            return (R_PRCU_STBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRPayHldByDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PYMT_HLD_TYP_DPT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PYMT_HLD_TYP_DPT objects.
      */
      public Enumeration getRDeptToRPayHldByDept()
      {
      
         if (getSession().getProperty("CacheRDeptToRPayHldByDept").equals("true"))
      
         {
            if ( RDeptToRPayHldByDeptCache != null ) return RDeptToRPayHldByDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PYMT_HLD_TYP_DPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRPayHldByDept").equals("true"))
         {
            RDeptToRPayHldByDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_PYMT_HLD_TYP_DPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRPayHldByDeptCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRPayHldByDeptCache.elements());
         }
         else
         {
            return (R_PYMT_HLD_TYP_DPTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_STPFCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_STPF objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_STPF objects.
      */
      public Enumeration getR_STPF()
      {
      
         if (getSession().getProperty("CacheR_STPF").equals("true"))
      
         {
            if ( R_STPFCache != null ) return R_STPFCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_STPF";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_STPF").equals("true"))
         {
            R_STPFCache = new ObjectHashtable();
            for (Enumeration e = (R_STPFBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_STPFCache.put(pkey,cacheBO);                        
            }
         
            return (R_STPFCache.elements());
         }
         else
         {
            return (R_STPFBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable UniversalRequestorControlsCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_UR_CTRL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_UR_CTRL objects.
      */
      public Enumeration getUniversalRequestorControls()
      {
      
         if (getSession().getProperty("CacheUniversalRequestorControls").equals("true"))
      
         {
            if ( UniversalRequestorControlsCache != null ) return UniversalRequestorControlsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_UR_CTRL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheUniversalRequestorControls").equals("true"))
         {
            UniversalRequestorControlsCache = new ObjectHashtable();
            for (Enumeration e = (R_UR_CTRLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               UniversalRequestorControlsCache.put(pkey,cacheBO);                        
            }
         
            return (UniversalRequestorControlsCache.elements());
         }
         else
         {
            return (R_UR_CTRLBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable UserGrpTmplToDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_USER_GRP_TMPL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_USER_GRP_TMPL objects.
      */
      public Enumeration getUserGrpTmplToDept()
      {
      
         if (getSession().getProperty("CacheUserGrpTmplToDept").equals("true"))
      
         {
            if ( UserGrpTmplToDeptCache != null ) return UserGrpTmplToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_USER_GRP_TMPL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheUserGrpTmplToDept").equals("true"))
         {
            UserGrpTmplToDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_USER_GRP_TMPLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               UserGrpTmplToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (UserGrpTmplToDeptCache.elements());
         }
         else
         {
            return (R_USER_GRP_TMPLBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_VEND_LSTs2Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_VEND_LST objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_VEND_LST objects.
      */
      public Enumeration getR_VEND_LSTs2()
      {
      
         if (getSession().getProperty("CacheR_VEND_LSTs2").equals("true"))
      
         {
            if ( R_VEND_LSTs2Cache != null ) return R_VEND_LSTs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_VEND_LST";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_VEND_LSTs2").equals("true"))
         {
            R_VEND_LSTs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_VEND_LSTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_VEND_LSTs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_VEND_LSTs2Cache.elements());
         }
         else
         {
            return (R_VEND_LSTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable REQ_ACTV_SACTVsCache = null;
        
      /**     
      * <br>
      * method to retrieve the REQ_ACTV_SACTV objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of REQ_ACTV_SACTV objects.
      */
      public Enumeration getREQ_ACTV_SACTVs()
      {
      
         if (getSession().getProperty("CacheREQ_ACTV_SACTVs").equals("true"))
      
         {
            if ( REQ_ACTV_SACTVsCache != null ) return REQ_ACTV_SACTVsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_ACTV_SACTV";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheREQ_ACTV_SACTVs").equals("true"))
         {
            REQ_ACTV_SACTVsCache = new ObjectHashtable();
            for (Enumeration e = (REQ_ACTV_SACTVBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               REQ_ACTV_SACTVsCache.put(pkey,cacheBO);                        
            }
         
            return (REQ_ACTV_SACTVsCache.elements());
         }
         else
         {
            return (REQ_ACTV_SACTVBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable REQ_DEPT_OBJ_REVsCache = null;
        
      /**     
      * <br>
      * method to retrieve the REQ_DEPT_OBJ_REV objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of REQ_DEPT_OBJ_REV objects.
      */
      public Enumeration getREQ_DEPT_OBJ_REVs()
      {
      
         if (getSession().getProperty("CacheREQ_DEPT_OBJ_REVs").equals("true"))
      
         {
            if ( REQ_DEPT_OBJ_REVsCache != null ) return REQ_DEPT_OBJ_REVsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_DEPT_OBJ_REV";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheREQ_DEPT_OBJ_REVs").equals("true"))
         {
            REQ_DEPT_OBJ_REVsCache = new ObjectHashtable();
            for (Enumeration e = (REQ_DEPT_OBJ_REVBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               REQ_DEPT_OBJ_REVsCache.put(pkey,cacheBO);                        
            }
         
            return (REQ_DEPT_OBJ_REVsCache.elements());
         }
         else
         {
            return (REQ_DEPT_OBJ_REVBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable ReqFundDeptToRDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the REQ_FUND_DEPT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of REQ_FUND_DEPT objects.
      */
      public Enumeration getReqFundDeptToRDept()
      {
      
         if (getSession().getProperty("CacheReqFundDeptToRDept").equals("true"))
      
         {
            if ( ReqFundDeptToRDeptCache != null ) return ReqFundDeptToRDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_FUND_DEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheReqFundDeptToRDept").equals("true"))
         {
            ReqFundDeptToRDeptCache = new ObjectHashtable();
            for (Enumeration e = (REQ_FUND_DEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ReqFundDeptToRDeptCache.put(pkey,cacheBO);                        
            }
         
            return (ReqFundDeptToRDeptCache.elements());
         }
         else
         {
            return (REQ_FUND_DEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable REQ_FUND_UNIT_OBJsCache = null;
        
      /**     
      * <br>
      * method to retrieve the REQ_FUND_UNIT_OBJ objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of REQ_FUND_UNIT_OBJ objects.
      */
      public Enumeration getREQ_FUND_UNIT_OBJs()
      {
      
         if (getSession().getProperty("CacheREQ_FUND_UNIT_OBJs").equals("true"))
      
         {
            if ( REQ_FUND_UNIT_OBJsCache != null ) return REQ_FUND_UNIT_OBJsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_FUND_UNIT_OBJ";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheREQ_FUND_UNIT_OBJs").equals("true"))
         {
            REQ_FUND_UNIT_OBJsCache = new ObjectHashtable();
            for (Enumeration e = (REQ_FUND_UNIT_OBJBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               REQ_FUND_UNIT_OBJsCache.put(pkey,cacheBO);                        
            }
         
            return (REQ_FUND_UNIT_OBJsCache.elements());
         }
         else
         {
            return (REQ_FUND_UNIT_OBJBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable REQ_FUND_UNIT_RSRCsCache = null;
        
      /**     
      * <br>
      * method to retrieve the REQ_FUND_UNIT_RSRC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of REQ_FUND_UNIT_RSRC objects.
      */
      public Enumeration getREQ_FUND_UNIT_RSRCs()
      {
      
         if (getSession().getProperty("CacheREQ_FUND_UNIT_RSRCs").equals("true"))
      
         {
            if ( REQ_FUND_UNIT_RSRCsCache != null ) return REQ_FUND_UNIT_RSRCsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_FUND_UNIT_RSRC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheREQ_FUND_UNIT_RSRCs").equals("true"))
         {
            REQ_FUND_UNIT_RSRCsCache = new ObjectHashtable();
            for (Enumeration e = (REQ_FUND_UNIT_RSRCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               REQ_FUND_UNIT_RSRCsCache.put(pkey,cacheBO);                        
            }
         
            return (REQ_FUND_UNIT_RSRCsCache.elements());
         }
         else
         {
            return (REQ_FUND_UNIT_RSRCBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable REQ_UNITsCache = null;
        
      /**     
      * <br>
      * method to retrieve the REQ_UNIT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of REQ_UNIT objects.
      */
      public Enumeration getREQ_UNITs()
      {
      
         if (getSession().getProperty("CacheREQ_UNITs").equals("true"))
      
         {
            if ( REQ_UNITsCache != null ) return REQ_UNITsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_UNIT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheREQ_UNITs").equals("true"))
         {
            REQ_UNITsCache = new ObjectHashtable();
            for (Enumeration e = (REQ_UNITBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               REQ_UNITsCache.put(pkey,cacheBO);                        
            }
         
            return (REQ_UNITsCache.elements());
         }
         else
         {
            return (REQ_UNITBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToReqUnitProgCache = null;
        
      /**     
      * <br>
      * method to retrieve the REQ_UNIT_PROG objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of REQ_UNIT_PROG objects.
      */
      public Enumeration getDeptToReqUnitProg()
      {
      
         if (getSession().getProperty("CacheDeptToReqUnitProg").equals("true"))
      
         {
            if ( DeptToReqUnitProgCache != null ) return DeptToReqUnitProgCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_UNIT_PROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToReqUnitProg").equals("true"))
         {
            DeptToReqUnitProgCache = new ObjectHashtable();
            for (Enumeration e = (REQ_UNIT_PROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToReqUnitProgCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToReqUnitProgCache.elements());
         }
         else
         {
            return (REQ_UNIT_PROGBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable REQ_UNIT_SUNITsCache = null;
        
      /**     
      * <br>
      * method to retrieve the REQ_UNIT_SUNIT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of REQ_UNIT_SUNIT objects.
      */
      public Enumeration getREQ_UNIT_SUNITs()
      {
      
         if (getSession().getProperty("CacheREQ_UNIT_SUNITs").equals("true"))
      
         {
            if ( REQ_UNIT_SUNITsCache != null ) return REQ_UNIT_SUNITsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_UNIT_SUNIT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheREQ_UNIT_SUNITs").equals("true"))
         {
            REQ_UNIT_SUNITsCache = new ObjectHashtable();
            for (Enumeration e = (REQ_UNIT_SUNITBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               REQ_UNIT_SUNITsCache.put(pkey,cacheBO);                        
            }
         
            return (REQ_UNIT_SUNITsCache.elements());
         }
         else
         {
            return (REQ_UNIT_SUNITBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_OTPT_PARM_DETs3Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_OTPT_PARM_DET objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_OTPT_PARM_DET objects.
      */
      public Enumeration getR_OTPT_PARM_DETs3()
      {
      
         if (getSession().getProperty("CacheR_OTPT_PARM_DETs3").equals("true"))
      
         {
            if ( R_OTPT_PARM_DETs3Cache != null ) return R_OTPT_PARM_DETs3Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_OTPT_PARM_DET";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_OTPT_PARM_DETs3").equals("true"))
         {
            R_OTPT_PARM_DETs3Cache = new ObjectHashtable();
            for (Enumeration e = (R_OTPT_PARM_DETBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_OTPT_PARM_DETs3Cache.put(pkey,cacheBO);                        
            }
         
            return (R_OTPT_PARM_DETs3Cache.elements());
         }
         else
         {
            return (R_OTPT_PARM_DETBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRGrntrEvntSched2Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_GRNTR_EVNT_SCHED objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_GRNTR_EVNT_SCHED objects.
      */
      public Enumeration getRDeptToRGrntrEvntSched2()
      {
      
         if (getSession().getProperty("CacheRDeptToRGrntrEvntSched2").equals("true"))
      
         {
            if ( RDeptToRGrntrEvntSched2Cache != null ) return RDeptToRGrntrEvntSched2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNTR_EVNT_SCHED";
            param.fieldName = "AWD_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntrEvntSched2").equals("true"))
         {
            RDeptToRGrntrEvntSched2Cache = new ObjectHashtable();
            for (Enumeration e = (R_GRNTR_EVNT_SCHEDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntrEvntSched2Cache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntrEvntSched2Cache.elements());
         }
         else
         {
            return (R_GRNTR_EVNT_SCHEDBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_FARO_PARMs3Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FARO_PARM objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FARO_PARM objects.
      */
      public Enumeration getR_FARO_PARMs3()
      {
      
         if (getSession().getProperty("CacheR_FARO_PARMs3").equals("true"))
      
         {
            if ( R_FARO_PARMs3Cache != null ) return R_FARO_PARMs3Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FARO_PARM";
            param.fieldName = "NEW_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_FARO_PARMs3").equals("true"))
         {
            R_FARO_PARMs3Cache = new ObjectHashtable();
            for (Enumeration e = (R_FARO_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_FARO_PARMs3Cache.put(pkey,cacheBO);                        
            }
         
            return (R_FARO_PARMs3Cache.elements());
         }
         else
         {
            return (R_FARO_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToClmtrk1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_CLMTRK objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_CLMTRK objects.
      */
      public Enumeration getDeptToClmtrk1()
      {
      
         if (getSession().getProperty("CacheDeptToClmtrk1").equals("true"))
      
         {
            if ( DeptToClmtrk1Cache != null ) return DeptToClmtrk1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CLMTRK";
            param.fieldName = "AWD_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToClmtrk1").equals("true"))
         {
            DeptToClmtrk1Cache = new ObjectHashtable();
            for (Enumeration e = (R_CLMTRKBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToClmtrk1Cache.put(pkey,cacheBO);                        
            }
         
            return (DeptToClmtrk1Cache.elements());
         }
         else
         {
            return (R_CLMTRKBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToGtDocProgMgmtUsrCache = null;
        
      /**     
      * <br>
      * method to retrieve the GT_DOC_PMGMTUSR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of GT_DOC_PMGMTUSR objects.
      */
      public Enumeration getRDeptToGtDocProgMgmtUsr()
      {
      
         if (getSession().getProperty("CacheRDeptToGtDocProgMgmtUsr").equals("true"))
      
         {
            if ( RDeptToGtDocProgMgmtUsrCache != null ) return RDeptToGtDocProgMgmtUsrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_PMGMTUSR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToGtDocProgMgmtUsr").equals("true"))
         {
            RDeptToGtDocProgMgmtUsrCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_PMGMTUSRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToGtDocProgMgmtUsrCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToGtDocProgMgmtUsrCache.elements());
         }
         else
         {
            return (GT_DOC_PMGMTUSRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable ACRL_CLR_EXCLCache = null;
        
      /**     
      * <br>
      * method to retrieve the ACRL_CLR_EXCL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of ACRL_CLR_EXCL objects.
      */
      public Enumeration getACRL_CLR_EXCL()
      {
      
         if (getSession().getProperty("CacheACRL_CLR_EXCL").equals("true"))
      
         {
            if ( ACRL_CLR_EXCLCache != null ) return ACRL_CLR_EXCLCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ACRL_CLR_EXCL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheACRL_CLR_EXCL").equals("true"))
         {
            ACRL_CLR_EXCLCache = new ObjectHashtable();
            for (Enumeration e = (ACRL_CLR_EXCLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ACRL_CLR_EXCLCache.put(pkey,cacheBO);                        
            }
         
            return (ACRL_CLR_EXCLCache.elements());
         }
         else
         {
            return (ACRL_CLR_EXCLBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RQ_DOC_CMPSHTCache = null;
        
      /**     
      * <br>
      * method to retrieve the RQ_DOC_CMPSHT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of RQ_DOC_CMPSHT objects.
      */
      public Enumeration getRQ_DOC_CMPSHT()
      {
      
         if (getSession().getProperty("CacheRQ_DOC_CMPSHT").equals("true"))
      
         {
            if ( RQ_DOC_CMPSHTCache != null ) return RQ_DOC_CMPSHTCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "RQ_DOC_CMPSHT";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRQ_DOC_CMPSHT").equals("true"))
         {
            RQ_DOC_CMPSHTCache = new ObjectHashtable();
            for (Enumeration e = (RQ_DOC_CMPSHTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RQ_DOC_CMPSHTCache.put(pkey,cacheBO);                        
            }
         
            return (RQ_DOC_CMPSHTCache.elements());
         }
         else
         {
            return (RQ_DOC_CMPSHTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_MJR_PGRPs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_MJR_PGRP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_MJR_PGRP objects.
      */
      public Enumeration getR_MJR_PGRPs1()
      {
      
         if (getSession().getProperty("CacheR_MJR_PGRPs1").equals("true"))
      
         {
            if ( R_MJR_PGRPs1Cache != null ) return R_MJR_PGRPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_MJR_PGRP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_MJR_PGRPs1").equals("true"))
         {
            R_MJR_PGRPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_MJR_PGRPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_MJR_PGRPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_MJR_PGRPs1Cache.elements());
         }
         else
         {
            return (R_MJR_PGRPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable IntrActgToDocDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_INTR_ACTG_CRSWLK objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_INTR_ACTG_CRSWLK objects.
      */
      public Enumeration getIntrActgToDocDept()
      {
      
         if (getSession().getProperty("CacheIntrActgToDocDept").equals("true"))
      
         {
            if ( IntrActgToDocDeptCache != null ) return IntrActgToDocDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_INTR_ACTG_CRSWLK";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheIntrActgToDocDept").equals("true"))
         {
            IntrActgToDocDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_INTR_ACTG_CRSWLKBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               IntrActgToDocDeptCache.put(pkey,cacheBO);                        
            }
         
            return (IntrActgToDocDeptCache.elements());
         }
         else
         {
            return (R_INTR_ACTG_CRSWLKBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable FacpatToDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FACPAT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FACPAT objects.
      */
      public Enumeration getFacpatToDept()
      {
      
         if (getSession().getProperty("CacheFacpatToDept").equals("true"))
      
         {
            if ( FacpatToDeptCache != null ) return FacpatToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FACPAT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheFacpatToDept").equals("true"))
         {
            FacpatToDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_FACPATBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               FacpatToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (FacpatToDeptCache.elements());
         }
         else
         {
            return (R_FACPATBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable FacpadToDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FACPAD objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FACPAD objects.
      */
      public Enumeration getFacpadToDept()
      {
      
         if (getSession().getProperty("CacheFacpadToDept").equals("true"))
      
         {
            if ( FacpadToDeptCache != null ) return FacpadToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FACPAD";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheFacpadToDept").equals("true"))
         {
            FacpadToDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_FACPADBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               FacpadToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (FacpadToDeptCache.elements());
         }
         else
         {
            return (R_FACPADBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_DOCATs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DOCAT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DOCAT objects.
      */
      public Enumeration getR_DOCATs1()
      {
      
         if (getSession().getProperty("CacheR_DOCATs1").equals("true"))
      
         {
            if ( R_DOCATs1Cache != null ) return R_DOCATs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DOCAT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DOCATs1").equals("true"))
         {
            R_DOCATs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DOCATBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DOCATs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DOCATs1Cache.elements());
         }
         else
         {
            return (R_DOCATBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDept_RBfyStpfSpndCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_BFY_STPF_SPND objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_BFY_STPF_SPND objects.
      */
      public Enumeration getRDept_RBfyStpfSpnd()
      {
      
         if (getSession().getProperty("CacheRDept_RBfyStpfSpnd").equals("true"))
      
         {
            if ( RDept_RBfyStpfSpndCache != null ) return RDept_RBfyStpfSpndCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_BFY_STPF_SPND";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDept_RBfyStpfSpnd").equals("true"))
         {
            RDept_RBfyStpfSpndCache = new ObjectHashtable();
            for (Enumeration e = (R_BFY_STPF_SPNDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDept_RBfyStpfSpndCache.put(pkey,cacheBO);                        
            }
         
            return (RDept_RBfyStpfSpndCache.elements());
         }
         else
         {
            return (R_BFY_STPF_SPNDBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_AP_DISB_PARMs3Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_AP_DISB_PARM objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_AP_DISB_PARM objects.
      */
      public Enumeration getR_AP_DISB_PARMs3()
      {
      
         if (getSession().getProperty("CacheR_AP_DISB_PARMs3").equals("true"))
      
         {
            if ( R_AP_DISB_PARMs3Cache != null ) return R_AP_DISB_PARMs3Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_DISB_PARM";
            param.fieldName = "DOC_DEPT";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_AP_DISB_PARMs3").equals("true"))
         {
            R_AP_DISB_PARMs3Cache = new ObjectHashtable();
            for (Enumeration e = (R_AP_DISB_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_AP_DISB_PARMs3Cache.put(pkey,cacheBO);                        
            }
         
            return (R_AP_DISB_PARMs3Cache.elements());
         }
         else
         {
            return (R_AP_DISB_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable MMRDocHdrDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the MMR_DOC_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of MMR_DOC_HDR objects.
      */
      public Enumeration getMMRDocHdrDept()
      {
      
         if (getSession().getProperty("CacheMMRDocHdrDept").equals("true"))
      
         {
            if ( MMRDocHdrDeptCache != null ) return MMRDocHdrDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "MMR_DOC_HDR";
            param.fieldName = "NEW_RQSTR_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheMMRDocHdrDept").equals("true"))
         {
            MMRDocHdrDeptCache = new ObjectHashtable();
            for (Enumeration e = (MMR_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               MMRDocHdrDeptCache.put(pkey,cacheBO);                        
            }
         
            return (MMRDocHdrDeptCache.elements());
         }
         else
         {
            return (MMR_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToMaSrtyInsCache = null;
        
      /**     
      * <br>
      * method to retrieve the MA_DOC_SRTYINS objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of MA_DOC_SRTYINS objects.
      */
      public Enumeration getDeptToMaSrtyIns()
      {
      
         if (getSession().getProperty("CacheDeptToMaSrtyIns").equals("true"))
      
         {
            if ( DeptToMaSrtyInsCache != null ) return DeptToMaSrtyInsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "MA_DOC_SRTYINS";
            param.fieldName = "HLD_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToMaSrtyIns").equals("true"))
         {
            DeptToMaSrtyInsCache = new ObjectHashtable();
            for (Enumeration e = (MA_DOC_SRTYINSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToMaSrtyInsCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToMaSrtyInsCache.elements());
         }
         else
         {
            return (MA_DOC_SRTYINSBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToFndCDocFndCCache = null;
        
      /**     
      * <br>
      * method to retrieve the FNDC_DOC_FNDC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of FNDC_DOC_FNDC objects.
      */
      public Enumeration getDeptToFndCDocFndC()
      {
      
         if (getSession().getProperty("CacheDeptToFndCDocFndC").equals("true"))
      
         {
            if ( DeptToFndCDocFndCCache != null ) return DeptToFndCDocFndCCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "FNDC_DOC_FNDC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToFndCDocFndC").equals("true"))
         {
            DeptToFndCDocFndCCache = new ObjectHashtable();
            for (Enumeration e = (FNDC_DOC_FNDCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToFndCDocFndCCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToFndCDocFndCCache.elements());
         }
         else
         {
            return (FNDC_DOC_FNDCBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RqstDeptToCMRDocHdrCache = null;
        
      /**     
      * <br>
      * method to retrieve the CMR_DOC_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of CMR_DOC_HDR objects.
      */
      public Enumeration getRqstDeptToCMRDocHdr()
      {
      
         if (getSession().getProperty("CacheRqstDeptToCMRDocHdr").equals("true"))
      
         {
            if ( RqstDeptToCMRDocHdrCache != null ) return RqstDeptToCMRDocHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CMR_DOC_HDR";
            param.fieldName = "NEW_RQSTR_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRqstDeptToCMRDocHdr").equals("true"))
         {
            RqstDeptToCMRDocHdrCache = new ObjectHashtable();
            for (Enumeration e = (CMR_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RqstDeptToCMRDocHdrCache.put(pkey,cacheBO);                        
            }
         
            return (RqstDeptToCMRDocHdrCache.elements());
         }
         else
         {
            return (CMR_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_TASKs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_TASK objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_TASK objects.
      */
      public Enumeration getR_TASKs1()
      {
      
         if (getSession().getProperty("CacheR_TASKs1").equals("true"))
      
         {
            if ( R_TASKs1Cache != null ) return R_TASKs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_TASK";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_TASKs1").equals("true"))
         {
            R_TASKs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_TASKBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_TASKs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_TASKs1Cache.elements());
         }
         else
         {
            return (R_TASKBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRPayHldTinCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PYMT_HLD_TIN objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PYMT_HLD_TIN objects.
      */
      public Enumeration getRDeptToRPayHldTin()
      {
      
         if (getSession().getProperty("CacheRDeptToRPayHldTin").equals("true"))
      
         {
            if ( RDeptToRPayHldTinCache != null ) return RDeptToRPayHldTinCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PYMT_HLD_TIN";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRPayHldTin").equals("true"))
         {
            RDeptToRPayHldTinCache = new ObjectHashtable();
            for (Enumeration e = (R_PYMT_HLD_TINBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRPayHldTinCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRPayHldTinCache.elements());
         }
         else
         {
            return (R_PYMT_HLD_TINBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRFscCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FSC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FSC objects.
      */
      public Enumeration getRDeptToRFsc()
      {
      
         if (getSession().getProperty("CacheRDeptToRFsc").equals("true"))
      
         {
            if ( RDeptToRFscCache != null ) return RDeptToRFscCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FSC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRFsc").equals("true"))
         {
            RDeptToRFscCache = new ObjectHashtable();
            for (Enumeration e = (R_FSCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRFscCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRFscCache.elements());
         }
         else
         {
            return (R_FSCBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_FIN_CHRG_SETPCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FIN_CHRG_SETP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FIN_CHRG_SETP objects.
      */
      public Enumeration getR_FIN_CHRG_SETP()
      {
      
         if (getSession().getProperty("CacheR_FIN_CHRG_SETP").equals("true"))
      
         {
            if ( R_FIN_CHRG_SETPCache != null ) return R_FIN_CHRG_SETPCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FIN_CHRG_SETP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_FIN_CHRG_SETP").equals("true"))
         {
            R_FIN_CHRG_SETPCache = new ObjectHashtable();
            for (Enumeration e = (R_FIN_CHRG_SETPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_FIN_CHRG_SETPCache.put(pkey,cacheBO);                        
            }
         
            return (R_FIN_CHRG_SETPCache.elements());
         }
         else
         {
            return (R_FIN_CHRG_SETPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_FARO_PARMs2Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FARO_PARM objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FARO_PARM objects.
      */
      public Enumeration getR_FARO_PARMs2()
      {
      
         if (getSession().getProperty("CacheR_FARO_PARMs2").equals("true"))
      
         {
            if ( R_FARO_PARMs2Cache != null ) return R_FARO_PARMs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FARO_PARM";
            param.fieldName = "OLD_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_FARO_PARMs2").equals("true"))
         {
            R_FARO_PARMs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_FARO_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_FARO_PARMs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_FARO_PARMs2Cache.elements());
         }
         else
         {
            return (R_FARO_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRCntrcGlln1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_CNTRC_GOAL_LN objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_CNTRC_GOAL_LN objects.
      */
      public Enumeration getRDeptToRCntrcGlln1()
      {
      
         if (getSession().getProperty("CacheRDeptToRCntrcGlln1").equals("true"))
      
         {
            if ( RDeptToRCntrcGlln1Cache != null ) return RDeptToRCntrcGlln1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CNTRC_GOAL_LN";
            param.fieldName = "RESP_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRCntrcGlln1").equals("true"))
         {
            RDeptToRCntrcGlln1Cache = new ObjectHashtable();
            for (Enumeration e = (R_CNTRC_GOAL_LNBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRCntrcGlln1Cache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRCntrcGlln1Cache.elements());
         }
         else
         {
            return (R_CNTRC_GOAL_LNBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDept_RBfyStpfBsaCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_BFY_STPF_BSA objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_BFY_STPF_BSA objects.
      */
      public Enumeration getRDept_RBfyStpfBsa()
      {
      
         if (getSession().getProperty("CacheRDept_RBfyStpfBsa").equals("true"))
      
         {
            if ( RDept_RBfyStpfBsaCache != null ) return RDept_RBfyStpfBsaCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_BFY_STPF_BSA";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDept_RBfyStpfBsa").equals("true"))
         {
            RDept_RBfyStpfBsaCache = new ObjectHashtable();
            for (Enumeration e = (R_BFY_STPF_BSABaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDept_RBfyStpfBsaCache.put(pkey,cacheBO);                        
            }
         
            return (RDept_RBfyStpfBsaCache.elements());
         }
         else
         {
            return (R_BFY_STPF_BSABaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRAdcParmCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_ADC_PARM objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_ADC_PARM objects.
      */
      public Enumeration getRDeptToRAdcParm()
      {
      
         if (getSession().getProperty("CacheRDeptToRAdcParm").equals("true"))
      
         {
            if ( RDeptToRAdcParmCache != null ) return RDeptToRAdcParmCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ADC_PARM";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRAdcParm").equals("true"))
         {
            RDeptToRAdcParmCache = new ObjectHashtable();
            for (Enumeration e = (R_ADC_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRAdcParmCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRAdcParmCache.elements());
         }
         else
         {
            return (R_ADC_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToGtDocPrtnrUsrCache = null;
        
      /**     
      * <br>
      * method to retrieve the GT_DOC_PRTNRUSR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of GT_DOC_PRTNRUSR objects.
      */
      public Enumeration getRDeptToGtDocPrtnrUsr()
      {
      
         if (getSession().getProperty("CacheRDeptToGtDocPrtnrUsr").equals("true"))
      
         {
            if ( RDeptToGtDocPrtnrUsrCache != null ) return RDeptToGtDocPrtnrUsrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_PRTNRUSR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToGtDocPrtnrUsr").equals("true"))
         {
            RDeptToGtDocPrtnrUsrCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_PRTNRUSRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToGtDocPrtnrUsrCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToGtDocPrtnrUsrCache.elements());
         }
         else
         {
            return (GT_DOC_PRTNRUSRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RdeptToCsalProcParmCache = null;
        
      /**     
      * <br>
      * method to retrieve the CSAL_PROC_PARM objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of CSAL_PROC_PARM objects.
      */
      public Enumeration getRdeptToCsalProcParm()
      {
      
         if (getSession().getProperty("CacheRdeptToCsalProcParm").equals("true"))
      
         {
            if ( RdeptToCsalProcParmCache != null ) return RdeptToCsalProcParmCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CSAL_PROC_PARM";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToCsalProcParm").equals("true"))
         {
            RdeptToCsalProcParmCache = new ObjectHashtable();
            for (Enumeration e = (CSAL_PROC_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToCsalProcParmCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToCsalProcParmCache.elements());
         }
         else
         {
            return (CSAL_PROC_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable VmPrvntDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the VCM_DOC_PRVNT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of VCM_DOC_PRVNT objects.
      */
      public Enumeration getVmPrvntDept()
      {
      
         if (getSession().getProperty("CacheVmPrvntDept").equals("true"))
      
         {
            if ( VmPrvntDeptCache != null ) return VmPrvntDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "VCM_DOC_PRVNT";
            param.fieldName = "NEW_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheVmPrvntDept").equals("true"))
         {
            VmPrvntDeptCache = new ObjectHashtable();
            for (Enumeration e = (VCM_DOC_PRVNTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               VmPrvntDeptCache.put(pkey,cacheBO);                        
            }
         
            return (VmPrvntDeptCache.elements());
         }
         else
         {
            return (VCM_DOC_PRVNTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRUtlyActgPrflCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_UTLY_ACTG_PRFL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_UTLY_ACTG_PRFL objects.
      */
      public Enumeration getRDeptToRUtlyActgPrfl()
      {
      
         if (getSession().getProperty("CacheRDeptToRUtlyActgPrfl").equals("true"))
      
         {
            if ( RDeptToRUtlyActgPrflCache != null ) return RDeptToRUtlyActgPrflCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_UTLY_ACTG_PRFL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRUtlyActgPrfl").equals("true"))
         {
            RDeptToRUtlyActgPrflCache = new ObjectHashtable();
            for (Enumeration e = (R_UTLY_ACTG_PRFLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRUtlyActgPrflCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRUtlyActgPrflCache.elements());
         }
         else
         {
            return (R_UTLY_ACTG_PRFLBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_UNITs2Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_UNIT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_UNIT objects.
      */
      public Enumeration getR_UNITs2()
      {
      
         if (getSession().getProperty("CacheR_UNITs2").equals("true"))
      
         {
            if ( R_UNITs2Cache != null ) return R_UNITs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_UNIT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_UNITs2").equals("true"))
         {
            R_UNITs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_UNITBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_UNITs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_UNITs2Cache.elements());
         }
         else
         {
            return (R_UNITBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_TASK_ORDs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_TASK_ORD objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_TASK_ORD objects.
      */
      public Enumeration getR_TASK_ORDs1()
      {
      
         if (getSession().getProperty("CacheR_TASK_ORDs1").equals("true"))
      
         {
            if ( R_TASK_ORDs1Cache != null ) return R_TASK_ORDs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_TASK_ORD";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_TASK_ORDs1").equals("true"))
         {
            R_TASK_ORDs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_TASK_ORDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_TASK_ORDs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_TASK_ORDs1Cache.elements());
         }
         else
         {
            return (R_TASK_ORDBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRRgnCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_RGN objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_RGN objects.
      */
      public Enumeration getRDeptToRRgn()
      {
      
         if (getSession().getProperty("CacheRDeptToRRgn").equals("true"))
      
         {
            if ( RDeptToRRgnCache != null ) return RDeptToRRgnCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_RGN";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRRgn").equals("true"))
         {
            RDeptToRRgnCache = new ObjectHashtable();
            for (Enumeration e = (R_RGNBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRRgnCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRRgnCache.elements());
         }
         else
         {
            return (R_RGNBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_PGRPs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PGRP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PGRP objects.
      */
      public Enumeration getR_PGRPs1()
      {
      
         if (getSession().getProperty("CacheR_PGRPs1").equals("true"))
      
         {
            if ( R_PGRPs1Cache != null ) return R_PGRPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PGRP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_PGRPs1").equals("true"))
         {
            R_PGRPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_PGRPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_PGRPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_PGRPs1Cache.elements());
         }
         else
         {
            return (R_PGRPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToPartUsgCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PART_USG objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PART_USG objects.
      */
      public Enumeration getDeptToPartUsg()
      {
      
         if (getSession().getProperty("CacheDeptToPartUsg").equals("true"))
      
         {
            if ( DeptToPartUsgCache != null ) return DeptToPartUsgCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PART_USG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToPartUsg").equals("true"))
         {
            DeptToPartUsgCache = new ObjectHashtable();
            for (Enumeration e = (R_PART_USGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToPartUsgCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToPartUsgCache.elements());
         }
         else
         {
            return (R_PART_USGBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_MJR_PTYPs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_MJR_PTYP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_MJR_PTYP objects.
      */
      public Enumeration getR_MJR_PTYPs1()
      {
      
         if (getSession().getProperty("CacheR_MJR_PTYPs1").equals("true"))
      
         {
            if ( R_MJR_PTYPs1Cache != null ) return R_MJR_PTYPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_MJR_PTYP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_MJR_PTYPs1").equals("true"))
         {
            R_MJR_PTYPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_MJR_PTYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_MJR_PTYPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_MJR_PTYPs1Cache.elements());
         }
         else
         {
            return (R_MJR_PTYPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_DSTCs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DSTC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DSTC objects.
      */
      public Enumeration getR_DSTCs1()
      {
      
         if (getSession().getProperty("CacheR_DSTCs1").equals("true"))
      
         {
            if ( R_DSTCs1Cache != null ) return R_DSTCs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DSTC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DSTCs1").equals("true"))
         {
            R_DSTCs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DSTCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DSTCs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DSTCs1Cache.elements());
         }
         else
         {
            return (R_DSTCBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRCntrcGllnCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_CNTRC_GOAL_LN objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_CNTRC_GOAL_LN objects.
      */
      public Enumeration getRDeptToRCntrcGlln()
      {
      
         if (getSession().getProperty("CacheRDeptToRCntrcGlln").equals("true"))
      
         {
            if ( RDeptToRCntrcGllnCache != null ) return RDeptToRCntrcGllnCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CNTRC_GOAL_LN";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRCntrcGlln").equals("true"))
         {
            RDeptToRCntrcGllnCache = new ObjectHashtable();
            for (Enumeration e = (R_CNTRC_GOAL_LNBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRCntrcGllnCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRCntrcGllnCache.elements());
         }
         else
         {
            return (R_CNTRC_GOAL_LNBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RCashSweepToRDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_CASH_SW_SETP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_CASH_SW_SETP objects.
      */
      public Enumeration getRCashSweepToRDept()
      {
      
         if (getSession().getProperty("CacheRCashSweepToRDept").equals("true"))
      
         {
            if ( RCashSweepToRDeptCache != null ) return RCashSweepToRDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CASH_SW_SETP";
            param.fieldName = "PRTP_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRCashSweepToRDept").equals("true"))
         {
            RCashSweepToRDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_CASH_SW_SETPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RCashSweepToRDeptCache.put(pkey,cacheBO);                        
            }
         
            return (RCashSweepToRDeptCache.elements());
         }
         else
         {
            return (R_CASH_SW_SETPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_AP_CLM_ACCTs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_AP_CLM_ACCT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_AP_CLM_ACCT objects.
      */
      public Enumeration getR_AP_CLM_ACCTs1()
      {
      
         if (getSession().getProperty("CacheR_AP_CLM_ACCTs1").equals("true"))
      
         {
            if ( R_AP_CLM_ACCTs1Cache != null ) return R_AP_CLM_ACCTs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_CLM_ACCT";
            param.fieldName = "CLM_DEPT";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_AP_CLM_ACCTs1").equals("true"))
         {
            R_AP_CLM_ACCTs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_AP_CLM_ACCTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_AP_CLM_ACCTs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_AP_CLM_ACCTs1Cache.elements());
         }
         else
         {
            return (R_AP_CLM_ACCTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToAltDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_ALT_ORG_STRUCT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_ALT_ORG_STRUCT objects.
      */
      public Enumeration getDeptToAltDept()
      {
      
         if (getSession().getProperty("CacheDeptToAltDept").equals("true"))
      
         {
            if ( DeptToAltDeptCache != null ) return DeptToAltDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ALT_ORG_STRUCT";
            param.fieldName = "ALT_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToAltDept").equals("true"))
         {
            DeptToAltDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_ALT_ORG_STRUCTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToAltDeptCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToAltDeptCache.elements());
         }
         else
         {
            return (R_ALT_ORG_STRUCTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable ONLN_PRN_BAT_PARM1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the ONLN_PRN_BAT_PARM objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of ONLN_PRN_BAT_PARM objects.
      */
      public Enumeration getONLN_PRN_BAT_PARM1()
      {
      
         if (getSession().getProperty("CacheONLN_PRN_BAT_PARM1").equals("true"))
      
         {
            if ( ONLN_PRN_BAT_PARM1Cache != null ) return ONLN_PRN_BAT_PARM1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ONLN_PRN_BAT_PARM";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheONLN_PRN_BAT_PARM1").equals("true"))
         {
            ONLN_PRN_BAT_PARM1Cache = new ObjectHashtable();
            for (Enumeration e = (ONLN_PRN_BAT_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ONLN_PRN_BAT_PARM1Cache.put(pkey,cacheBO);                        
            }
         
            return (ONLN_PRN_BAT_PARM1Cache.elements());
         }
         else
         {
            return (ONLN_PRN_BAT_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable INF_APPRs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_APPR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_APPR objects.
      */
      public Enumeration getINF_APPRs1()
      {
      
         if (getSession().getProperty("CacheINF_APPRs1").equals("true"))
      
         {
            if ( INF_APPRs1Cache != null ) return INF_APPRs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_APPR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheINF_APPRs1").equals("true"))
         {
            INF_APPRs1Cache = new ObjectHashtable();
            for (Enumeration e = (INF_APPRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               INF_APPRs1Cache.put(pkey,cacheBO);                        
            }
         
            return (INF_APPRs1Cache.elements());
         }
         else
         {
            return (INF_APPRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToGtDocRptuserCache = null;
        
      /**     
      * <br>
      * method to retrieve the GT_DOC_RPTUSER objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of GT_DOC_RPTUSER objects.
      */
      public Enumeration getRDeptToGtDocRptuser()
      {
      
         if (getSession().getProperty("CacheRDeptToGtDocRptuser").equals("true"))
      
         {
            if ( RDeptToGtDocRptuserCache != null ) return RDeptToGtDocRptuserCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_RPTUSER";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToGtDocRptuser").equals("true"))
         {
            RDeptToGtDocRptuserCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_RPTUSERBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToGtDocRptuserCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToGtDocRptuserCache.elements());
         }
         else
         {
            return (GT_DOC_RPTUSERBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DOC_HDRsCache = null;
        
      /**     
      * <br>
      * method to retrieve the DOC_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of DOC_HDR objects.
      */
      public Enumeration getDOC_HDRs()
      {
      
         if (getSession().getProperty("CacheDOC_HDRs").equals("true"))
      
         {
            if ( DOC_HDRsCache != null ) return DOC_HDRsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "DOC_HDR";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDOC_HDRs").equals("true"))
         {
            DOC_HDRsCache = new ObjectHashtable();
            for (Enumeration e = (DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DOC_HDRsCache.put(pkey,cacheBO);                        
            }
         
            return (DOC_HDRsCache.elements());
         }
         else
         {
            return (DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable VmAuthDeptDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the VCM_DOC_AUTHDEPT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of VCM_DOC_AUTHDEPT objects.
      */
      public Enumeration getVmAuthDeptDept()
      {
      
         if (getSession().getProperty("CacheVmAuthDeptDept").equals("true"))
      
         {
            if ( VmAuthDeptDeptCache != null ) return VmAuthDeptDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "VCM_DOC_AUTHDEPT";
            param.fieldName = "NEW_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheVmAuthDeptDept").equals("true"))
         {
            VmAuthDeptDeptCache = new ObjectHashtable();
            for (Enumeration e = (VCM_DOC_AUTHDEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               VmAuthDeptDeptCache.put(pkey,cacheBO);                        
            }
         
            return (VmAuthDeptDeptCache.elements());
         }
         else
         {
            return (VCM_DOC_AUTHDEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_PRVNT_SPNDsCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PRVNT_SPND objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PRVNT_SPND objects.
      */
      public Enumeration getR_PRVNT_SPNDs()
      {
      
         if (getSession().getProperty("CacheR_PRVNT_SPNDs").equals("true"))
      
         {
            if ( R_PRVNT_SPNDsCache != null ) return R_PRVNT_SPNDsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PRVNT_SPND";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_PRVNT_SPNDs").equals("true"))
         {
            R_PRVNT_SPNDsCache = new ObjectHashtable();
            for (Enumeration e = (R_PRVNT_SPNDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_PRVNT_SPNDsCache.put(pkey,cacheBO);                        
            }
         
            return (R_PRVNT_SPNDsCache.elements());
         }
         else
         {
            return (R_PRVNT_SPNDBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToPartRfCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PART_RF objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PART_RF objects.
      */
      public Enumeration getDeptToPartRf()
      {
      
         if (getSession().getProperty("CacheDeptToPartRf").equals("true"))
      
         {
            if ( DeptToPartRfCache != null ) return DeptToPartRfCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PART_RF";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToPartRf").equals("true"))
         {
            DeptToPartRfCache = new ObjectHashtable();
            for (Enumeration e = (R_PART_RFBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToPartRfCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToPartRfCache.elements());
         }
         else
         {
            return (R_PART_RFBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRGrntrRptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_GRNTR_RPT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_GRNTR_RPT objects.
      */
      public Enumeration getRDeptToRGrntrRpt()
      {
      
         if (getSession().getProperty("CacheRDeptToRGrntrRpt").equals("true"))
      
         {
            if ( RDeptToRGrntrRptCache != null ) return RDeptToRGrntrRptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNTR_RPT";
            param.fieldName = "APPL_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntrRpt").equals("true"))
         {
            RDeptToRGrntrRptCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNTR_RPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntrRptCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntrRptCache.elements());
         }
         else
         {
            return (R_GRNTR_RPTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToDebtAuthCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DEBT_AUTH objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DEBT_AUTH objects.
      */
      public Enumeration getDeptToDebtAuth()
      {
      
         if (getSession().getProperty("CacheDeptToDebtAuth").equals("true"))
      
         {
            if ( DeptToDebtAuthCache != null ) return DeptToDebtAuthCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DEBT_AUTH";
            param.fieldName = "RESP_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDebtAuth").equals("true"))
         {
            DeptToDebtAuthCache = new ObjectHashtable();
            for (Enumeration e = (R_DEBT_AUTHBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDebtAuthCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDebtAuthCache.elements());
         }
         else
         {
            return (R_DEBT_AUTHBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RdeptToRcsalSrctrSetpCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_CSAL_SRCTR_SETP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_CSAL_SRCTR_SETP objects.
      */
      public Enumeration getRdeptToRcsalSrctrSetp()
      {
      
         if (getSession().getProperty("CacheRdeptToRcsalSrctrSetp").equals("true"))
      
         {
            if ( RdeptToRcsalSrctrSetpCache != null ) return RdeptToRcsalSrctrSetpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CSAL_SRCTR_SETP";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToRcsalSrctrSetp").equals("true"))
         {
            RdeptToRcsalSrctrSetpCache = new ObjectHashtable();
            for (Enumeration e = (R_CSAL_SRCTR_SETPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToRcsalSrctrSetpCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToRcsalSrctrSetpCache.elements());
         }
         else
         {
            return (R_CSAL_SRCTR_SETPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRApUprocPrcuAlCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_AP_UPROC_PRCU_AL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_AP_UPROC_PRCU_AL objects.
      */
      public Enumeration getRDeptToRApUprocPrcuAl()
      {
      
         if (getSession().getProperty("CacheRDeptToRApUprocPrcuAl").equals("true"))
      
         {
            if ( RDeptToRApUprocPrcuAlCache != null ) return RDeptToRApUprocPrcuAlCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_UPROC_PRCU_AL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRApUprocPrcuAl").equals("true"))
         {
            RDeptToRApUprocPrcuAlCache = new ObjectHashtable();
            for (Enumeration e = (R_AP_UPROC_PRCU_ALBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRApUprocPrcuAlCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRApUprocPrcuAlCache.elements());
         }
         else
         {
            return (R_AP_UPROC_PRCU_ALBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToApCwChkCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_AP_CW_CHK_NO objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_AP_CW_CHK_NO objects.
      */
      public Enumeration getDeptToApCwChk()
      {
      
         if (getSession().getProperty("CacheDeptToApCwChk").equals("true"))
      
         {
            if ( DeptToApCwChkCache != null ) return DeptToApCwChkCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_CW_CHK_NO";
            param.fieldName = "CW_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToApCwChk").equals("true"))
         {
            DeptToApCwChkCache = new ObjectHashtable();
            for (Enumeration e = (R_AP_CW_CHK_NOBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToApCwChkCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToApCwChkCache.elements());
         }
         else
         {
            return (R_AP_CW_CHK_NOBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDept1ToRAdcParm1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_ADC_PARM objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_ADC_PARM objects.
      */
      public Enumeration getRDept1ToRAdcParm1()
      {
      
         if (getSession().getProperty("CacheRDept1ToRAdcParm1").equals("true"))
      
         {
            if ( RDept1ToRAdcParm1Cache != null ) return RDept1ToRAdcParm1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ADC_PARM";
            param.fieldName = "SRC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDept1ToRAdcParm1").equals("true"))
         {
            RDept1ToRAdcParm1Cache = new ObjectHashtable();
            for (Enumeration e = (R_ADC_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDept1ToRAdcParm1Cache.put(pkey,cacheBO);                        
            }
         
            return (RDept1ToRAdcParm1Cache.elements());
         }
         else
         {
            return (R_ADC_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToMDHdrCache = null;
        
      /**     
      * <br>
      * method to retrieve the MD_DOC_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of MD_DOC_HDR objects.
      */
      public Enumeration getDeptToMDHdr()
      {
      
         if (getSession().getProperty("CacheDeptToMDHdr").equals("true"))
      
         {
            if ( DeptToMDHdrCache != null ) return DeptToMDHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "MD_DOC_HDR";
            param.fieldName = "PY_HLD_TYP_DEPT_DC";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToMDHdr").equals("true"))
         {
            DeptToMDHdrCache = new ObjectHashtable();
            for (Enumeration e = (MD_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToMDHdrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToMDHdrCache.elements());
         }
         else
         {
            return (MD_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToCamProcParmCache = null;
        
      /**     
      * <br>
      * method to retrieve the CAM_PROC_PARM objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of CAM_PROC_PARM objects.
      */
      public Enumeration getDeptToCamProcParm()
      {
      
         if (getSession().getProperty("CacheDeptToCamProcParm").equals("true"))
      
         {
            if ( DeptToCamProcParmCache != null ) return DeptToCamProcParmCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CAM_PROC_PARM";
            param.fieldName = "JV_DOC_DEPT";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCamProcParm").equals("true"))
         {
            DeptToCamProcParmCache = new ObjectHashtable();
            for (Enumeration e = (CAM_PROC_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCamProcParmCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCamProcParmCache.elements());
         }
         else
         {
            return (CAM_PROC_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RdeptToRstatUnitSetpCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_STAT_UNIT_SETP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_STAT_UNIT_SETP objects.
      */
      public Enumeration getRdeptToRstatUnitSetp()
      {
      
         if (getSession().getProperty("CacheRdeptToRstatUnitSetp").equals("true"))
      
         {
            if ( RdeptToRstatUnitSetpCache != null ) return RdeptToRstatUnitSetpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_STAT_UNIT_SETP";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToRstatUnitSetp").equals("true"))
         {
            RdeptToRstatUnitSetpCache = new ObjectHashtable();
            for (Enumeration e = (R_STAT_UNIT_SETPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToRstatUnitSetpCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToRstatUnitSetpCache.elements());
         }
         else
         {
            return (R_STAT_UNIT_SETPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToProgStaCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PROG_STA objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PROG_STA objects.
      */
      public Enumeration getDeptToProgSta()
      {
      
         if (getSession().getProperty("CacheDeptToProgSta").equals("true"))
      
         {
            if ( DeptToProgStaCache != null ) return DeptToProgStaCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PROG_STA";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToProgSta").equals("true"))
         {
            DeptToProgStaCache = new ObjectHashtable();
            for (Enumeration e = (R_PROG_STABaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToProgStaCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToProgStaCache.elements());
         }
         else
         {
            return (R_PROG_STABaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_PROGs2Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PROG objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PROG objects.
      */
      public Enumeration getR_PROGs2()
      {
      
         if (getSession().getProperty("CacheR_PROGs2").equals("true"))
      
         {
            if ( R_PROGs2Cache != null ) return R_PROGs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_PROGs2").equals("true"))
         {
            R_PROGs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_PROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_PROGs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_PROGs2Cache.elements());
         }
         else
         {
            return (R_PROGBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToOnGoingAwardInfoCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_ONGOING_AWD_INFO objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_ONGOING_AWD_INFO objects.
      */
      public Enumeration getDeptToOnGoingAwardInfo()
      {
      
         if (getSession().getProperty("CacheDeptToOnGoingAwardInfo").equals("true"))
      
         {
            if ( DeptToOnGoingAwardInfoCache != null ) return DeptToOnGoingAwardInfoCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ONGOING_AWD_INFO";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToOnGoingAwardInfo").equals("true"))
         {
            DeptToOnGoingAwardInfoCache = new ObjectHashtable();
            for (Enumeration e = (R_ONGOING_AWD_INFOBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToOnGoingAwardInfoCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToOnGoingAwardInfoCache.elements());
         }
         else
         {
            return (R_ONGOING_AWD_INFOBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable NegDrawExcpDtlRecsCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_NEG_DRW_EXCP_DTL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_NEG_DRW_EXCP_DTL objects.
      */
      public Enumeration getNegDrawExcpDtlRecs()
      {
      
         if (getSession().getProperty("CacheNegDrawExcpDtlRecs").equals("true"))
      
         {
            if ( NegDrawExcpDtlRecsCache != null ) return NegDrawExcpDtlRecsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_NEG_DRW_EXCP_DTL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheNegDrawExcpDtlRecs").equals("true"))
         {
            NegDrawExcpDtlRecsCache = new ObjectHashtable();
            for (Enumeration e = (R_NEG_DRW_EXCP_DTLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               NegDrawExcpDtlRecsCache.put(pkey,cacheBO);                        
            }
         
            return (NegDrawExcpDtlRecsCache.elements());
         }
         else
         {
            return (R_NEG_DRW_EXCP_DTLBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_LCLSs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_LCLS objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_LCLS objects.
      */
      public Enumeration getR_LCLSs1()
      {
      
         if (getSession().getProperty("CacheR_LCLSs1").equals("true"))
      
         {
            if ( R_LCLSs1Cache != null ) return R_LCLSs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_LCLS";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_LCLSs1").equals("true"))
         {
            R_LCLSs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_LCLSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_LCLSs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_LCLSs1Cache.elements());
         }
         else
         {
            return (R_LCLSBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToGrntNotifUsrCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_GRNT_NOTIFUSR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_GRNT_NOTIFUSR objects.
      */
      public Enumeration getDeptToGrntNotifUsr()
      {
      
         if (getSession().getProperty("CacheDeptToGrntNotifUsr").equals("true"))
      
         {
            if ( DeptToGrntNotifUsrCache != null ) return DeptToGrntNotifUsrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_NOTIFUSR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGrntNotifUsr").equals("true"))
         {
            DeptToGrntNotifUsrCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_NOTIFUSRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGrntNotifUsrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGrntNotifUsrCache.elements());
         }
         else
         {
            return (R_GRNT_NOTIFUSRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDept2ToRAdcParm2Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_ADC_PARM objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_ADC_PARM objects.
      */
      public Enumeration getRDept2ToRAdcParm2()
      {
      
         if (getSession().getProperty("CacheRDept2ToRAdcParm2").equals("true"))
      
         {
            if ( RDept2ToRAdcParm2Cache != null ) return RDept2ToRAdcParm2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ADC_PARM";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDept2ToRAdcParm2").equals("true"))
         {
            RDept2ToRAdcParm2Cache = new ObjectHashtable();
            for (Enumeration e = (R_ADC_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDept2ToRAdcParm2Cache.put(pkey,cacheBO);                        
            }
         
            return (RDept2ToRAdcParm2Cache.elements());
         }
         else
         {
            return (R_ADC_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_ACATs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_ACAT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_ACAT objects.
      */
      public Enumeration getR_ACATs1()
      {
      
         if (getSession().getProperty("CacheR_ACATs1").equals("true"))
      
         {
            if ( R_ACATs1Cache != null ) return R_ACATs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ACAT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_ACATs1").equals("true"))
         {
            R_ACATs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_ACATBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_ACATs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_ACATs1Cache.elements());
         }
         else
         {
            return (R_ACATBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable LrdsToDept1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the LIC_RNEW_DT_STRG objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of LIC_RNEW_DT_STRG objects.
      */
      public Enumeration getLrdsToDept1()
      {
      
         if (getSession().getProperty("CacheLrdsToDept1").equals("true"))
      
         {
            if ( LrdsToDept1Cache != null ) return LrdsToDept1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "LIC_RNEW_DT_STRG";
            param.fieldName = "REMT_DEPT";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheLrdsToDept1").equals("true"))
         {
            LrdsToDept1Cache = new ObjectHashtable();
            for (Enumeration e = (LIC_RNEW_DT_STRGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               LrdsToDept1Cache.put(pkey,cacheBO);                        
            }
         
            return (LrdsToDept1Cache.elements());
         }
         else
         {
            return (LIC_RNEW_DT_STRGBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable LrdsToDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the LIC_RNEW_DT_STRG objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of LIC_RNEW_DT_STRG objects.
      */
      public Enumeration getLrdsToDept()
      {
      
         if (getSession().getProperty("CacheLrdsToDept").equals("true"))
      
         {
            if ( LrdsToDeptCache != null ) return LrdsToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "LIC_RNEW_DT_STRG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheLrdsToDept").equals("true"))
         {
            LrdsToDeptCache = new ObjectHashtable();
            for (Enumeration e = (LIC_RNEW_DT_STRGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               LrdsToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (LrdsToDeptCache.elements());
         }
         else
         {
            return (LIC_RNEW_DT_STRGBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToARRADocSRcpQtrCache = null;
        
      /**     
      * <br>
      * method to retrieve the ARRA_DOC_SRCPQTR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of ARRA_DOC_SRCPQTR objects.
      */
      public Enumeration getDeptToARRADocSRcpQtr()
      {
      
         if (getSession().getProperty("CacheDeptToARRADocSRcpQtr").equals("true"))
      
         {
            if ( DeptToARRADocSRcpQtrCache != null ) return DeptToARRADocSRcpQtrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ARRA_DOC_SRCPQTR";
            param.fieldName = "AWD_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToARRADocSRcpQtr").equals("true"))
         {
            DeptToARRADocSRcpQtrCache = new ObjectHashtable();
            for (Enumeration e = (ARRA_DOC_SRCPQTRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToARRADocSRcpQtrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToARRADocSRcpQtrCache.elements());
         }
         else
         {
            return (ARRA_DOC_SRCPQTRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable ACRL_CLR_MGMT_2Cache = null;
        
      /**     
      * <br>
      * method to retrieve the ACRL_CLR_MGMT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of ACRL_CLR_MGMT objects.
      */
      public Enumeration getACRL_CLR_MGMT_2()
      {
      
         if (getSession().getProperty("CacheACRL_CLR_MGMT_2").equals("true"))
      
         {
            if ( ACRL_CLR_MGMT_2Cache != null ) return ACRL_CLR_MGMT_2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ACRL_CLR_MGMT";
            param.fieldName = "RFED_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheACRL_CLR_MGMT_2").equals("true"))
         {
            ACRL_CLR_MGMT_2Cache = new ObjectHashtable();
            for (Enumeration e = (ACRL_CLR_MGMTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ACRL_CLR_MGMT_2Cache.put(pkey,cacheBO);                        
            }
         
            return (ACRL_CLR_MGMT_2Cache.elements());
         }
         else
         {
            return (ACRL_CLR_MGMTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable TRVLCoaOVrdToRDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the TRVL_COA_OVRD objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of TRVL_COA_OVRD objects.
      */
      public Enumeration getTRVLCoaOVrdToRDept()
      {
      
         if (getSession().getProperty("CacheTRVLCoaOVrdToRDept").equals("true"))
      
         {
            if ( TRVLCoaOVrdToRDeptCache != null ) return TRVLCoaOVrdToRDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "TRVL_COA_OVRD";
            param.fieldName = "HOME_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheTRVLCoaOVrdToRDept").equals("true"))
         {
            TRVLCoaOVrdToRDeptCache = new ObjectHashtable();
            for (Enumeration e = (TRVL_COA_OVRDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               TRVLCoaOVrdToRDeptCache.put(pkey,cacheBO);                        
            }
         
            return (TRVLCoaOVrdToRDeptCache.elements());
         }
         else
         {
            return (TRVL_COA_OVRDBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToSrcOfFundCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_SRC_OF_FUND objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_SRC_OF_FUND objects.
      */
      public Enumeration getDeptToSrcOfFund()
      {
      
         if (getSession().getProperty("CacheDeptToSrcOfFund").equals("true"))
      
         {
            if ( DeptToSrcOfFundCache != null ) return DeptToSrcOfFundCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_SRC_OF_FUND";
            param.fieldName = "GRNT_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToSrcOfFund").equals("true"))
         {
            DeptToSrcOfFundCache = new ObjectHashtable();
            for (Enumeration e = (R_SRC_OF_FUNDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToSrcOfFundCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToSrcOfFundCache.elements());
         }
         else
         {
            return (R_SRC_OF_FUNDBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_REIM_GEN_PARAMCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_REIM_GEN_PARAM objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_REIM_GEN_PARAM objects.
      */
      public Enumeration getR_REIM_GEN_PARAM()
      {
      
         if (getSession().getProperty("CacheR_REIM_GEN_PARAM").equals("true"))
      
         {
            if ( R_REIM_GEN_PARAMCache != null ) return R_REIM_GEN_PARAMCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_REIM_GEN_PARAM";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_REIM_GEN_PARAM").equals("true"))
         {
            R_REIM_GEN_PARAMCache = new ObjectHashtable();
            for (Enumeration e = (R_REIM_GEN_PARAMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_REIM_GEN_PARAMCache.put(pkey,cacheBO);                        
            }
         
            return (R_REIM_GEN_PARAMCache.elements());
         }
         else
         {
            return (R_REIM_GEN_PARAMBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DocDeptToReimExpAdjCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_REIM_EXP_ADJ objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_REIM_EXP_ADJ objects.
      */
      public Enumeration getDocDeptToReimExpAdj()
      {
      
         if (getSession().getProperty("CacheDocDeptToReimExpAdj").equals("true"))
      
         {
            if ( DocDeptToReimExpAdjCache != null ) return DocDeptToReimExpAdjCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_REIM_EXP_ADJ";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDocDeptToReimExpAdj").equals("true"))
         {
            DocDeptToReimExpAdjCache = new ObjectHashtable();
            for (Enumeration e = (R_REIM_EXP_ADJBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DocDeptToReimExpAdjCache.put(pkey,cacheBO);                        
            }
         
            return (DocDeptToReimExpAdjCache.elements());
         }
         else
         {
            return (R_REIM_EXP_ADJBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RFAIntnExcepToRDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FA_INTN_EXCEPT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FA_INTN_EXCEPT objects.
      */
      public Enumeration getRFAIntnExcepToRDept()
      {
      
         if (getSession().getProperty("CacheRFAIntnExcepToRDept").equals("true"))
      
         {
            if ( RFAIntnExcepToRDeptCache != null ) return RFAIntnExcepToRDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FA_INTN_EXCEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRFAIntnExcepToRDept").equals("true"))
         {
            RFAIntnExcepToRDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_FA_INTN_EXCEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RFAIntnExcepToRDeptCache.put(pkey,cacheBO);                        
            }
         
            return (RFAIntnExcepToRDeptCache.elements());
         }
         else
         {
            return (R_FA_INTN_EXCEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToDebtHist1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DEBT_HIST objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DEBT_HIST objects.
      */
      public Enumeration getDeptToDebtHist1()
      {
      
         if (getSession().getProperty("CacheDeptToDebtHist1").equals("true"))
      
         {
            if ( DeptToDebtHist1Cache != null ) return DeptToDebtHist1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DEBT_HIST";
            param.fieldName = "RESP_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDebtHist1").equals("true"))
         {
            DeptToDebtHist1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DEBT_HISTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDebtHist1Cache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDebtHist1Cache.elements());
         }
         else
         {
            return (R_DEBT_HISTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_CORSPDs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_CORSPD objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_CORSPD objects.
      */
      public Enumeration getR_CORSPDs1()
      {
      
         if (getSession().getProperty("CacheR_CORSPDs1").equals("true"))
      
         {
            if ( R_CORSPDs1Cache != null ) return R_CORSPDs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CORSPD";
            param.fieldName = "SPFC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_CORSPDs1").equals("true"))
         {
            R_CORSPDs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_CORSPDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_CORSPDs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_CORSPDs1Cache.elements());
         }
         else
         {
            return (R_CORSPDBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToCWCanParmCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_AP_CWCAN_PARM objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_AP_CWCAN_PARM objects.
      */
      public Enumeration getDeptToCWCanParm()
      {
      
         if (getSession().getProperty("CacheDeptToCWCanParm").equals("true"))
      
         {
            if ( DeptToCWCanParmCache != null ) return DeptToCWCanParmCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_CWCAN_PARM";
            param.fieldName = "CW_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCWCanParm").equals("true"))
         {
            DeptToCWCanParmCache = new ObjectHashtable();
            for (Enumeration e = (R_AP_CWCAN_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCWCanParmCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCWCanParmCache.elements());
         }
         else
         {
            return (R_AP_CWCAN_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToAutoCanoCache = null;
        
      /**     
      * <br>
      * method to retrieve the AUTO_CA_NO objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of AUTO_CA_NO objects.
      */
      public Enumeration getDeptToAutoCano()
      {
      
         if (getSession().getProperty("CacheDeptToAutoCano").equals("true"))
      
         {
            if ( DeptToAutoCanoCache != null ) return DeptToAutoCanoCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "AUTO_CA_NO";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToAutoCano").equals("true"))
         {
            DeptToAutoCanoCache = new ObjectHashtable();
            for (Enumeration e = (AUTO_CA_NOBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToAutoCanoCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToAutoCanoCache.elements());
         }
         else
         {
            return (AUTO_CA_NOBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable TRVLCoaOvrdToDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the TRVL_COA_OVRD objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of TRVL_COA_OVRD objects.
      */
      public Enumeration getTRVLCoaOvrdToDept()
      {
      
         if (getSession().getProperty("CacheTRVLCoaOvrdToDept").equals("true"))
      
         {
            if ( TRVLCoaOvrdToDeptCache != null ) return TRVLCoaOvrdToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "TRVL_COA_OVRD";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheTRVLCoaOvrdToDept").equals("true"))
         {
            TRVLCoaOvrdToDeptCache = new ObjectHashtable();
            for (Enumeration e = (TRVL_COA_OVRDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               TRVLCoaOvrdToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (TRVLCoaOvrdToDeptCache.elements());
         }
         else
         {
            return (TRVL_COA_OVRDBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable Dept1ToTaskOrdBuyrLn1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_TASK_ORD_BUYR_LN objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_TASK_ORD_BUYR_LN objects.
      */
      public Enumeration getDept1ToTaskOrdBuyrLn1()
      {
      
         if (getSession().getProperty("CacheDept1ToTaskOrdBuyrLn1").equals("true"))
      
         {
            if ( Dept1ToTaskOrdBuyrLn1Cache != null ) return Dept1ToTaskOrdBuyrLn1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_TASK_ORD_BUYR_LN";
            param.fieldName = "BUYR_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDept1ToTaskOrdBuyrLn1").equals("true"))
         {
            Dept1ToTaskOrdBuyrLn1Cache = new ObjectHashtable();
            for (Enumeration e = (R_TASK_ORD_BUYR_LNBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               Dept1ToTaskOrdBuyrLn1Cache.put(pkey,cacheBO);                        
            }
         
            return (Dept1ToTaskOrdBuyrLn1Cache.elements());
         }
         else
         {
            return (R_TASK_ORD_BUYR_LNBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToTaskOrdBuyrLnCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_TASK_ORD_BUYR_LN objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_TASK_ORD_BUYR_LN objects.
      */
      public Enumeration getDeptToTaskOrdBuyrLn()
      {
      
         if (getSession().getProperty("CacheDeptToTaskOrdBuyrLn").equals("true"))
      
         {
            if ( DeptToTaskOrdBuyrLnCache != null ) return DeptToTaskOrdBuyrLnCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_TASK_ORD_BUYR_LN";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToTaskOrdBuyrLn").equals("true"))
         {
            DeptToTaskOrdBuyrLnCache = new ObjectHashtable();
            for (Enumeration e = (R_TASK_ORD_BUYR_LNBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToTaskOrdBuyrLnCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToTaskOrdBuyrLnCache.elements());
         }
         else
         {
            return (R_TASK_ORD_BUYR_LNBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_SYS_CROSWALKsCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_SYS_CROSWALK objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_SYS_CROSWALK objects.
      */
      public Enumeration getR_SYS_CROSWALKs()
      {
      
         if (getSession().getProperty("CacheR_SYS_CROSWALKs").equals("true"))
      
         {
            if ( R_SYS_CROSWALKsCache != null ) return R_SYS_CROSWALKsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_SYS_CROSWALK";
            param.fieldName = "CTRL_ELEM_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_SYS_CROSWALKs").equals("true"))
         {
            R_SYS_CROSWALKsCache = new ObjectHashtable();
            for (Enumeration e = (R_SYS_CROSWALKBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_SYS_CROSWALKsCache.put(pkey,cacheBO);                        
            }
         
            return (R_SYS_CROSWALKsCache.elements());
         }
         else
         {
            return (R_SYS_CROSWALKBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_PTYPs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PTYP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PTYP objects.
      */
      public Enumeration getR_PTYPs1()
      {
      
         if (getSession().getProperty("CacheR_PTYPs1").equals("true"))
      
         {
            if ( R_PTYPs1Cache != null ) return R_PTYPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PTYP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_PTYPs1").equals("true"))
         {
            R_PTYPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_PTYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_PTYPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_PTYPs1Cache.elements());
         }
         else
         {
            return (R_PTYPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RdeptToRplbsOfstReqCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PLBS_OFST_REQ objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PLBS_OFST_REQ objects.
      */
      public Enumeration getRdeptToRplbsOfstReq()
      {
      
         if (getSession().getProperty("CacheRdeptToRplbsOfstReq").equals("true"))
      
         {
            if ( RdeptToRplbsOfstReqCache != null ) return RdeptToRplbsOfstReqCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PLBS_OFST_REQ";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToRplbsOfstReq").equals("true"))
         {
            RdeptToRplbsOfstReqCache = new ObjectHashtable();
            for (Enumeration e = (R_PLBS_OFST_REQBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToRplbsOfstReqCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToRplbsOfstReqCache.elements());
         }
         else
         {
            return (R_PLBS_OFST_REQBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RdeptToRplbsDistCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PLBS_DIST objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PLBS_DIST objects.
      */
      public Enumeration getRdeptToRplbsDist()
      {
      
         if (getSession().getProperty("CacheRdeptToRplbsDist").equals("true"))
      
         {
            if ( RdeptToRplbsDistCache != null ) return RdeptToRplbsDistCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PLBS_DIST";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToRplbsDist").equals("true"))
         {
            RdeptToRplbsDistCache = new ObjectHashtable();
            for (Enumeration e = (R_PLBS_DISTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToRplbsDistCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToRplbsDistCache.elements());
         }
         else
         {
            return (R_PLBS_DISTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRGrntrRpt1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_GRNTR_RPT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_GRNTR_RPT objects.
      */
      public Enumeration getRDeptToRGrntrRpt1()
      {
      
         if (getSession().getProperty("CacheRDeptToRGrntrRpt1").equals("true"))
      
         {
            if ( RDeptToRGrntrRpt1Cache != null ) return RDeptToRGrntrRpt1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNTR_RPT";
            param.fieldName = "AWD_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntrRpt1").equals("true"))
         {
            RDeptToRGrntrRpt1Cache = new ObjectHashtable();
            for (Enumeration e = (R_GRNTR_RPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntrRpt1Cache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntrRpt1Cache.elements());
         }
         else
         {
            return (R_GRNTR_RPTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_FNCATs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FNCAT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FNCAT objects.
      */
      public Enumeration getR_FNCATs1()
      {
      
         if (getSession().getProperty("CacheR_FNCATs1").equals("true"))
      
         {
            if ( R_FNCATs1Cache != null ) return R_FNCATs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FNCAT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_FNCATs1").equals("true"))
         {
            R_FNCATs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_FNCATBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_FNCATs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_FNCATs1Cache.elements());
         }
         else
         {
            return (R_FNCATBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RdeptToRcsalStpctrSetpCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_CSAL_STPCTR_SETP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_CSAL_STPCTR_SETP objects.
      */
      public Enumeration getRdeptToRcsalStpctrSetp()
      {
      
         if (getSession().getProperty("CacheRdeptToRcsalStpctrSetp").equals("true"))
      
         {
            if ( RdeptToRcsalStpctrSetpCache != null ) return RdeptToRcsalStpctrSetpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CSAL_STPCTR_SETP";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToRcsalStpctrSetp").equals("true"))
         {
            RdeptToRcsalStpctrSetpCache = new ObjectHashtable();
            for (Enumeration e = (R_CSAL_STPCTR_SETPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToRcsalStpctrSetpCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToRcsalStpctrSetpCache.elements());
         }
         else
         {
            return (R_CSAL_STPCTR_SETPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_BURs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_BUR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_BUR objects.
      */
      public Enumeration getR_BURs1()
      {
      
         if (getSession().getProperty("CacheR_BURs1").equals("true"))
      
         {
            if ( R_BURs1Cache != null ) return R_BURs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_BUR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_BURs1").equals("true"))
         {
            R_BURs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_BURBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_BURs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_BURs1Cache.elements());
         }
         else
         {
            return (R_BURBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDept_RBfyStpfNactgCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_BFY_STPF_NACTG objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_BFY_STPF_NACTG objects.
      */
      public Enumeration getRDept_RBfyStpfNactg()
      {
      
         if (getSession().getProperty("CacheRDept_RBfyStpfNactg").equals("true"))
      
         {
            if ( RDept_RBfyStpfNactgCache != null ) return RDept_RBfyStpfNactgCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_BFY_STPF_NACTG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDept_RBfyStpfNactg").equals("true"))
         {
            RDept_RBfyStpfNactgCache = new ObjectHashtable();
            for (Enumeration e = (R_BFY_STPF_NACTGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDept_RBfyStpfNactgCache.put(pkey,cacheBO);                        
            }
         
            return (RDept_RBfyStpfNactgCache.elements());
         }
         else
         {
            return (R_BFY_STPF_NACTGBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable AUTO_DOC_NOsCache = null;
        
      /**     
      * <br>
      * method to retrieve the AUTO_DOC_NO objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of AUTO_DOC_NO objects.
      */
      public Enumeration getAUTO_DOC_NOs()
      {
      
         if (getSession().getProperty("CacheAUTO_DOC_NOs").equals("true"))
      
         {
            if ( AUTO_DOC_NOsCache != null ) return AUTO_DOC_NOsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "AUTO_DOC_NO";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheAUTO_DOC_NOs").equals("true"))
         {
            AUTO_DOC_NOsCache = new ObjectHashtable();
            for (Enumeration e = (AUTO_DOC_NOBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               AUTO_DOC_NOsCache.put(pkey,cacheBO);                        
            }
         
            return (AUTO_DOC_NOsCache.elements());
         }
         else
         {
            return (AUTO_DOC_NOBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptVcVcustCache = null;
        
      /**     
      * <br>
      * method to retrieve the VCC_DOC_VCUST objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of VCC_DOC_VCUST objects.
      */
      public Enumeration getRDeptVcVcust()
      {
      
         if (getSession().getProperty("CacheRDeptVcVcust").equals("true"))
      
         {
            if ( RDeptVcVcustCache != null ) return RDeptVcVcustCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "VCC_DOC_VCUST";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptVcVcust").equals("true"))
         {
            RDeptVcVcustCache = new ObjectHashtable();
            for (Enumeration e = (VCC_DOC_VCUSTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptVcVcustCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptVcVcustCache.elements());
         }
         else
         {
            return (VCC_DOC_VCUSTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptVcAuthDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the VCC_DOC_AUTHDEPT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of VCC_DOC_AUTHDEPT objects.
      */
      public Enumeration getRDeptVcAuthDept()
      {
      
         if (getSession().getProperty("CacheRDeptVcAuthDept").equals("true"))
      
         {
            if ( RDeptVcAuthDeptCache != null ) return RDeptVcAuthDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "VCC_DOC_AUTHDEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptVcAuthDept").equals("true"))
         {
            RDeptVcAuthDeptCache = new ObjectHashtable();
            for (Enumeration e = (VCC_DOC_AUTHDEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptVcAuthDeptCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptVcAuthDeptCache.elements());
         }
         else
         {
            return (VCC_DOC_AUTHDEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RQ_DOC_HDRCache = null;
        
      /**     
      * <br>
      * method to retrieve the RQ_DOC_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of RQ_DOC_HDR objects.
      */
      public Enumeration getRQ_DOC_HDR()
      {
      
         if (getSession().getProperty("CacheRQ_DOC_HDR").equals("true"))
      
         {
            if ( RQ_DOC_HDRCache != null ) return RQ_DOC_HDRCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "RQ_DOC_HDR";
            param.fieldName = "RQSTR_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRQ_DOC_HDR").equals("true"))
         {
            RQ_DOC_HDRCache = new ObjectHashtable();
            for (Enumeration e = (RQ_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RQ_DOC_HDRCache.put(pkey,cacheBO);                        
            }
         
            return (RQ_DOC_HDRCache.elements());
         }
         else
         {
            return (RQ_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable ReimReqRcycSelToDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_REIMRQD_RCYCSEL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_REIMRQD_RCYCSEL objects.
      */
      public Enumeration getReimReqRcycSelToDept()
      {
      
         if (getSession().getProperty("CacheReimReqRcycSelToDept").equals("true"))
      
         {
            if ( ReimReqRcycSelToDeptCache != null ) return ReimReqRcycSelToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_REIMRQD_RCYCSEL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheReimReqRcycSelToDept").equals("true"))
         {
            ReimReqRcycSelToDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_REIMRQD_RCYCSELBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ReimReqRcycSelToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (ReimReqRcycSelToDeptCache.elements());
         }
         else
         {
            return (R_REIMRQD_RCYCSELBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRPrtstCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PRTST objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PRTST objects.
      */
      public Enumeration getRDeptToRPrtst()
      {
      
         if (getSession().getProperty("CacheRDeptToRPrtst").equals("true"))
      
         {
            if ( RDeptToRPrtstCache != null ) return RDeptToRPrtstCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PRTST";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRPrtst").equals("true"))
         {
            RDeptToRPrtstCache = new ObjectHashtable();
            for (Enumeration e = (R_PRTSTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRPrtstCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRPrtstCache.elements());
         }
         else
         {
            return (R_PRTSTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_LOC_TBLs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_LOC_TBL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_LOC_TBL objects.
      */
      public Enumeration getR_LOC_TBLs1()
      {
      
         if (getSession().getProperty("CacheR_LOC_TBLs1").equals("true"))
      
         {
            if ( R_LOC_TBLs1Cache != null ) return R_LOC_TBLs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_LOC_TBL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_LOC_TBLs1").equals("true"))
         {
            R_LOC_TBLs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_LOC_TBLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_LOC_TBLs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_LOC_TBLs1Cache.elements());
         }
         else
         {
            return (R_LOC_TBLBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDept1ToRIntCstCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_INT_CST_PARM objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_INT_CST_PARM objects.
      */
      public Enumeration getRDept1ToRIntCst()
      {
      
         if (getSession().getProperty("CacheRDept1ToRIntCst").equals("true"))
      
         {
            if ( RDept1ToRIntCstCache != null ) return RDept1ToRIntCstCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_INT_CST_PARM";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDept1ToRIntCst").equals("true"))
         {
            RDept1ToRIntCstCache = new ObjectHashtable();
            for (Enumeration e = (R_INT_CST_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDept1ToRIntCstCache.put(pkey,cacheBO);                        
            }
         
            return (RDept1ToRIntCstCache.elements());
         }
         else
         {
            return (R_INT_CST_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRGrntrEvntSchedCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_GRNTR_EVNT_SCHED objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_GRNTR_EVNT_SCHED objects.
      */
      public Enumeration getRDeptToRGrntrEvntSched()
      {
      
         if (getSession().getProperty("CacheRDeptToRGrntrEvntSched").equals("true"))
      
         {
            if ( RDeptToRGrntrEvntSchedCache != null ) return RDeptToRGrntrEvntSchedCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNTR_EVNT_SCHED";
            param.fieldName = "OPTY_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntrEvntSched").equals("true"))
         {
            RDeptToRGrntrEvntSchedCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNTR_EVNT_SCHEDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntrEvntSchedCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntrEvntSchedCache.elements());
         }
         else
         {
            return (R_GRNTR_EVNT_SCHEDBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToEscrowHistCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_ESCROW_HIST objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_ESCROW_HIST objects.
      */
      public Enumeration getDeptToEscrowHist()
      {
      
         if (getSession().getProperty("CacheDeptToEscrowHist").equals("true"))
      
         {
            if ( DeptToEscrowHistCache != null ) return DeptToEscrowHistCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ESCROW_HIST";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToEscrowHist").equals("true"))
         {
            DeptToEscrowHistCache = new ObjectHashtable();
            for (Enumeration e = (R_ESCROW_HISTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToEscrowHistCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToEscrowHistCache.elements());
         }
         else
         {
            return (R_ESCROW_HISTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_DISB_MGMT_RSTRs2Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DISB_MGMT_RSTR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DISB_MGMT_RSTR objects.
      */
      public Enumeration getR_DISB_MGMT_RSTRs2()
      {
      
         if (getSession().getProperty("CacheR_DISB_MGMT_RSTRs2").equals("true"))
      
         {
            if ( R_DISB_MGMT_RSTRs2Cache != null ) return R_DISB_MGMT_RSTRs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DISB_MGMT_RSTR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DISB_MGMT_RSTRs2").equals("true"))
         {
            R_DISB_MGMT_RSTRs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_DISB_MGMT_RSTRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DISB_MGMT_RSTRs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DISB_MGMT_RSTRs2Cache.elements());
         }
         else
         {
            return (R_DISB_MGMT_RSTRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToDebtDocDebtInstCache = null;
        
      /**     
      * <br>
      * method to retrieve the DEBT_DOC_DEBTINST objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of DEBT_DOC_DEBTINST objects.
      */
      public Enumeration getDeptToDebtDocDebtInst()
      {
      
         if (getSession().getProperty("CacheDeptToDebtDocDebtInst").equals("true"))
      
         {
            if ( DeptToDebtDocDebtInstCache != null ) return DeptToDebtDocDebtInstCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "DEBT_DOC_DEBTINST";
            param.fieldName = "RESP_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDebtDocDebtInst").equals("true"))
         {
            DeptToDebtDocDebtInstCache = new ObjectHashtable();
            for (Enumeration e = (DEBT_DOC_DEBTINSTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDebtDocDebtInstCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDebtDocDebtInstCache.elements());
         }
         else
         {
            return (DEBT_DOC_DEBTINSTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable SO_DOC_HDRs2Cache = null;
        
      /**     
      * <br>
      * method to retrieve the SO_DOC_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of SO_DOC_HDR objects.
      */
      public Enumeration getSO_DOC_HDRs2()
      {
      
         if (getSession().getProperty("CacheSO_DOC_HDRs2").equals("true"))
      
         {
            if ( SO_DOC_HDRs2Cache != null ) return SO_DOC_HDRs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "SO_DOC_HDR";
            param.fieldName = "NVEND_LST_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheSO_DOC_HDRs2").equals("true"))
         {
            SO_DOC_HDRs2Cache = new ObjectHashtable();
            for (Enumeration e = (SO_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               SO_DOC_HDRs2Cache.put(pkey,cacheBO);                        
            }
         
            return (SO_DOC_HDRs2Cache.elements());
         }
         else
         {
            return (SO_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToREquipCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_EQUIP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_EQUIP objects.
      */
      public Enumeration getRDeptToREquip()
      {
      
         if (getSession().getProperty("CacheRDeptToREquip").equals("true"))
      
         {
            if ( RDeptToREquipCache != null ) return RDeptToREquipCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_EQUIP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToREquip").equals("true"))
         {
            RDeptToREquipCache = new ObjectHashtable();
            for (Enumeration e = (R_EQUIPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToREquipCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToREquipCache.elements());
         }
         else
         {
            return (R_EQUIPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_DRSCLSs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DRSCLS objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DRSCLS objects.
      */
      public Enumeration getR_DRSCLSs1()
      {
      
         if (getSession().getProperty("CacheR_DRSCLSs1").equals("true"))
      
         {
            if ( R_DRSCLSs1Cache != null ) return R_DRSCLSs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DRSCLS";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DRSCLSs1").equals("true"))
         {
            R_DRSCLSs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DRSCLSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DRSCLSs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DRSCLSs1Cache.elements());
         }
         else
         {
            return (R_DRSCLSBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_DIVs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DIV objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DIV objects.
      */
      public Enumeration getR_DIVs1()
      {
      
         if (getSession().getProperty("CacheR_DIVs1").equals("true"))
      
         {
            if ( R_DIVs1Cache != null ) return R_DIVs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DIV";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DIVs1").equals("true"))
         {
            R_DIVs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DIVBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DIVs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DIVs1Cache.elements());
         }
         else
         {
            return (R_DIVBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToPHMDocLnCache = null;
        
      /**     
      * <br>
      * method to retrieve the PHM_DOC_LINE objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of PHM_DOC_LINE objects.
      */
      public Enumeration getRDeptToPHMDocLn()
      {
      
         if (getSession().getProperty("CacheRDeptToPHMDocLn").equals("true"))
      
         {
            if ( RDeptToPHMDocLnCache != null ) return RDeptToPHMDocLnCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "PHM_DOC_LINE";
            param.fieldName = "PR_AWD_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToPHMDocLn").equals("true"))
         {
            RDeptToPHMDocLnCache = new ObjectHashtable();
            for (Enumeration e = (PHM_DOC_LINEBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToPHMDocLnCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToPHMDocLnCache.elements());
         }
         else
         {
            return (PHM_DOC_LINEBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToInfApBY2Cache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_APBY2 objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_APBY2 objects.
      */
      public Enumeration getDeptToInfApBY2()
      {
      
         if (getSession().getProperty("CacheDeptToInfApBY2").equals("true"))
      
         {
            if ( DeptToInfApBY2Cache != null ) return DeptToInfApBY2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_APBY2";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfApBY2").equals("true"))
         {
            DeptToInfApBY2Cache = new ObjectHashtable();
            for (Enumeration e = (INF_APBY2BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfApBY2Cache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfApBY2Cache.elements());
         }
         else
         {
            return (INF_APBY2BaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToApEdiHdrCache = null;
        
      /**     
      * <br>
      * method to retrieve the AP_EDI_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of AP_EDI_HDR objects.
      */
      public Enumeration getDeptToApEdiHdr()
      {
      
         if (getSession().getProperty("CacheDeptToApEdiHdr").equals("true"))
      
         {
            if ( DeptToApEdiHdrCache != null ) return DeptToApEdiHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "AP_EDI_HDR";
            param.fieldName = "IN_DOC_DEPT";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToApEdiHdr").equals("true"))
         {
            DeptToApEdiHdrCache = new ObjectHashtable();
            for (Enumeration e = (AP_EDI_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToApEdiHdrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToApEdiHdrCache.elements());
         }
         else
         {
            return (AP_EDI_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToReimExpAdjCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_REIM_EXP_ADJ objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_REIM_EXP_ADJ objects.
      */
      public Enumeration getDeptToReimExpAdj()
      {
      
         if (getSession().getProperty("CacheDeptToReimExpAdj").equals("true"))
      
         {
            if ( DeptToReimExpAdjCache != null ) return DeptToReimExpAdjCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_REIM_EXP_ADJ";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToReimExpAdj").equals("true"))
         {
            DeptToReimExpAdjCache = new ObjectHashtable();
            for (Enumeration e = (R_REIM_EXP_ADJBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToReimExpAdjCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToReimExpAdjCache.elements());
         }
         else
         {
            return (R_REIM_EXP_ADJBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable PrgDocCrsRefToDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PROG_DOC_CRSREF objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PROG_DOC_CRSREF objects.
      */
      public Enumeration getPrgDocCrsRefToDept()
      {
      
         if (getSession().getProperty("CachePrgDocCrsRefToDept").equals("true"))
      
         {
            if ( PrgDocCrsRefToDeptCache != null ) return PrgDocCrsRefToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PROG_DOC_CRSREF";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCachePrgDocCrsRefToDept").equals("true"))
         {
            PrgDocCrsRefToDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_PROG_DOC_CRSREFBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               PrgDocCrsRefToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (PrgDocCrsRefToDeptCache.elements());
         }
         else
         {
            return (R_PROG_DOC_CRSREFBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_PHASEsCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PHASE objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PHASE objects.
      */
      public Enumeration getR_PHASEs()
      {
      
         if (getSession().getProperty("CacheR_PHASEs").equals("true"))
      
         {
            if ( R_PHASEsCache != null ) return R_PHASEsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PHASE";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_PHASEs").equals("true"))
         {
            R_PHASEsCache = new ObjectHashtable();
            for (Enumeration e = (R_PHASEBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_PHASEsCache.put(pkey,cacheBO);                        
            }
         
            return (R_PHASEsCache.elements());
         }
         else
         {
            return (R_PHASEBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_LOCs2Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_LOC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_LOC objects.
      */
      public Enumeration getR_LOCs2()
      {
      
         if (getSession().getProperty("CacheR_LOCs2").equals("true"))
      
         {
            if ( R_LOCs2Cache != null ) return R_LOCs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_LOC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_LOCs2").equals("true"))
         {
            R_LOCs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_LOCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_LOCs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_LOCs2Cache.elements());
         }
         else
         {
            return (R_LOCBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRGrntDtDetCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_GRNT_DT_DET objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_GRNT_DT_DET objects.
      */
      public Enumeration getRDeptToRGrntDtDet()
      {
      
         if (getSession().getProperty("CacheRDeptToRGrntDtDet").equals("true"))
      
         {
            if ( RDeptToRGrntDtDetCache != null ) return RDeptToRGrntDtDetCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_DT_DET";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntDtDet").equals("true"))
         {
            RDeptToRGrntDtDetCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_DT_DETBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntDtDetCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntDtDetCache.elements());
         }
         else
         {
            return (R_GRNT_DT_DETBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRGrntrEvntSched1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_GRNTR_EVNT_SCHED objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_GRNTR_EVNT_SCHED objects.
      */
      public Enumeration getRDeptToRGrntrEvntSched1()
      {
      
         if (getSession().getProperty("CacheRDeptToRGrntrEvntSched1").equals("true"))
      
         {
            if ( RDeptToRGrntrEvntSched1Cache != null ) return RDeptToRGrntrEvntSched1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNTR_EVNT_SCHED";
            param.fieldName = "APPL_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntrEvntSched1").equals("true"))
         {
            RDeptToRGrntrEvntSched1Cache = new ObjectHashtable();
            for (Enumeration e = (R_GRNTR_EVNT_SCHEDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntrEvntSched1Cache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntrEvntSched1Cache.elements());
         }
         else
         {
            return (R_GRNTR_EVNT_SCHEDBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToFDTOptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FDT_OPT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FDT_OPT objects.
      */
      public Enumeration getDeptToFDTOpt()
      {
      
         if (getSession().getProperty("CacheDeptToFDTOpt").equals("true"))
      
         {
            if ( DeptToFDTOptCache != null ) return DeptToFDTOptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FDT_OPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToFDTOpt").equals("true"))
         {
            DeptToFDTOptCache = new ObjectHashtable();
            for (Enumeration e = (R_FDT_OPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToFDTOptCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToFDTOptCache.elements());
         }
         else
         {
            return (R_FDT_OPTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_DRSRCs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DRSRC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DRSRC objects.
      */
      public Enumeration getR_DRSRCs1()
      {
      
         if (getSession().getProperty("CacheR_DRSRCs1").equals("true"))
      
         {
            if ( R_DRSRCs1Cache != null ) return R_DRSRCs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DRSRC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DRSRCs1").equals("true"))
         {
            R_DRSRCs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DRSRCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DRSRCs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DRSRCs1Cache.elements());
         }
         else
         {
            return (R_DRSRCBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_DOCLSs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DOCLS objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DOCLS objects.
      */
      public Enumeration getR_DOCLSs1()
      {
      
         if (getSession().getProperty("CacheR_DOCLSs1").equals("true"))
      
         {
            if ( R_DOCLSs1Cache != null ) return R_DOCLSs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DOCLS";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DOCLSs1").equals("true"))
         {
            R_DOCLSs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DOCLSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DOCLSs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DOCLSs1Cache.elements());
         }
         else
         {
            return (R_DOCLSBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RdeptToRcsalCtrlSetpCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_CSAL_CTRL_SETP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_CSAL_CTRL_SETP objects.
      */
      public Enumeration getRdeptToRcsalCtrlSetp()
      {
      
         if (getSession().getProperty("CacheRdeptToRcsalCtrlSetp").equals("true"))
      
         {
            if ( RdeptToRcsalCtrlSetpCache != null ) return RdeptToRcsalCtrlSetpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CSAL_CTRL_SETP";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToRcsalCtrlSetp").equals("true"))
         {
            RdeptToRcsalCtrlSetpCache = new ObjectHashtable();
            for (Enumeration e = (R_CSAL_CTRL_SETPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToRcsalCtrlSetpCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToRcsalCtrlSetpCache.elements());
         }
         else
         {
            return (R_CSAL_CTRL_SETPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_BUYR_FLINEs2Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_BUYR_FLINE objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_BUYR_FLINE objects.
      */
      public Enumeration getR_BUYR_FLINEs2()
      {
      
         if (getSession().getProperty("CacheR_BUYR_FLINEs2").equals("true"))
      
         {
            if ( R_BUYR_FLINEs2Cache != null ) return R_BUYR_FLINEs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_BUYR_FLINE";
            param.fieldName = "BUYR_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_BUYR_FLINEs2").equals("true"))
         {
            R_BUYR_FLINEs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_BUYR_FLINEBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_BUYR_FLINEs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_BUYR_FLINEs2Cache.elements());
         }
         else
         {
            return (R_BUYR_FLINEBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToAlwPymntByDebtCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_ALW_PYMT_DBTYP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_ALW_PYMT_DBTYP objects.
      */
      public Enumeration getDeptToAlwPymntByDebt()
      {
      
         if (getSession().getProperty("CacheDeptToAlwPymntByDebt").equals("true"))
      
         {
            if ( DeptToAlwPymntByDebtCache != null ) return DeptToAlwPymntByDebtCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ALW_PYMT_DBTYP";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToAlwPymntByDebt").equals("true"))
         {
            DeptToAlwPymntByDebtCache = new ObjectHashtable();
            for (Enumeration e = (R_ALW_PYMT_DBTYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToAlwPymntByDebtCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToAlwPymntByDebtCache.elements());
         }
         else
         {
            return (R_ALW_PYMT_DBTYPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable GnBudRuleToDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the GN_BUD_RULE objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of GN_BUD_RULE objects.
      */
      public Enumeration getGnBudRuleToDept()
      {
      
         if (getSession().getProperty("CacheGnBudRuleToDept").equals("true"))
      
         {
            if ( GnBudRuleToDeptCache != null ) return GnBudRuleToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GN_BUD_RULE";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheGnBudRuleToDept").equals("true"))
         {
            GnBudRuleToDeptCache = new ObjectHashtable();
            for (Enumeration e = (GN_BUD_RULEBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               GnBudRuleToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (GnBudRuleToDeptCache.elements());
         }
         else
         {
            return (GN_BUD_RULEBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_RSTR_USEsCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_RSTR_USE objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_RSTR_USE objects.
      */
      public Enumeration getR_RSTR_USEs()
      {
      
         if (getSession().getProperty("CacheR_RSTR_USEs").equals("true"))
      
         {
            if ( R_RSTR_USEsCache != null ) return R_RSTR_USEsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_RSTR_USE";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_RSTR_USEs").equals("true"))
         {
            R_RSTR_USEsCache = new ObjectHashtable();
            for (Enumeration e = (R_RSTR_USEBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_RSTR_USEsCache.put(pkey,cacheBO);                        
            }
         
            return (R_RSTR_USEsCache.elements());
         }
         else
         {
            return (R_RSTR_USEBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_FACCsCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FACC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FACC objects.
      */
      public Enumeration getR_FACCs()
      {
      
         if (getSession().getProperty("CacheR_FACCs").equals("true"))
      
         {
            if ( R_FACCsCache != null ) return R_FACCsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FACC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_FACCs").equals("true"))
         {
            R_FACCsCache = new ObjectHashtable();
            for (Enumeration e = (R_FACCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_FACCsCache.put(pkey,cacheBO);                        
            }
         
            return (R_FACCsCache.elements());
         }
         else
         {
            return (R_FACCBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable ECRTToDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_EXTR_CASH_RECT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_EXTR_CASH_RECT objects.
      */
      public Enumeration getECRTToDept()
      {
      
         if (getSession().getProperty("CacheECRTToDept").equals("true"))
      
         {
            if ( ECRTToDeptCache != null ) return ECRTToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_EXTR_CASH_RECT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheECRTToDept").equals("true"))
         {
            ECRTToDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_EXTR_CASH_RECTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ECRTToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (ECRTToDeptCache.elements());
         }
         else
         {
            return (R_EXTR_CASH_RECTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_DOGRPs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DOGRP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DOGRP objects.
      */
      public Enumeration getR_DOGRPs1()
      {
      
         if (getSession().getProperty("CacheR_DOGRPs1").equals("true"))
      
         {
            if ( R_DOGRPs1Cache != null ) return R_DOGRPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DOGRP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DOGRPs1").equals("true"))
         {
            R_DOGRPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DOGRPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DOGRPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DOGRPs1Cache.elements());
         }
         else
         {
            return (R_DOGRPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToClmtrkCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_CLMTRK objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_CLMTRK objects.
      */
      public Enumeration getDeptToClmtrk()
      {
      
         if (getSession().getProperty("CacheDeptToClmtrk").equals("true"))
      
         {
            if ( DeptToClmtrkCache != null ) return DeptToClmtrkCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CLMTRK";
            param.fieldName = "RC_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToClmtrk").equals("true"))
         {
            DeptToClmtrkCache = new ObjectHashtable();
            for (Enumeration e = (R_CLMTRKBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToClmtrkCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToClmtrkCache.elements());
         }
         else
         {
            return (R_CLMTRKBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToCADocHistCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_CA_DOC_HIST objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_CA_DOC_HIST objects.
      */
      public Enumeration getDeptToCADocHist()
      {
      
         if (getSession().getProperty("CacheDeptToCADocHist").equals("true"))
      
         {
            if ( DeptToCADocHistCache != null ) return DeptToCADocHistCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CA_DOC_HIST";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCADocHist").equals("true"))
         {
            DeptToCADocHistCache = new ObjectHashtable();
            for (Enumeration e = (R_CA_DOC_HISTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCADocHistCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCADocHistCache.elements());
         }
         else
         {
            return (R_CA_DOC_HISTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToDisbExcpCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_AP_DISB_EXCP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_AP_DISB_EXCP objects.
      */
      public Enumeration getDeptToDisbExcp()
      {
      
         if (getSession().getProperty("CacheDeptToDisbExcp").equals("true"))
      
         {
            if ( DeptToDisbExcpCache != null ) return DeptToDisbExcpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_DISB_EXCP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDisbExcp").equals("true"))
         {
            DeptToDisbExcpCache = new ObjectHashtable();
            for (Enumeration e = (R_AP_DISB_EXCPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDisbExcpCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDisbExcpCache.elements());
         }
         else
         {
            return (R_AP_DISB_EXCPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_ACLSs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_ACLS objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_ACLS objects.
      */
      public Enumeration getR_ACLSs1()
      {
      
         if (getSession().getProperty("CacheR_ACLSs1").equals("true"))
      
         {
            if ( R_ACLSs1Cache != null ) return R_ACLSs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ACLS";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_ACLSs1").equals("true"))
         {
            R_ACLSs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_ACLSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_ACLSs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_ACLSs1Cache.elements());
         }
         else
         {
            return (R_ACLSBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DepartmentToElectronicFederalTaxPaymentSystemCache = null;
        
      /**     
      * <br>
      * method to retrieve the ELEC_FED_TAXP_SYS objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of ELEC_FED_TAXP_SYS objects.
      */
      public Enumeration getDepartmentToElectronicFederalTaxPaymentSystem()
      {
      
         if (getSession().getProperty("CacheDepartmentToElectronicFederalTaxPaymentSystem").equals("true"))
      
         {
            if ( DepartmentToElectronicFederalTaxPaymentSystemCache != null ) return DepartmentToElectronicFederalTaxPaymentSystemCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ELEC_FED_TAXP_SYS";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDepartmentToElectronicFederalTaxPaymentSystem").equals("true"))
         {
            DepartmentToElectronicFederalTaxPaymentSystemCache = new ObjectHashtable();
            for (Enumeration e = (ELEC_FED_TAXP_SYSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DepartmentToElectronicFederalTaxPaymentSystemCache.put(pkey,cacheBO);                        
            }
         
            return (DepartmentToElectronicFederalTaxPaymentSystemCache.elements());
         }
         else
         {
            return (ELEC_FED_TAXP_SYSBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable ACRL_CLR_MGMT_1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the ACRL_CLR_MGMT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of ACRL_CLR_MGMT objects.
      */
      public Enumeration getACRL_CLR_MGMT_1()
      {
      
         if (getSession().getProperty("CacheACRL_CLR_MGMT_1").equals("true"))
      
         {
            if ( ACRL_CLR_MGMT_1Cache != null ) return ACRL_CLR_MGMT_1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ACRL_CLR_MGMT";
            param.fieldName = "DOC_ACTG_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheACRL_CLR_MGMT_1").equals("true"))
         {
            ACRL_CLR_MGMT_1Cache = new ObjectHashtable();
            for (Enumeration e = (ACRL_CLR_MGMTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ACRL_CLR_MGMT_1Cache.put(pkey,cacheBO);                        
            }
         
            return (ACRL_CLR_MGMT_1Cache.elements());
         }
         else
         {
            return (ACRL_CLR_MGMTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_SECTs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_SECT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_SECT objects.
      */
      public Enumeration getR_SECTs1()
      {
      
         if (getSession().getProperty("CacheR_SECTs1").equals("true"))
      
         {
            if ( R_SECTs1Cache != null ) return R_SECTs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_SECT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_SECTs1").equals("true"))
         {
            R_SECTs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_SECTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_SECTs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_SECTs1Cache.elements());
         }
         else
         {
            return (R_SECTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable PrgDocCrsRef1ToDept_1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PROG_DOC_CRSREF objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PROG_DOC_CRSREF objects.
      */
      public Enumeration getPrgDocCrsRef1ToDept_1()
      {
      
         if (getSession().getProperty("CachePrgDocCrsRef1ToDept_1").equals("true"))
      
         {
            if ( PrgDocCrsRef1ToDept_1Cache != null ) return PrgDocCrsRef1ToDept_1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PROG_DOC_CRSREF";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCachePrgDocCrsRef1ToDept_1").equals("true"))
         {
            PrgDocCrsRef1ToDept_1Cache = new ObjectHashtable();
            for (Enumeration e = (R_PROG_DOC_CRSREFBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               PrgDocCrsRef1ToDept_1Cache.put(pkey,cacheBO);                        
            }
         
            return (PrgDocCrsRef1ToDept_1Cache.elements());
         }
         else
         {
            return (R_PROG_DOC_CRSREFBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable IntrActgToDeptCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_INTR_ACTG_CRSWLK objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_INTR_ACTG_CRSWLK objects.
      */
      public Enumeration getIntrActgToDept()
      {
      
         if (getSession().getProperty("CacheIntrActgToDept").equals("true"))
      
         {
            if ( IntrActgToDeptCache != null ) return IntrActgToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_INTR_ACTG_CRSWLK";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheIntrActgToDept").equals("true"))
         {
            IntrActgToDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_INTR_ACTG_CRSWLKBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               IntrActgToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (IntrActgToDeptCache.elements());
         }
         else
         {
            return (R_INTR_ACTG_CRSWLKBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_DOTYPs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DOTYP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DOTYP objects.
      */
      public Enumeration getR_DOTYPs1()
      {
      
         if (getSession().getProperty("CacheR_DOTYPs1").equals("true"))
      
         {
            if ( R_DOTYPs1Cache != null ) return R_DOTYPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DOTYP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DOTYPs1").equals("true"))
         {
            R_DOTYPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DOTYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DOTYPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DOTYPs1Cache.elements());
         }
         else
         {
            return (R_DOTYPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RqstDeptToMaDocHdrCache = null;
        
      /**     
      * <br>
      * method to retrieve the MA_DOC_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of MA_DOC_HDR objects.
      */
      public Enumeration getRqstDeptToMaDocHdr()
      {
      
         if (getSession().getProperty("CacheRqstDeptToMaDocHdr").equals("true"))
      
         {
            if ( RqstDeptToMaDocHdrCache != null ) return RqstDeptToMaDocHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "MA_DOC_HDR";
            param.fieldName = "RQSTR_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRqstDeptToMaDocHdr").equals("true"))
         {
            RqstDeptToMaDocHdrCache = new ObjectHashtable();
            for (Enumeration e = (MA_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RqstDeptToMaDocHdrCache.put(pkey,cacheBO);                        
            }
         
            return (RqstDeptToMaDocHdrCache.elements());
         }
         else
         {
            return (MA_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToInfAppr2Cache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_APPR2 objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_APPR2 objects.
      */
      public Enumeration getDeptToInfAppr2()
      {
      
         if (getSession().getProperty("CacheDeptToInfAppr2").equals("true"))
      
         {
            if ( DeptToInfAppr2Cache != null ) return DeptToInfAppr2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_APPR2";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfAppr2").equals("true"))
         {
            DeptToInfAppr2Cache = new ObjectHashtable();
            for (Enumeration e = (INF_APPR2BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfAppr2Cache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfAppr2Cache.elements());
         }
         else
         {
            return (INF_APPR2BaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToGRDocHdrCache = null;
        
      /**     
      * <br>
      * method to retrieve the GR_DOC_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of GR_DOC_HDR objects.
      */
      public Enumeration getDeptToGRDocHdr()
      {
      
         if (getSession().getProperty("CacheDeptToGRDocHdr").equals("true"))
      
         {
            if ( DeptToGRDocHdrCache != null ) return DeptToGRDocHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GR_DOC_HDR";
            param.fieldName = "RQSTR_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGRDocHdr").equals("true"))
         {
            DeptToGRDocHdrCache = new ObjectHashtable();
            for (Enumeration e = (GR_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGRDocHdrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGRDocHdrCache.elements());
         }
         else
         {
            return (GR_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToDebtDocAuthCache = null;
        
      /**     
      * <br>
      * method to retrieve the DEBT_DOC_AUTH objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of DEBT_DOC_AUTH objects.
      */
      public Enumeration getDeptToDebtDocAuth()
      {
      
         if (getSession().getProperty("CacheDeptToDebtDocAuth").equals("true"))
      
         {
            if ( DeptToDebtDocAuthCache != null ) return DeptToDebtDocAuthCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "DEBT_DOC_AUTH";
            param.fieldName = "RESP_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDebtDocAuth").equals("true"))
         {
            DeptToDebtDocAuthCache = new ObjectHashtable();
            for (Enumeration e = (DEBT_DOC_AUTHBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDebtDocAuthCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDebtDocAuthCache.elements());
         }
         else
         {
            return (DEBT_DOC_AUTHBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToAutoPartNoCache = null;
        
      /**     
      * <br>
      * method to retrieve the AUTO_PART_NO objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of AUTO_PART_NO objects.
      */
      public Enumeration getDeptToAutoPartNo()
      {
      
         if (getSession().getProperty("CacheDeptToAutoPartNo").equals("true"))
      
         {
            if ( DeptToAutoPartNoCache != null ) return DeptToAutoPartNoCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "AUTO_PART_NO";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToAutoPartNo").equals("true"))
         {
            DeptToAutoPartNoCache = new ObjectHashtable();
            for (Enumeration e = (AUTO_PART_NOBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToAutoPartNoCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToAutoPartNoCache.elements());
         }
         else
         {
            return (AUTO_PART_NOBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToADHdrCache = null;
        
      /**     
      * <br>
      * method to retrieve the AD_DOC_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of AD_DOC_HDR objects.
      */
      public Enumeration getDeptToADHdr()
      {
      
         if (getSession().getProperty("CacheDeptToADHdr").equals("true"))
      
         {
            if ( DeptToADHdrCache != null ) return DeptToADHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "AD_DOC_HDR";
            param.fieldName = "PY_HLD_TYP_DEPT_DC";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToADHdr").equals("true"))
         {
            DeptToADHdrCache = new ObjectHashtable();
            for (Enumeration e = (AD_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToADHdrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToADHdrCache.elements());
         }
         else
         {
            return (AD_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RCLS_PARM_DTL1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the RCLS_PARM_DTL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of RCLS_PARM_DTL objects.
      */
      public Enumeration getRCLS_PARM_DTL1()
      {
      
         if (getSession().getProperty("CacheRCLS_PARM_DTL1").equals("true"))
      
         {
            if ( RCLS_PARM_DTL1Cache != null ) return RCLS_PARM_DTL1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "RCLS_PARM_DTL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRCLS_PARM_DTL1").equals("true"))
         {
            RCLS_PARM_DTL1Cache = new ObjectHashtable();
            for (Enumeration e = (RCLS_PARM_DTLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RCLS_PARM_DTL1Cache.put(pkey,cacheBO);                        
            }
         
            return (RCLS_PARM_DTL1Cache.elements());
         }
         else
         {
            return (RCLS_PARM_DTLBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToVcustCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_VEND_CUST objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_VEND_CUST objects.
      */
      public Enumeration getDeptToVcust()
      {
      
         if (getSession().getProperty("CacheDeptToVcust").equals("true"))
      
         {
            if ( DeptToVcustCache != null ) return DeptToVcustCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_VEND_CUST";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToVcust").equals("true"))
         {
            DeptToVcustCache = new ObjectHashtable();
            for (Enumeration e = (R_VEND_CUSTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToVcustCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToVcustCache.elements());
         }
         else
         {
            return (R_VEND_CUSTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToMsmalsCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_MSMALS objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_MSMALS objects.
      */
      public Enumeration getDeptToMsmals()
      {
      
         if (getSession().getProperty("CacheDeptToMsmals").equals("true"))
      
         {
            if ( DeptToMsmalsCache != null ) return DeptToMsmalsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_MSMALS";
            param.fieldName = "AUTH_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToMsmals").equals("true"))
         {
            DeptToMsmalsCache = new ObjectHashtable();
            for (Enumeration e = (R_MSMALSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToMsmalsCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToMsmalsCache.elements());
         }
         else
         {
            return (R_MSMALSBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRIntCstCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_INT_CST_PARM objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_INT_CST_PARM objects.
      */
      public Enumeration getRDeptToRIntCst()
      {
      
         if (getSession().getProperty("CacheRDeptToRIntCst").equals("true"))
      
         {
            if ( RDeptToRIntCstCache != null ) return RDeptToRIntCstCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_INT_CST_PARM";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRIntCst").equals("true"))
         {
            RDeptToRIntCstCache = new ObjectHashtable();
            for (Enumeration e = (R_INT_CST_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRIntCstCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRIntCstCache.elements());
         }
         else
         {
            return (R_INT_CST_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_FUNCs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FUNC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FUNC objects.
      */
      public Enumeration getR_FUNCs1()
      {
      
         if (getSession().getProperty("CacheR_FUNCs1").equals("true"))
      
         {
            if ( R_FUNCs1Cache != null ) return R_FUNCs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FUNC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_FUNCs1").equals("true"))
         {
            R_FUNCs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_FUNCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_FUNCs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_FUNCs1Cache.elements());
         }
         else
         {
            return (R_FUNCBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRFacCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FAC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FAC objects.
      */
      public Enumeration getRDeptToRFac()
      {
      
         if (getSession().getProperty("CacheRDeptToRFac").equals("true"))
      
         {
            if ( RDeptToRFacCache != null ) return RDeptToRFacCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FAC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRFac").equals("true"))
         {
            RDeptToRFacCache = new ObjectHashtable();
            for (Enumeration e = (R_FACBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRFacCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRFacCache.elements());
         }
         else
         {
            return (R_FACBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToREmpInfoCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_EMP_INFO objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_EMP_INFO objects.
      */
      public Enumeration getRDeptToREmpInfo()
      {
      
         if (getSession().getProperty("CacheRDeptToREmpInfo").equals("true"))
      
         {
            if ( RDeptToREmpInfoCache != null ) return RDeptToREmpInfoCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_EMP_INFO";
            param.fieldName = "EMP_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToREmpInfo").equals("true"))
         {
            RDeptToREmpInfoCache = new ObjectHashtable();
            for (Enumeration e = (R_EMP_INFOBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToREmpInfoCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToREmpInfoCache.elements());
         }
         else
         {
            return (R_EMP_INFOBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToDeptTrvlxpPolCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DEPT_TRVLXP_POL objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DEPT_TRVLXP_POL objects.
      */
      public Enumeration getDeptToDeptTrvlxpPol()
      {
      
         if (getSession().getProperty("CacheDeptToDeptTrvlxpPol").equals("true"))
      
         {
            if ( DeptToDeptTrvlxpPolCache != null ) return DeptToDeptTrvlxpPolCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DEPT_TRVLXP_POL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDeptTrvlxpPol").equals("true"))
         {
            DeptToDeptTrvlxpPolCache = new ObjectHashtable();
            for (Enumeration e = (R_DEPT_TRVLXP_POLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDeptTrvlxpPolCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDeptTrvlxpPolCache.elements());
         }
         else
         {
            return (R_DEPT_TRVLXP_POLBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToDebtDebtInstCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DEBT_DEBTINST objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DEBT_DEBTINST objects.
      */
      public Enumeration getDeptToDebtDebtInst()
      {
      
         if (getSession().getProperty("CacheDeptToDebtDebtInst").equals("true"))
      
         {
            if ( DeptToDebtDebtInstCache != null ) return DeptToDebtDebtInstCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DEBT_DEBTINST";
            param.fieldName = "RESP_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDebtDebtInst").equals("true"))
         {
            DeptToDebtDebtInstCache = new ObjectHashtable();
            for (Enumeration e = (R_DEBT_DEBTINSTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDebtDebtInstCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDebtDebtInstCache.elements());
         }
         else
         {
            return (R_DEBT_DEBTINSTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRCntrcGlhdCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_CNTRC_GOAL_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_CNTRC_GOAL_HDR objects.
      */
      public Enumeration getRDeptToRCntrcGlhd()
      {
      
         if (getSession().getProperty("CacheRDeptToRCntrcGlhd").equals("true"))
      
         {
            if ( RDeptToRCntrcGlhdCache != null ) return RDeptToRCntrcGlhdCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CNTRC_GOAL_HDR";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRCntrcGlhd").equals("true"))
         {
            RDeptToRCntrcGlhdCache = new ObjectHashtable();
            for (Enumeration e = (R_CNTRC_GOAL_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRCntrcGlhdCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRCntrcGlhdCache.elements());
         }
         else
         {
            return (R_CNTRC_GOAL_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable ACRL_CLR_MGMTCache = null;
        
      /**     
      * <br>
      * method to retrieve the ACRL_CLR_MGMT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of ACRL_CLR_MGMT objects.
      */
      public Enumeration getACRL_CLR_MGMT()
      {
      
         if (getSession().getProperty("CacheACRL_CLR_MGMT").equals("true"))
      
         {
            if ( ACRL_CLR_MGMTCache != null ) return ACRL_CLR_MGMTCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ACRL_CLR_MGMT";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheACRL_CLR_MGMT").equals("true"))
         {
            ACRL_CLR_MGMTCache = new ObjectHashtable();
            for (Enumeration e = (ACRL_CLR_MGMTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ACRL_CLR_MGMTCache.put(pkey,cacheBO);                        
            }
         
            return (ACRL_CLR_MGMTCache.elements());
         }
         else
         {
            return (ACRL_CLR_MGMTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToABSHdrCache = null;
        
      /**     
      * <br>
      * method to retrieve the ABS_DOC_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of ABS_DOC_HDR objects.
      */
      public Enumeration getDeptToABSHdr()
      {
      
         if (getSession().getProperty("CacheDeptToABSHdr").equals("true"))
      
         {
            if ( DeptToABSHdrCache != null ) return DeptToABSHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ABS_DOC_HDR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToABSHdr").equals("true"))
         {
            DeptToABSHdrCache = new ObjectHashtable();
            for (Enumeration e = (ABS_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToABSHdrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToABSHdrCache.elements());
         }
         else
         {
            return (ABS_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToTrvlDocVendCache = null;
        
      /**     
      * <br>
      * method to retrieve the TRVL_DOC_VEND objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of TRVL_DOC_VEND objects.
      */
      public Enumeration getDeptToTrvlDocVend()
      {
      
         if (getSession().getProperty("CacheDeptToTrvlDocVend").equals("true"))
      
         {
            if ( DeptToTrvlDocVendCache != null ) return DeptToTrvlDocVendCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "TRVL_DOC_VEND";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToTrvlDocVend").equals("true"))
         {
            DeptToTrvlDocVendCache = new ObjectHashtable();
            for (Enumeration e = (TRVL_DOC_VENDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToTrvlDocVendCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToTrvlDocVendCache.elements());
         }
         else
         {
            return (TRVL_DOC_VENDBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_REIM_FREQ_DTs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_REIM_FREQ_DT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_REIM_FREQ_DT objects.
      */
      public Enumeration getR_REIM_FREQ_DTs1()
      {
      
         if (getSession().getProperty("CacheR_REIM_FREQ_DTs1").equals("true"))
      
         {
            if ( R_REIM_FREQ_DTs1Cache != null ) return R_REIM_FREQ_DTs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_REIM_FREQ_DT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_REIM_FREQ_DTs1").equals("true"))
         {
            R_REIM_FREQ_DTs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_REIM_FREQ_DTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_REIM_FREQ_DTs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_REIM_FREQ_DTs1Cache.elements());
         }
         else
         {
            return (R_REIM_FREQ_DTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_OTPT_PARM_DETs5Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_OTPT_PARM_DET objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_OTPT_PARM_DET objects.
      */
      public Enumeration getR_OTPT_PARM_DETs5()
      {
      
         if (getSession().getProperty("CacheR_OTPT_PARM_DETs5").equals("true"))
      
         {
            if ( R_OTPT_PARM_DETs5Cache != null ) return R_OTPT_PARM_DETs5Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_OTPT_PARM_DET";
            param.fieldName = "IET_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_OTPT_PARM_DETs5").equals("true"))
         {
            R_OTPT_PARM_DETs5Cache = new ObjectHashtable();
            for (Enumeration e = (R_OTPT_PARM_DETBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_OTPT_PARM_DETs5Cache.put(pkey,cacheBO);                        
            }
         
            return (R_OTPT_PARM_DETs5Cache.elements());
         }
         else
         {
            return (R_OTPT_PARM_DETBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_MGRCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_MGR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_MGR objects.
      */
      public Enumeration getR_MGR()
      {
      
         if (getSession().getProperty("CacheR_MGR").equals("true"))
      
         {
            if ( R_MGRCache != null ) return R_MGRCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_MGR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_MGR").equals("true"))
         {
            R_MGRCache = new ObjectHashtable();
            for (Enumeration e = (R_MGRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_MGRCache.put(pkey,cacheBO);                        
            }
         
            return (R_MGRCache.elements());
         }
         else
         {
            return (R_MGRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_GPs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_GP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_GP objects.
      */
      public Enumeration getR_GPs1()
      {
      
         if (getSession().getProperty("CacheR_GPs1").equals("true"))
      
         {
            if ( R_GPs1Cache != null ) return R_GPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_GPs1").equals("true"))
         {
            R_GPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_GPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_GPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_GPs1Cache.elements());
         }
         else
         {
            return (R_GPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToREmplBenMultiCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_EMPL_BEN_MULTI objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_EMPL_BEN_MULTI objects.
      */
      public Enumeration getRDeptToREmplBenMulti()
      {
      
         if (getSession().getProperty("CacheRDeptToREmplBenMulti").equals("true"))
      
         {
            if ( RDeptToREmplBenMultiCache != null ) return RDeptToREmplBenMultiCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_EMPL_BEN_MULTI";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToREmplBenMulti").equals("true"))
         {
            RDeptToREmplBenMultiCache = new ObjectHashtable();
            for (Enumeration e = (R_EMPL_BEN_MULTIBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToREmplBenMultiCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToREmplBenMultiCache.elements());
         }
         else
         {
            return (R_EMPL_BEN_MULTIBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_DRSGRPs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DRSGRP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DRSGRP objects.
      */
      public Enumeration getR_DRSGRPs1()
      {
      
         if (getSession().getProperty("CacheR_DRSGRPs1").equals("true"))
      
         {
            if ( R_DRSGRPs1Cache != null ) return R_DRSGRPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DRSGRP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DRSGRPs1").equals("true"))
         {
            R_DRSGRPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DRSGRPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DRSGRPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DRSGRPs1Cache.elements());
         }
         else
         {
            return (R_DRSGRPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_DOBJs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DOBJ objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DOBJ objects.
      */
      public Enumeration getR_DOBJs1()
      {
      
         if (getSession().getProperty("CacheR_DOBJs1").equals("true"))
      
         {
            if ( R_DOBJs1Cache != null ) return R_DOBJs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DOBJ";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DOBJs1").equals("true"))
         {
            R_DOBJs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DOBJBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DOBJs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DOBJs1Cache.elements());
         }
         else
         {
            return (R_DOBJBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable PO_DOC_HDRCache = null;
        
      /**     
      * <br>
      * method to retrieve the PO_DOC_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of PO_DOC_HDR objects.
      */
      public Enumeration getPO_DOC_HDR()
      {
      
         if (getSession().getProperty("CachePO_DOC_HDR").equals("true"))
      
         {
            if ( PO_DOC_HDRCache != null ) return PO_DOC_HDRCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "PO_DOC_HDR";
            param.fieldName = "RQSTR_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCachePO_DOC_HDR").equals("true"))
         {
            PO_DOC_HDRCache = new ObjectHashtable();
            for (Enumeration e = (PO_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               PO_DOC_HDRCache.put(pkey,cacheBO);                        
            }
         
            return (PO_DOC_HDRCache.elements());
         }
         else
         {
            return (PO_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptVcPrvntCache = null;
        
      /**     
      * <br>
      * method to retrieve the VCC_DOC_PRVNT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of VCC_DOC_PRVNT objects.
      */
      public Enumeration getRDeptVcPrvnt()
      {
      
         if (getSession().getProperty("CacheRDeptVcPrvnt").equals("true"))
      
         {
            if ( RDeptVcPrvntCache != null ) return RDeptVcPrvntCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "VCC_DOC_PRVNT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptVcPrvnt").equals("true"))
         {
            RDeptVcPrvntCache = new ObjectHashtable();
            for (Enumeration e = (VCC_DOC_PRVNTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptVcPrvntCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptVcPrvntCache.elements());
         }
         else
         {
            return (VCC_DOC_PRVNTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_PROG_GIS_LOCCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PROG_GIS_LOC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PROG_GIS_LOC objects.
      */
      public Enumeration getR_PROG_GIS_LOC()
      {
      
         if (getSession().getProperty("CacheR_PROG_GIS_LOC").equals("true"))
      
         {
            if ( R_PROG_GIS_LOCCache != null ) return R_PROG_GIS_LOCCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PROG_GIS_LOC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_PROG_GIS_LOC").equals("true"))
         {
            R_PROG_GIS_LOCCache = new ObjectHashtable();
            for (Enumeration e = (R_PROG_GIS_LOCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_PROG_GIS_LOCCache.put(pkey,cacheBO);                        
            }
         
            return (R_PROG_GIS_LOCCache.elements());
         }
         else
         {
            return (R_PROG_GIS_LOCBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToPartTypCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PART_TYP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PART_TYP objects.
      */
      public Enumeration getDeptToPartTyp()
      {
      
         if (getSession().getProperty("CacheDeptToPartTyp").equals("true"))
      
         {
            if ( DeptToPartTypCache != null ) return DeptToPartTypCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PART_TYP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToPartTyp").equals("true"))
         {
            DeptToPartTypCache = new ObjectHashtable();
            for (Enumeration e = (R_PART_TYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToPartTypCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToPartTypCache.elements());
         }
         else
         {
            return (R_PART_TYPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_LCATs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_LCAT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_LCAT objects.
      */
      public Enumeration getR_LCATs1()
      {
      
         if (getSession().getProperty("CacheR_LCATs1").equals("true"))
      
         {
            if ( R_LCATs1Cache != null ) return R_LCATs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_LCAT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_LCATs1").equals("true"))
         {
            R_LCATs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_LCATBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_LCATs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_LCATs1Cache.elements());
         }
         else
         {
            return (R_LCATBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRGrntAlrtUserCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_GRNT_ALRT_USER objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_GRNT_ALRT_USER objects.
      */
      public Enumeration getRDeptToRGrntAlrtUser()
      {
      
         if (getSession().getProperty("CacheRDeptToRGrntAlrtUser").equals("true"))
      
         {
            if ( RDeptToRGrntAlrtUserCache != null ) return RDeptToRGrntAlrtUserCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_ALRT_USER";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntAlrtUser").equals("true"))
         {
            RDeptToRGrntAlrtUserCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_ALRT_USERBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntAlrtUserCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntAlrtUserCache.elements());
         }
         else
         {
            return (R_GRNT_ALRT_USERBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRFndgGrpCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FNDG_GRP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FNDG_GRP objects.
      */
      public Enumeration getRDeptToRFndgGrp()
      {
      
         if (getSession().getProperty("CacheRDeptToRFndgGrp").equals("true"))
      
         {
            if ( RDeptToRFndgGrpCache != null ) return RDeptToRFndgGrpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FNDG_GRP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRFndgGrp").equals("true"))
         {
            RDeptToRFndgGrpCache = new ObjectHashtable();
            for (Enumeration e = (R_FNDG_GRPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRFndgGrpCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRFndgGrpCache.elements());
         }
         else
         {
            return (R_FNDG_GRPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToRFgcCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FGC objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FGC objects.
      */
      public Enumeration getRDeptToRFgc()
      {
      
         if (getSession().getProperty("CacheRDeptToRFgc").equals("true"))
      
         {
            if ( RDeptToRFgcCache != null ) return RDeptToRFgcCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FGC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRFgc").equals("true"))
         {
            RDeptToRFgcCache = new ObjectHashtable();
            for (Enumeration e = (R_FGCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRFgcCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRFgcCache.elements());
         }
         else
         {
            return (R_FGCBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToFarHdrCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FAR_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FAR_HDR objects.
      */
      public Enumeration getRDeptToFarHdr()
      {
      
         if (getSession().getProperty("CacheRDeptToFarHdr").equals("true"))
      
         {
            if ( RDeptToFarHdrCache != null ) return RDeptToFarHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FAR_HDR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToFarHdr").equals("true"))
         {
            RDeptToFarHdrCache = new ObjectHashtable();
            for (Enumeration e = (R_FAR_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToFarHdrCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToFarHdrCache.elements());
         }
         else
         {
            return (R_FAR_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_DRSTYPs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DRSTYP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DRSTYP objects.
      */
      public Enumeration getR_DRSTYPs1()
      {
      
         if (getSession().getProperty("CacheR_DRSTYPs1").equals("true"))
      
         {
            if ( R_DRSTYPs1Cache != null ) return R_DRSTYPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DRSTYP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DRSTYPs1").equals("true"))
         {
            R_DRSTYPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DRSTYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DRSTYPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DRSTYPs1Cache.elements());
         }
         else
         {
            return (R_DRSTYPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_DRSCATs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DRSCAT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DRSCAT objects.
      */
      public Enumeration getR_DRSCATs1()
      {
      
         if (getSession().getProperty("CacheR_DRSCATs1").equals("true"))
      
         {
            if ( R_DRSCATs1Cache != null ) return R_DRSCATs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DRSCAT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DRSCATs1").equals("true"))
         {
            R_DRSCATs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DRSCATBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DRSCATs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DRSCATs1Cache.elements());
         }
         else
         {
            return (R_DRSCATBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_ACTVs6Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_ACTV objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_ACTV objects.
      */
      public Enumeration getR_ACTVs6()
      {
      
         if (getSession().getProperty("CacheR_ACTVs6").equals("true"))
      
         {
            if ( R_ACTVs6Cache != null ) return R_ACTVs6Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ACTV";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_ACTVs6").equals("true"))
         {
            R_ACTVs6Cache = new ObjectHashtable();
            for (Enumeration e = (R_ACTVBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_ACTVs6Cache.put(pkey,cacheBO);                        
            }
         
            return (R_ACTVs6Cache.elements());
         }
         else
         {
            return (R_ACTVBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToPoSrtyInsCache = null;
        
      /**     
      * <br>
      * method to retrieve the PO_DOC_SRTYINS objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of PO_DOC_SRTYINS objects.
      */
      public Enumeration getDeptToPoSrtyIns()
      {
      
         if (getSession().getProperty("CacheDeptToPoSrtyIns").equals("true"))
      
         {
            if ( DeptToPoSrtyInsCache != null ) return DeptToPoSrtyInsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "PO_DOC_SRTYINS";
            param.fieldName = "HLD_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToPoSrtyIns").equals("true"))
         {
            DeptToPoSrtyInsCache = new ObjectHashtable();
            for (Enumeration e = (PO_DOC_SRTYINSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToPoSrtyInsCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToPoSrtyInsCache.elements());
         }
         else
         {
            return (PO_DOC_SRTYINSBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDptToROnPrnParmDfltCache = null;
        
      /**     
      * <br>
      * method to retrieve the ONLN_PRN_PARM_DFLT objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of ONLN_PRN_PARM_DFLT objects.
      */
      public Enumeration getRDptToROnPrnParmDflt()
      {
      
         if (getSession().getProperty("CacheRDptToROnPrnParmDflt").equals("true"))
      
         {
            if ( RDptToROnPrnParmDfltCache != null ) return RDptToROnPrnParmDfltCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ONLN_PRN_PARM_DFLT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDptToROnPrnParmDflt").equals("true"))
         {
            RDptToROnPrnParmDfltCache = new ObjectHashtable();
            for (Enumeration e = (ONLN_PRN_PARM_DFLTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDptToROnPrnParmDfltCache.put(pkey,cacheBO);                        
            }
         
            return (RDptToROnPrnParmDfltCache.elements());
         }
         else
         {
            return (ONLN_PRN_PARM_DFLTBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToInfApBYCache = null;
        
      /**     
      * <br>
      * method to retrieve the INF_APBY objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of INF_APBY objects.
      */
      public Enumeration getDeptToInfApBY()
      {
      
         if (getSession().getProperty("CacheDeptToInfApBY").equals("true"))
      
         {
            if ( DeptToInfApBYCache != null ) return DeptToInfApBYCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_APBY";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfApBY").equals("true"))
         {
            DeptToInfApBYCache = new ObjectHashtable();
            for (Enumeration e = (INF_APBYBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfApBYCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfApBYCache.elements());
         }
         else
         {
            return (INF_APBYBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDeptToGtDocAlrtuserCache = null;
        
      /**     
      * <br>
      * method to retrieve the GT_DOC_ALRTUSER objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of GT_DOC_ALRTUSER objects.
      */
      public Enumeration getRDeptToGtDocAlrtuser()
      {
      
         if (getSession().getProperty("CacheRDeptToGtDocAlrtuser").equals("true"))
      
         {
            if ( RDeptToGtDocAlrtuserCache != null ) return RDeptToGtDocAlrtuserCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_ALRTUSER";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToGtDocAlrtuser").equals("true"))
         {
            RDeptToGtDocAlrtuserCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_ALRTUSERBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToGtDocAlrtuserCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToGtDocAlrtuserCache.elements());
         }
         else
         {
            return (GT_DOC_ALRTUSERBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable FA_DOC_HDRs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the FA_DOC_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of FA_DOC_HDR objects.
      */
      public Enumeration getFA_DOC_HDRs1()
      {
      
         if (getSession().getProperty("CacheFA_DOC_HDRs1").equals("true"))
      
         {
            if ( FA_DOC_HDRs1Cache != null ) return FA_DOC_HDRs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "FA_DOC_HDR";
            param.fieldName = "NEW_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheFA_DOC_HDRs1").equals("true"))
         {
            FA_DOC_HDRs1Cache = new ObjectHashtable();
            for (Enumeration e = (FA_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               FA_DOC_HDRs1Cache.put(pkey,cacheBO);                        
            }
         
            return (FA_DOC_HDRs1Cache.elements());
         }
         else
         {
            return (FA_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToARRADocOngoingCache = null;
        
      /**     
      * <br>
      * method to retrieve the ARRA_DOC_ONGOING objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of ARRA_DOC_ONGOING objects.
      */
      public Enumeration getDeptToARRADocOngoing()
      {
      
         if (getSession().getProperty("CacheDeptToARRADocOngoing").equals("true"))
      
         {
            if ( DeptToARRADocOngoingCache != null ) return DeptToARRADocOngoingCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ARRA_DOC_ONGOING";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToARRADocOngoing").equals("true"))
         {
            DeptToARRADocOngoingCache = new ObjectHashtable();
            for (Enumeration e = (ARRA_DOC_ONGOINGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToARRADocOngoingCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToARRADocOngoingCache.elements());
         }
         else
         {
            return (ARRA_DOC_ONGOINGBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DepartmentToSubRcpntQtrlyAwdCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_SRCPNT_QTRLY_AWD objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_SRCPNT_QTRLY_AWD objects.
      */
      public Enumeration getDepartmentToSubRcpntQtrlyAwd()
      {
      
         if (getSession().getProperty("CacheDepartmentToSubRcpntQtrlyAwd").equals("true"))
      
         {
            if ( DepartmentToSubRcpntQtrlyAwdCache != null ) return DepartmentToSubRcpntQtrlyAwdCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_SRCPNT_QTRLY_AWD";
            param.fieldName = "AWD_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDepartmentToSubRcpntQtrlyAwd").equals("true"))
         {
            DepartmentToSubRcpntQtrlyAwdCache = new ObjectHashtable();
            for (Enumeration e = (R_SRCPNT_QTRLY_AWDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DepartmentToSubRcpntQtrlyAwdCache.put(pkey,cacheBO);                        
            }
         
            return (DepartmentToSubRcpntQtrlyAwdCache.elements());
         }
         else
         {
            return (R_SRCPNT_QTRLY_AWDBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RdeptToRplbsSetpCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_PLBS_SETP objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_PLBS_SETP objects.
      */
      public Enumeration getRdeptToRplbsSetp()
      {
      
         if (getSession().getProperty("CacheRdeptToRplbsSetp").equals("true"))
      
         {
            if ( RdeptToRplbsSetpCache != null ) return RdeptToRplbsSetpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PLBS_SETP";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToRplbsSetp").equals("true"))
         {
            RdeptToRplbsSetpCache = new ObjectHashtable();
            for (Enumeration e = (R_PLBS_SETPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToRplbsSetpCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToRplbsSetpCache.elements());
         }
         else
         {
            return (R_PLBS_SETPBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_OTPT_PARM_DETs4Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_OTPT_PARM_DET objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_OTPT_PARM_DET objects.
      */
      public Enumeration getR_OTPT_PARM_DETs4()
      {
      
         if (getSession().getProperty("CacheR_OTPT_PARM_DETs4").equals("true"))
      
         {
            if ( R_OTPT_PARM_DETs4Cache != null ) return R_OTPT_PARM_DETs4Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_OTPT_PARM_DET";
            param.fieldName = "RE_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_OTPT_PARM_DETs4").equals("true"))
         {
            R_OTPT_PARM_DETs4Cache = new ObjectHashtable();
            for (Enumeration e = (R_OTPT_PARM_DETBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_OTPT_PARM_DETs4Cache.put(pkey,cacheBO);                        
            }
         
            return (R_OTPT_PARM_DETs4Cache.elements());
         }
         else
         {
            return (R_OTPT_PARM_DETBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RIntCstOtMultiToRDept1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_INT_CST_OT_MULTI objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_INT_CST_OT_MULTI objects.
      */
      public Enumeration getRIntCstOtMultiToRDept1()
      {
      
         if (getSession().getProperty("CacheRIntCstOtMultiToRDept1").equals("true"))
      
         {
            if ( RIntCstOtMultiToRDept1Cache != null ) return RIntCstOtMultiToRDept1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_INT_CST_OT_MULTI";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRIntCstOtMultiToRDept1").equals("true"))
         {
            RIntCstOtMultiToRDept1Cache = new ObjectHashtable();
            for (Enumeration e = (R_INT_CST_OT_MULTIBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RIntCstOtMultiToRDept1Cache.put(pkey,cacheBO);                        
            }
         
            return (RIntCstOtMultiToRDept1Cache.elements());
         }
         else
         {
            return (R_INT_CST_OT_MULTIBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_FNCLSs1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_FNCLS objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_FNCLS objects.
      */
      public Enumeration getR_FNCLSs1()
      {
      
         if (getSession().getProperty("CacheR_FNCLSs1").equals("true"))
      
         {
            if ( R_FNCLSs1Cache != null ) return R_FNCLSs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FNCLS";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_FNCLSs1").equals("true"))
         {
            R_FNCLSs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_FNCLSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_FNCLSs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_FNCLSs1Cache.elements());
         }
         else
         {
            return (R_FNCLSBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_DISB_MGMT_RSTR_1Cache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DISB_MGMT_RSTR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DISB_MGMT_RSTR objects.
      */
      public Enumeration getR_DISB_MGMT_RSTR_1()
      {
      
         if (getSession().getProperty("CacheR_DISB_MGMT_RSTR_1").equals("true"))
      
         {
            if ( R_DISB_MGMT_RSTR_1Cache != null ) return R_DISB_MGMT_RSTR_1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DISB_MGMT_RSTR";
            param.fieldName = "AWD_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DISB_MGMT_RSTR_1").equals("true"))
         {
            R_DISB_MGMT_RSTR_1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DISB_MGMT_RSTRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DISB_MGMT_RSTR_1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DISB_MGMT_RSTR_1Cache.elements());
         }
         else
         {
            return (R_DISB_MGMT_RSTRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_DISB_MGMT_RSTRCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_DISB_MGMT_RSTR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_DISB_MGMT_RSTR objects.
      */
      public Enumeration getR_DISB_MGMT_RSTR()
      {
      
         if (getSession().getProperty("CacheR_DISB_MGMT_RSTR").equals("true"))
      
         {
            if ( R_DISB_MGMT_RSTRCache != null ) return R_DISB_MGMT_RSTRCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DISB_MGMT_RSTR";
            param.fieldName = "PR_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DISB_MGMT_RSTR").equals("true"))
         {
            R_DISB_MGMT_RSTRCache = new ObjectHashtable();
            for (Enumeration e = (R_DISB_MGMT_RSTRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DISB_MGMT_RSTRCache.put(pkey,cacheBO);                        
            }
         
            return (R_DISB_MGMT_RSTRCache.elements());
         }
         else
         {
            return (R_DISB_MGMT_RSTRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable R_CMIA_INTR_PARMsCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_CMIA_INTR_PARM objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_CMIA_INTR_PARM objects.
      */
      public Enumeration getR_CMIA_INTR_PARMs()
      {
      
         if (getSession().getProperty("CacheR_CMIA_INTR_PARMs").equals("true"))
      
         {
            if ( R_CMIA_INTR_PARMsCache != null ) return R_CMIA_INTR_PARMsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CMIA_INTR_PARM";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_CMIA_INTR_PARMs").equals("true"))
         {
            R_CMIA_INTR_PARMsCache = new ObjectHashtable();
            for (Enumeration e = (R_CMIA_INTR_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_CMIA_INTR_PARMsCache.put(pkey,cacheBO);                        
            }
         
            return (R_CMIA_INTR_PARMsCache.elements());
         }
         else
         {
            return (R_CMIA_INTR_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable RDept_RBfyStpfRevCache = null;
        
      /**     
      * <br>
      * method to retrieve the R_BFY_STPF_REV objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of R_BFY_STPF_REV objects.
      */
      public Enumeration getRDept_RBfyStpfRev()
      {
      
         if (getSession().getProperty("CacheRDept_RBfyStpfRev").equals("true"))
      
         {
            if ( RDept_RBfyStpfRevCache != null ) return RDept_RBfyStpfRevCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_BFY_STPF_REV";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDept_RBfyStpfRev").equals("true"))
         {
            RDept_RBfyStpfRevCache = new ObjectHashtable();
            for (Enumeration e = (R_BFY_STPF_REVBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDept_RBfyStpfRevCache.put(pkey,cacheBO);                        
            }
         
            return (RDept_RBfyStpfRevCache.elements());
         }
         else
         {
            return (R_BFY_STPF_REVBaseImpl.getObjects(searchReq ,getSession()));
         }
      }
   
   
      private ObjectHashtable DeptToIctDocActgCache = null;
        
      /**     
      * <br>
      * method to retrieve the ICT_DOC_HDR objects for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of ICT_DOC_HDR objects.
      */
      public Enumeration getDeptToIctDocActg()
      {
      
         if (getSession().getProperty("CacheDeptToIctDocActg").equals("true"))
      
         {
            if ( DeptToIctDocActgCache != null ) return DeptToIctDocActgCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ICT_DOC_HDR";
            param.fieldName = "EMPL_HM_DEPT";
            param.value = getData(miDEPT_CD).getString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToIctDocActg").equals("true"))
         {
            DeptToIctDocActgCache = new ObjectHashtable();
            for (Enumeration e = (ICT_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToIctDocActgCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToIctDocActgCache.elements());
         }
         else
         {
            return (ICT_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
      }

     /**     
      * <br>
      * method to retrieve the old ARRA_DOC_ONGOING objects for this R_DEPT
      * old ARRA_DOC_ONGOING objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old ARRA_DOC_ONGOING objects.
      */
  public Enumeration getOldDeptCAToARRADocOngoing(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptCAToARRADocOngoing");
    if (cache)
      getSession().setProperty("NoCacheDeptCAToARRADocOngoing", "false");
    else
      getSession().setProperty("NoCacheDeptCAToARRADocOngoing", "true");

    try {
      return getOldDeptCAToARRADocOngoing();
    } finally {
        getSession().setProperty("NoCacheDeptCAToARRADocOngoing", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old ARRA_DOC_ONGOING objects for this R_DEPT
      * old ARRA_DOC_ONGOING objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old ARRA_DOC_ONGOING objects.
      */
      public Enumeration   getOldDeptCAToARRADocOngoing()
      {
         
         if (!getSession().getProperty("NoCacheDeptCAToARRADocOngoing").equals("true"))
         
         {
            if ( DeptCAToARRADocOngoingCache != null ) return DeptCAToARRADocOngoingCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ARRA_DOC_ONGOING";
            param.fieldName = "CA_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptCAToARRADocOngoing").equals("true"))
         {
            DeptCAToARRADocOngoingCache = new ObjectHashtable();
            for (Enumeration e = (ARRA_DOC_ONGOINGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptCAToARRADocOngoingCache.put(pkey,cacheBO);                        
            }
         
            return (DeptCAToARRADocOngoingCache.elements());
         }
         else
         {
         
            return (ARRA_DOC_ONGOINGBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old CAM_DOC_MJRPROG objects for this R_DEPT
      * old CAM_DOC_MJRPROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old CAM_DOC_MJRPROG objects.
      */
  public Enumeration getOldDeptToCAMMjrProgDoc(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToCAMMjrProgDoc");
    if (cache)
      getSession().setProperty("NoCacheDeptToCAMMjrProgDoc", "false");
    else
      getSession().setProperty("NoCacheDeptToCAMMjrProgDoc", "true");

    try {
      return getOldDeptToCAMMjrProgDoc();
    } finally {
        getSession().setProperty("NoCacheDeptToCAMMjrProgDoc", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old CAM_DOC_MJRPROG objects for this R_DEPT
      * old CAM_DOC_MJRPROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old CAM_DOC_MJRPROG objects.
      */
      public Enumeration   getOldDeptToCAMMjrProgDoc()
      {
         
         if (!getSession().getProperty("NoCacheDeptToCAMMjrProgDoc").equals("true"))
         
         {
            if ( DeptToCAMMjrProgDocCache != null ) return DeptToCAMMjrProgDocCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CAM_DOC_MJRPROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCAMMjrProgDoc").equals("true"))
         {
            DeptToCAMMjrProgDocCache = new ObjectHashtable();
            for (Enumeration e = (CAM_DOC_MJRPROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCAMMjrProgDocCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCAMMjrProgDocCache.elements());
         }
         else
         {
         
            return (CAM_DOC_MJRPROGBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old CAS_DOC_MJRPROG objects for this R_DEPT
      * old CAS_DOC_MJRPROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old CAS_DOC_MJRPROG objects.
      */
  public Enumeration getOldDeptToCASMjrProgDoc(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToCASMjrProgDoc");
    if (cache)
      getSession().setProperty("NoCacheDeptToCASMjrProgDoc", "false");
    else
      getSession().setProperty("NoCacheDeptToCASMjrProgDoc", "true");

    try {
      return getOldDeptToCASMjrProgDoc();
    } finally {
        getSession().setProperty("NoCacheDeptToCASMjrProgDoc", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old CAS_DOC_MJRPROG objects for this R_DEPT
      * old CAS_DOC_MJRPROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old CAS_DOC_MJRPROG objects.
      */
      public Enumeration   getOldDeptToCASMjrProgDoc()
      {
         
         if (!getSession().getProperty("NoCacheDeptToCASMjrProgDoc").equals("true"))
         
         {
            if ( DeptToCASMjrProgDocCache != null ) return DeptToCASMjrProgDocCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CAS_DOC_MJRPROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCASMjrProgDoc").equals("true"))
         {
            DeptToCASMjrProgDocCache = new ObjectHashtable();
            for (Enumeration e = (CAS_DOC_MJRPROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCASMjrProgDocCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCASMjrProgDocCache.elements());
         }
         else
         {
         
            return (CAS_DOC_MJRPROGBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old CVEX_FUND_DEPT objects for this R_DEPT
      * old CVEX_FUND_DEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old CVEX_FUND_DEPT objects.
      */
  public Enumeration getOldCVEX_FUND_DEPTs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheCVEX_FUND_DEPTs");
    if (cache)
      getSession().setProperty("NoCacheCVEX_FUND_DEPTs", "false");
    else
      getSession().setProperty("NoCacheCVEX_FUND_DEPTs", "true");

    try {
      return getOldCVEX_FUND_DEPTs();
    } finally {
        getSession().setProperty("NoCacheCVEX_FUND_DEPTs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old CVEX_FUND_DEPT objects for this R_DEPT
      * old CVEX_FUND_DEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old CVEX_FUND_DEPT objects.
      */
      public Enumeration   getOldCVEX_FUND_DEPTs()
      {
         
         if (!getSession().getProperty("NoCacheCVEX_FUND_DEPTs").equals("true"))
         
         {
            if ( CVEX_FUND_DEPTsCache != null ) return CVEX_FUND_DEPTsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CVEX_FUND_DEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheCVEX_FUND_DEPTs").equals("true"))
         {
            CVEX_FUND_DEPTsCache = new ObjectHashtable();
            for (Enumeration e = (CVEX_FUND_DEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               CVEX_FUND_DEPTsCache.put(pkey,cacheBO);                        
            }
         
            return (CVEX_FUND_DEPTsCache.elements());
         }
         else
         {
         
            return (CVEX_FUND_DEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old CVIN_FUND_DEPT objects for this R_DEPT
      * old CVIN_FUND_DEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old CVIN_FUND_DEPT objects.
      */
  public Enumeration getOldCVIN_FUND_DEPTs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheCVIN_FUND_DEPTs");
    if (cache)
      getSession().setProperty("NoCacheCVIN_FUND_DEPTs", "false");
    else
      getSession().setProperty("NoCacheCVIN_FUND_DEPTs", "true");

    try {
      return getOldCVIN_FUND_DEPTs();
    } finally {
        getSession().setProperty("NoCacheCVIN_FUND_DEPTs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old CVIN_FUND_DEPT objects for this R_DEPT
      * old CVIN_FUND_DEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old CVIN_FUND_DEPT objects.
      */
      public Enumeration   getOldCVIN_FUND_DEPTs()
      {
         
         if (!getSession().getProperty("NoCacheCVIN_FUND_DEPTs").equals("true"))
         
         {
            if ( CVIN_FUND_DEPTsCache != null ) return CVIN_FUND_DEPTsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CVIN_FUND_DEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheCVIN_FUND_DEPTs").equals("true"))
         {
            CVIN_FUND_DEPTsCache = new ObjectHashtable();
            for (Enumeration e = (CVIN_FUND_DEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               CVIN_FUND_DEPTsCache.put(pkey,cacheBO);                        
            }
         
            return (CVIN_FUND_DEPTsCache.elements());
         }
         else
         {
         
            return (CVIN_FUND_DEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old CVIN_STRU44L3_REQ objects for this R_DEPT
      * old CVIN_STRU44L3_REQ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old CVIN_STRU44L3_REQ objects.
      */
  public Enumeration getOldRDeptToCvinStru44L3Req(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToCvinStru44L3Req");
    if (cache)
      getSession().setProperty("NoCacheRDeptToCvinStru44L3Req", "false");
    else
      getSession().setProperty("NoCacheRDeptToCvinStru44L3Req", "true");

    try {
      return getOldRDeptToCvinStru44L3Req();
    } finally {
        getSession().setProperty("NoCacheRDeptToCvinStru44L3Req", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old CVIN_STRU44L3_REQ objects for this R_DEPT
      * old CVIN_STRU44L3_REQ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old CVIN_STRU44L3_REQ objects.
      */
      public Enumeration   getOldRDeptToCvinStru44L3Req()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToCvinStru44L3Req").equals("true"))
         
         {
            if ( RDeptToCvinStru44L3ReqCache != null ) return RDeptToCvinStru44L3ReqCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CVIN_STRU44L3_REQ";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToCvinStru44L3Req").equals("true"))
         {
            RDeptToCvinStru44L3ReqCache = new ObjectHashtable();
            for (Enumeration e = (CVIN_STRU44L3_REQBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToCvinStru44L3ReqCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToCvinStru44L3ReqCache.elements());
         }
         else
         {
         
            return (CVIN_STRU44L3_REQBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old CVIN_STRU45L3_REQ objects for this R_DEPT
      * old CVIN_STRU45L3_REQ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old CVIN_STRU45L3_REQ objects.
      */
  public Enumeration getOldDeptToCvinStru45L3Req(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToCvinStru45L3Req");
    if (cache)
      getSession().setProperty("NoCacheDeptToCvinStru45L3Req", "false");
    else
      getSession().setProperty("NoCacheDeptToCvinStru45L3Req", "true");

    try {
      return getOldDeptToCvinStru45L3Req();
    } finally {
        getSession().setProperty("NoCacheDeptToCvinStru45L3Req", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old CVIN_STRU45L3_REQ objects for this R_DEPT
      * old CVIN_STRU45L3_REQ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old CVIN_STRU45L3_REQ objects.
      */
      public Enumeration   getOldDeptToCvinStru45L3Req()
      {
         
         if (!getSession().getProperty("NoCacheDeptToCvinStru45L3Req").equals("true"))
         
         {
            if ( DeptToCvinStru45L3ReqCache != null ) return DeptToCvinStru45L3ReqCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CVIN_STRU45L3_REQ";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCvinStru45L3Req").equals("true"))
         {
            DeptToCvinStru45L3ReqCache = new ObjectHashtable();
            for (Enumeration e = (CVIN_STRU45L3_REQBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCvinStru45L3ReqCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCvinStru45L3ReqCache.elements());
         }
         else
         {
         
            return (CVIN_STRU45L3_REQBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old CVIN_UNIT_PROG objects for this R_DEPT
      * old CVIN_UNIT_PROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old CVIN_UNIT_PROG objects.
      */
  public Enumeration getOldDeptToUnitProg(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToUnitProg");
    if (cache)
      getSession().setProperty("NoCacheDeptToUnitProg", "false");
    else
      getSession().setProperty("NoCacheDeptToUnitProg", "true");

    try {
      return getOldDeptToUnitProg();
    } finally {
        getSession().setProperty("NoCacheDeptToUnitProg", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old CVIN_UNIT_PROG objects for this R_DEPT
      * old CVIN_UNIT_PROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old CVIN_UNIT_PROG objects.
      */
      public Enumeration   getOldDeptToUnitProg()
      {
         
         if (!getSession().getProperty("NoCacheDeptToUnitProg").equals("true"))
         
         {
            if ( DeptToUnitProgCache != null ) return DeptToUnitProgCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CVIN_UNIT_PROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToUnitProg").equals("true"))
         {
            DeptToUnitProgCache = new ObjectHashtable();
            for (Enumeration e = (CVIN_UNIT_PROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToUnitProgCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToUnitProgCache.elements());
         }
         else
         {
         
            return (CVIN_UNIT_PROGBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old DOC_COA objects for this R_DEPT
      * old DOC_COA objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old DOC_COA objects.
      */
  public Enumeration getOldDOC_COAs28(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDOC_COAs28");
    if (cache)
      getSession().setProperty("NoCacheDOC_COAs28", "false");
    else
      getSession().setProperty("NoCacheDOC_COAs28", "true");

    try {
      return getOldDOC_COAs28();
    } finally {
        getSession().setProperty("NoCacheDOC_COAs28", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old DOC_COA objects for this R_DEPT
      * old DOC_COA objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old DOC_COA objects.
      */
      public Enumeration   getOldDOC_COAs28()
      {
         
         if (!getSession().getProperty("NoCacheDOC_COAs28").equals("true"))
         
         {
            if ( DOC_COAs28Cache != null ) return DOC_COAs28Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "DOC_COA";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDOC_COAs28").equals("true"))
         {
            DOC_COAs28Cache = new ObjectHashtable();
            for (Enumeration e = (DOC_COABaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DOC_COAs28Cache.put(pkey,cacheBO);                        
            }
         
            return (DOC_COAs28Cache.elements());
         }
         else
         {
         
            return (DOC_COABaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old DOC_INT_COA objects for this R_DEPT
      * old DOC_INT_COA objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old DOC_INT_COA objects.
      */
  public Enumeration getOldDeptDocIntCoa(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptDocIntCoa");
    if (cache)
      getSession().setProperty("NoCacheDeptDocIntCoa", "false");
    else
      getSession().setProperty("NoCacheDeptDocIntCoa", "true");

    try {
      return getOldDeptDocIntCoa();
    } finally {
        getSession().setProperty("NoCacheDeptDocIntCoa", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old DOC_INT_COA objects for this R_DEPT
      * old DOC_INT_COA objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old DOC_INT_COA objects.
      */
      public Enumeration   getOldDeptDocIntCoa()
      {
         
         if (!getSession().getProperty("NoCacheDeptDocIntCoa").equals("true"))
         
         {
            if ( DeptDocIntCoaCache != null ) return DeptDocIntCoaCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "DOC_INT_COA";
            param.fieldName = "IG_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptDocIntCoa").equals("true"))
         {
            DeptDocIntCoaCache = new ObjectHashtable();
            for (Enumeration e = (DOC_INT_COABaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptDocIntCoaCache.put(pkey,cacheBO);                        
            }
         
            return (DeptDocIntCoaCache.elements());
         }
         else
         {
         
            return (DOC_INT_COABaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old GT_DOC_COMN objects for this R_DEPT
      * old GT_DOC_COMN objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old GT_DOC_COMN objects.
      */
  public Enumeration getOldRDeptToGtDocComn(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToGtDocComn");
    if (cache)
      getSession().setProperty("NoCacheRDeptToGtDocComn", "false");
    else
      getSession().setProperty("NoCacheRDeptToGtDocComn", "true");

    try {
      return getOldRDeptToGtDocComn();
    } finally {
        getSession().setProperty("NoCacheRDeptToGtDocComn", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old GT_DOC_COMN objects for this R_DEPT
      * old GT_DOC_COMN objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old GT_DOC_COMN objects.
      */
      public Enumeration   getOldRDeptToGtDocComn()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToGtDocComn").equals("true"))
         
         {
            if ( RDeptToGtDocComnCache != null ) return RDeptToGtDocComnCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_COMN";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToGtDocComn").equals("true"))
         {
            RDeptToGtDocComnCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_COMNBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToGtDocComnCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToGtDocComnCache.elements());
         }
         else
         {
         
            return (GT_DOC_COMNBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old GT_DOC_NOTIFUSR objects for this R_DEPT
      * old GT_DOC_NOTIFUSR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old GT_DOC_NOTIFUSR objects.
      */
  public Enumeration getOldDeptToGtDocNotifUsr(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToGtDocNotifUsr");
    if (cache)
      getSession().setProperty("NoCacheDeptToGtDocNotifUsr", "false");
    else
      getSession().setProperty("NoCacheDeptToGtDocNotifUsr", "true");

    try {
      return getOldDeptToGtDocNotifUsr();
    } finally {
        getSession().setProperty("NoCacheDeptToGtDocNotifUsr", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old GT_DOC_NOTIFUSR objects for this R_DEPT
      * old GT_DOC_NOTIFUSR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old GT_DOC_NOTIFUSR objects.
      */
      public Enumeration   getOldDeptToGtDocNotifUsr()
      {
         
         if (!getSession().getProperty("NoCacheDeptToGtDocNotifUsr").equals("true"))
         
         {
            if ( DeptToGtDocNotifUsrCache != null ) return DeptToGtDocNotifUsrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_NOTIFUSR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGtDocNotifUsr").equals("true"))
         {
            DeptToGtDocNotifUsrCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_NOTIFUSRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGtDocNotifUsrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGtDocNotifUsrCache.elements());
         }
         else
         {
         
            return (GT_DOC_NOTIFUSRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old GT_DOC_OPTY objects for this R_DEPT
      * old GT_DOC_OPTY objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old GT_DOC_OPTY objects.
      */
  public Enumeration getOldDeptToGtDocOpty(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToGtDocOpty");
    if (cache)
      getSession().setProperty("NoCacheDeptToGtDocOpty", "false");
    else
      getSession().setProperty("NoCacheDeptToGtDocOpty", "true");

    try {
      return getOldDeptToGtDocOpty();
    } finally {
        getSession().setProperty("NoCacheDeptToGtDocOpty", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old GT_DOC_OPTY objects for this R_DEPT
      * old GT_DOC_OPTY objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old GT_DOC_OPTY objects.
      */
      public Enumeration   getOldDeptToGtDocOpty()
      {
         
         if (!getSession().getProperty("NoCacheDeptToGtDocOpty").equals("true"))
         
         {
            if ( DeptToGtDocOptyCache != null ) return DeptToGtDocOptyCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_OPTY";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGtDocOpty").equals("true"))
         {
            DeptToGtDocOptyCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_OPTYBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGtDocOptyCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGtDocOptyCache.elements());
         }
         else
         {
         
            return (GT_DOC_OPTYBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old GT_DOC_RESP objects for this R_DEPT
      * old GT_DOC_RESP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old GT_DOC_RESP objects.
      */
  public Enumeration getOldDeptToGtDocResp(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToGtDocResp");
    if (cache)
      getSession().setProperty("NoCacheDeptToGtDocResp", "false");
    else
      getSession().setProperty("NoCacheDeptToGtDocResp", "true");

    try {
      return getOldDeptToGtDocResp();
    } finally {
        getSession().setProperty("NoCacheDeptToGtDocResp", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old GT_DOC_RESP objects for this R_DEPT
      * old GT_DOC_RESP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old GT_DOC_RESP objects.
      */
      public Enumeration   getOldDeptToGtDocResp()
      {
         
         if (!getSession().getProperty("NoCacheDeptToGtDocResp").equals("true"))
         
         {
            if ( DeptToGtDocRespCache != null ) return DeptToGtDocRespCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_RESP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGtDocResp").equals("true"))
         {
            DeptToGtDocRespCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_RESPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGtDocRespCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGtDocRespCache.elements());
         }
         else
         {
         
            return (GT_DOC_RESPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_APPR_FUNC_OTYP objects for this R_DEPT
      * old INF_APPR_FUNC_OTYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_APPR_FUNC_OTYP objects.
      */
  public Enumeration getOldDeptToInfApprFuncOtyp(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToInfApprFuncOtyp");
    if (cache)
      getSession().setProperty("NoCacheDeptToInfApprFuncOtyp", "false");
    else
      getSession().setProperty("NoCacheDeptToInfApprFuncOtyp", "true");

    try {
      return getOldDeptToInfApprFuncOtyp();
    } finally {
        getSession().setProperty("NoCacheDeptToInfApprFuncOtyp", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_APPR_FUNC_OTYP objects for this R_DEPT
      * old INF_APPR_FUNC_OTYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_APPR_FUNC_OTYP objects.
      */
      public Enumeration   getOldDeptToInfApprFuncOtyp()
      {
         
         if (!getSession().getProperty("NoCacheDeptToInfApprFuncOtyp").equals("true"))
         
         {
            if ( DeptToInfApprFuncOtypCache != null ) return DeptToInfApprFuncOtypCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_APPR_FUNC_OTYP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfApprFuncOtyp").equals("true"))
         {
            DeptToInfApprFuncOtypCache = new ObjectHashtable();
            for (Enumeration e = (INF_APPR_FUNC_OTYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfApprFuncOtypCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfApprFuncOtypCache.elements());
         }
         else
         {
         
            return (INF_APPR_FUNC_OTYPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_APPR_RSRC objects for this R_DEPT
      * old INF_APPR_RSRC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_APPR_RSRC objects.
      */
  public Enumeration getOldRsrcApprInfRecs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRsrcApprInfRecs");
    if (cache)
      getSession().setProperty("NoCacheRsrcApprInfRecs", "false");
    else
      getSession().setProperty("NoCacheRsrcApprInfRecs", "true");

    try {
      return getOldRsrcApprInfRecs();
    } finally {
        getSession().setProperty("NoCacheRsrcApprInfRecs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_APPR_RSRC objects for this R_DEPT
      * old INF_APPR_RSRC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_APPR_RSRC objects.
      */
      public Enumeration   getOldRsrcApprInfRecs()
      {
         
         if (!getSession().getProperty("NoCacheRsrcApprInfRecs").equals("true"))
         
         {
            if ( RsrcApprInfRecsCache != null ) return RsrcApprInfRecsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_APPR_RSRC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRsrcApprInfRecs").equals("true"))
         {
            RsrcApprInfRecsCache = new ObjectHashtable();
            for (Enumeration e = (INF_APPR_RSRCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RsrcApprInfRecsCache.put(pkey,cacheBO);                        
            }
         
            return (RsrcApprInfRecsCache.elements());
         }
         else
         {
         
            return (INF_APPR_RSRCBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_BFY objects for this R_DEPT
      * old INF_BFY objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_BFY objects.
      */
  public Enumeration getOldINF_BFYs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheINF_BFYs1");
    if (cache)
      getSession().setProperty("NoCacheINF_BFYs1", "false");
    else
      getSession().setProperty("NoCacheINF_BFYs1", "true");

    try {
      return getOldINF_BFYs1();
    } finally {
        getSession().setProperty("NoCacheINF_BFYs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_BFY objects for this R_DEPT
      * old INF_BFY objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_BFY objects.
      */
      public Enumeration   getOldINF_BFYs1()
      {
         
         if (!getSession().getProperty("NoCacheINF_BFYs1").equals("true"))
         
         {
            if ( INF_BFYs1Cache != null ) return INF_BFYs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_BFY";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheINF_BFYs1").equals("true"))
         {
            INF_BFYs1Cache = new ObjectHashtable();
            for (Enumeration e = (INF_BFYBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               INF_BFYs1Cache.put(pkey,cacheBO);                        
            }
         
            return (INF_BFYs1Cache.elements());
         }
         else
         {
         
            return (INF_BFYBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_DEPT_UNIT objects for this R_DEPT
      * old INF_DEPT_UNIT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_DEPT_UNIT objects.
      */
  public Enumeration getOldInfDeptUnitToDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheInfDeptUnitToDept");
    if (cache)
      getSession().setProperty("NoCacheInfDeptUnitToDept", "false");
    else
      getSession().setProperty("NoCacheInfDeptUnitToDept", "true");

    try {
      return getOldInfDeptUnitToDept();
    } finally {
        getSession().setProperty("NoCacheInfDeptUnitToDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_DEPT_UNIT objects for this R_DEPT
      * old INF_DEPT_UNIT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_DEPT_UNIT objects.
      */
      public Enumeration   getOldInfDeptUnitToDept()
      {
         
         if (!getSession().getProperty("NoCacheInfDeptUnitToDept").equals("true"))
         
         {
            if ( InfDeptUnitToDeptCache != null ) return InfDeptUnitToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_DEPT_UNIT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheInfDeptUnitToDept").equals("true"))
         {
            InfDeptUnitToDeptCache = new ObjectHashtable();
            for (Enumeration e = (INF_DEPT_UNITBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               InfDeptUnitToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (InfDeptUnitToDeptCache.elements());
         }
         else
         {
         
            return (INF_DEPT_UNITBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_FPI_6 objects for this R_DEPT
      * old INF_FPI_6 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_FPI_6 objects.
      */
  public Enumeration getOldDeptToInfFpi6(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToInfFpi6");
    if (cache)
      getSession().setProperty("NoCacheDeptToInfFpi6", "false");
    else
      getSession().setProperty("NoCacheDeptToInfFpi6", "true");

    try {
      return getOldDeptToInfFpi6();
    } finally {
        getSession().setProperty("NoCacheDeptToInfFpi6", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_FPI_6 objects for this R_DEPT
      * old INF_FPI_6 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_FPI_6 objects.
      */
      public Enumeration   getOldDeptToInfFpi6()
      {
         
         if (!getSession().getProperty("NoCacheDeptToInfFpi6").equals("true"))
         
         {
            if ( DeptToInfFpi6Cache != null ) return DeptToInfFpi6Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPI_6";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfFpi6").equals("true"))
         {
            DeptToInfFpi6Cache = new ObjectHashtable();
            for (Enumeration e = (INF_FPI_6BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfFpi6Cache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfFpi6Cache.elements());
         }
         else
         {
         
            return (INF_FPI_6BaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_FPRL_1 objects for this R_DEPT
      * old INF_FPRL_1 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_FPRL_1 objects.
      */
  public Enumeration getOldINF_FPRL_12(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheINF_FPRL_12");
    if (cache)
      getSession().setProperty("NoCacheINF_FPRL_12", "false");
    else
      getSession().setProperty("NoCacheINF_FPRL_12", "true");

    try {
      return getOldINF_FPRL_12();
    } finally {
        getSession().setProperty("NoCacheINF_FPRL_12", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_FPRL_1 objects for this R_DEPT
      * old INF_FPRL_1 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_FPRL_1 objects.
      */
      public Enumeration   getOldINF_FPRL_12()
      {
         
         if (!getSession().getProperty("NoCacheINF_FPRL_12").equals("true"))
         
         {
            if ( INF_FPRL_12Cache != null ) return INF_FPRL_12Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPRL_1";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheINF_FPRL_12").equals("true"))
         {
            INF_FPRL_12Cache = new ObjectHashtable();
            for (Enumeration e = (INF_FPRL_1BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               INF_FPRL_12Cache.put(pkey,cacheBO);                        
            }
         
            return (INF_FPRL_12Cache.elements());
         }
         else
         {
         
            return (INF_FPRL_1BaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_FPRL_2 objects for this R_DEPT
      * old INF_FPRL_2 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_FPRL_2 objects.
      */
  public Enumeration getOldINF_FPRL_21(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheINF_FPRL_21");
    if (cache)
      getSession().setProperty("NoCacheINF_FPRL_21", "false");
    else
      getSession().setProperty("NoCacheINF_FPRL_21", "true");

    try {
      return getOldINF_FPRL_21();
    } finally {
        getSession().setProperty("NoCacheINF_FPRL_21", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_FPRL_2 objects for this R_DEPT
      * old INF_FPRL_2 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_FPRL_2 objects.
      */
      public Enumeration   getOldINF_FPRL_21()
      {
         
         if (!getSession().getProperty("NoCacheINF_FPRL_21").equals("true"))
         
         {
            if ( INF_FPRL_21Cache != null ) return INF_FPRL_21Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPRL_2";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheINF_FPRL_21").equals("true"))
         {
            INF_FPRL_21Cache = new ObjectHashtable();
            for (Enumeration e = (INF_FPRL_2BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               INF_FPRL_21Cache.put(pkey,cacheBO);                        
            }
         
            return (INF_FPRL_21Cache.elements());
         }
         else
         {
         
            return (INF_FPRL_2BaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_FPRL_3 objects for this R_DEPT
      * old INF_FPRL_3 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_FPRL_3 objects.
      */
  public Enumeration getOldINF_FPRL_32(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheINF_FPRL_32");
    if (cache)
      getSession().setProperty("NoCacheINF_FPRL_32", "false");
    else
      getSession().setProperty("NoCacheINF_FPRL_32", "true");

    try {
      return getOldINF_FPRL_32();
    } finally {
        getSession().setProperty("NoCacheINF_FPRL_32", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_FPRL_3 objects for this R_DEPT
      * old INF_FPRL_3 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_FPRL_3 objects.
      */
      public Enumeration   getOldINF_FPRL_32()
      {
         
         if (!getSession().getProperty("NoCacheINF_FPRL_32").equals("true"))
         
         {
            if ( INF_FPRL_32Cache != null ) return INF_FPRL_32Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPRL_3";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheINF_FPRL_32").equals("true"))
         {
            INF_FPRL_32Cache = new ObjectHashtable();
            for (Enumeration e = (INF_FPRL_3BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               INF_FPRL_32Cache.put(pkey,cacheBO);                        
            }
         
            return (INF_FPRL_32Cache.elements());
         }
         else
         {
         
            return (INF_FPRL_3BaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_FPRL_4 objects for this R_DEPT
      * old INF_FPRL_4 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_FPRL_4 objects.
      */
  public Enumeration getOldInfFprfl4Recs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheInfFprfl4Recs");
    if (cache)
      getSession().setProperty("NoCacheInfFprfl4Recs", "false");
    else
      getSession().setProperty("NoCacheInfFprfl4Recs", "true");

    try {
      return getOldInfFprfl4Recs();
    } finally {
        getSession().setProperty("NoCacheInfFprfl4Recs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_FPRL_4 objects for this R_DEPT
      * old INF_FPRL_4 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_FPRL_4 objects.
      */
      public Enumeration   getOldInfFprfl4Recs()
      {
         
         if (!getSession().getProperty("NoCacheInfFprfl4Recs").equals("true"))
         
         {
            if ( InfFprfl4RecsCache != null ) return InfFprfl4RecsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPRL_4";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheInfFprfl4Recs").equals("true"))
         {
            InfFprfl4RecsCache = new ObjectHashtable();
            for (Enumeration e = (INF_FPRL_4BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               InfFprfl4RecsCache.put(pkey,cacheBO);                        
            }
         
            return (InfFprfl4RecsCache.elements());
         }
         else
         {
         
            return (INF_FPRL_4BaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_FPRL_5 objects for this R_DEPT
      * old INF_FPRL_5 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_FPRL_5 objects.
      */
  public Enumeration getOldDeptToInfFprl5(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToInfFprl5");
    if (cache)
      getSession().setProperty("NoCacheDeptToInfFprl5", "false");
    else
      getSession().setProperty("NoCacheDeptToInfFprl5", "true");

    try {
      return getOldDeptToInfFprl5();
    } finally {
        getSession().setProperty("NoCacheDeptToInfFprl5", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_FPRL_5 objects for this R_DEPT
      * old INF_FPRL_5 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_FPRL_5 objects.
      */
      public Enumeration   getOldDeptToInfFprl5()
      {
         
         if (!getSession().getProperty("NoCacheDeptToInfFprl5").equals("true"))
         
         {
            if ( DeptToInfFprl5Cache != null ) return DeptToInfFprl5Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPRL_5";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfFprl5").equals("true"))
         {
            DeptToInfFprl5Cache = new ObjectHashtable();
            for (Enumeration e = (INF_FPRL_5BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfFprl5Cache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfFprl5Cache.elements());
         }
         else
         {
         
            return (INF_FPRL_5BaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_FPRL_O objects for this R_DEPT
      * old INF_FPRL_O objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_FPRL_O objects.
      */
  public Enumeration getOldRDeptToInfFprlO(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToInfFprlO");
    if (cache)
      getSession().setProperty("NoCacheRDeptToInfFprlO", "false");
    else
      getSession().setProperty("NoCacheRDeptToInfFprlO", "true");

    try {
      return getOldRDeptToInfFprlO();
    } finally {
        getSession().setProperty("NoCacheRDeptToInfFprlO", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_FPRL_O objects for this R_DEPT
      * old INF_FPRL_O objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_FPRL_O objects.
      */
      public Enumeration   getOldRDeptToInfFprlO()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToInfFprlO").equals("true"))
         
         {
            if ( RDeptToInfFprlOCache != null ) return RDeptToInfFprlOCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPRL_O";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToInfFprlO").equals("true"))
         {
            RDeptToInfFprlOCache = new ObjectHashtable();
            for (Enumeration e = (INF_FPRL_OBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToInfFprlOCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToInfFprlOCache.elements());
         }
         else
         {
         
            return (INF_FPRL_OBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_FPRL_ACTV_LOC objects for this R_DEPT
      * old INF_FPRL_ACTV_LOC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_FPRL_ACTV_LOC objects.
      */
  public Enumeration getOldDeptToInfFprlActToLcn(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToInfFprlActToLcn");
    if (cache)
      getSession().setProperty("NoCacheDeptToInfFprlActToLcn", "false");
    else
      getSession().setProperty("NoCacheDeptToInfFprlActToLcn", "true");

    try {
      return getOldDeptToInfFprlActToLcn();
    } finally {
        getSession().setProperty("NoCacheDeptToInfFprlActToLcn", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_FPRL_ACTV_LOC objects for this R_DEPT
      * old INF_FPRL_ACTV_LOC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_FPRL_ACTV_LOC objects.
      */
      public Enumeration   getOldDeptToInfFprlActToLcn()
      {
         
         if (!getSession().getProperty("NoCacheDeptToInfFprlActToLcn").equals("true"))
         
         {
            if ( DeptToInfFprlActToLcnCache != null ) return DeptToInfFprlActToLcnCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FPRL_ACTV_LOC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfFprlActToLcn").equals("true"))
         {
            DeptToInfFprlActToLcnCache = new ObjectHashtable();
            for (Enumeration e = (INF_FPRL_ACTV_LOCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfFprlActToLcnCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfFprlActToLcnCache.elements());
         }
         else
         {
         
            return (INF_FPRL_ACTV_LOCBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_FUNC_FUND_PROG objects for this R_DEPT
      * old INF_FUNC_FUND_PROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_FUNC_FUND_PROG objects.
      */
  public Enumeration getOldDeptToInfFuncFundProg(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToInfFuncFundProg");
    if (cache)
      getSession().setProperty("NoCacheDeptToInfFuncFundProg", "false");
    else
      getSession().setProperty("NoCacheDeptToInfFuncFundProg", "true");

    try {
      return getOldDeptToInfFuncFundProg();
    } finally {
        getSession().setProperty("NoCacheDeptToInfFuncFundProg", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_FUNC_FUND_PROG objects for this R_DEPT
      * old INF_FUNC_FUND_PROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_FUNC_FUND_PROG objects.
      */
      public Enumeration   getOldDeptToInfFuncFundProg()
      {
         
         if (!getSession().getProperty("NoCacheDeptToInfFuncFundProg").equals("true"))
         
         {
            if ( DeptToInfFuncFundProgCache != null ) return DeptToInfFuncFundProgCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FUNC_FUND_PROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfFuncFundProg").equals("true"))
         {
            DeptToInfFuncFundProgCache = new ObjectHashtable();
            for (Enumeration e = (INF_FUNC_FUND_PROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfFuncFundProgCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfFuncFundProgCache.elements());
         }
         else
         {
         
            return (INF_FUNC_FUND_PROGBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_FUND_FUNC_ACTV objects for this R_DEPT
      * old INF_FUND_FUNC_ACTV objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_FUND_FUNC_ACTV objects.
      */
  public Enumeration getOldINF_FUND_FUNC_ACTVs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheINF_FUND_FUNC_ACTVs1");
    if (cache)
      getSession().setProperty("NoCacheINF_FUND_FUNC_ACTVs1", "false");
    else
      getSession().setProperty("NoCacheINF_FUND_FUNC_ACTVs1", "true");

    try {
      return getOldINF_FUND_FUNC_ACTVs1();
    } finally {
        getSession().setProperty("NoCacheINF_FUND_FUNC_ACTVs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_FUND_FUNC_ACTV objects for this R_DEPT
      * old INF_FUND_FUNC_ACTV objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_FUND_FUNC_ACTV objects.
      */
      public Enumeration   getOldINF_FUND_FUNC_ACTVs1()
      {
         
         if (!getSession().getProperty("NoCacheINF_FUND_FUNC_ACTVs1").equals("true"))
         
         {
            if ( INF_FUND_FUNC_ACTVs1Cache != null ) return INF_FUND_FUNC_ACTVs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_FUND_FUNC_ACTV";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheINF_FUND_FUNC_ACTVs1").equals("true"))
         {
            INF_FUND_FUNC_ACTVs1Cache = new ObjectHashtable();
            for (Enumeration e = (INF_FUND_FUNC_ACTVBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               INF_FUND_FUNC_ACTVs1Cache.put(pkey,cacheBO);                        
            }
         
            return (INF_FUND_FUNC_ACTVs1Cache.elements());
         }
         else
         {
         
            return (INF_FUND_FUNC_ACTVBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_GRNT_FP objects for this R_DEPT
      * old INF_GRNT_FP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_GRNT_FP objects.
      */
  public Enumeration getOldGFPIToDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheGFPIToDept");
    if (cache)
      getSession().setProperty("NoCacheGFPIToDept", "false");
    else
      getSession().setProperty("NoCacheGFPIToDept", "true");

    try {
      return getOldGFPIToDept();
    } finally {
        getSession().setProperty("NoCacheGFPIToDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_GRNT_FP objects for this R_DEPT
      * old INF_GRNT_FP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_GRNT_FP objects.
      */
      public Enumeration   getOldGFPIToDept()
      {
         
         if (!getSession().getProperty("NoCacheGFPIToDept").equals("true"))
         
         {
            if ( GFPIToDeptCache != null ) return GFPIToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_GRNT_FP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheGFPIToDept").equals("true"))
         {
            GFPIToDeptCache = new ObjectHashtable();
            for (Enumeration e = (INF_GRNT_FPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               GFPIToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (GFPIToDeptCache.elements());
         }
         else
         {
         
            return (INF_GRNT_FPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_OBJ_OTYP objects for this R_DEPT
      * old INF_OBJ_OTYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_OBJ_OTYP objects.
      */
  public Enumeration getOldInfObjOtypToDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheInfObjOtypToDept");
    if (cache)
      getSession().setProperty("NoCacheInfObjOtypToDept", "false");
    else
      getSession().setProperty("NoCacheInfObjOtypToDept", "true");

    try {
      return getOldInfObjOtypToDept();
    } finally {
        getSession().setProperty("NoCacheInfObjOtypToDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_OBJ_OTYP objects for this R_DEPT
      * old INF_OBJ_OTYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_OBJ_OTYP objects.
      */
      public Enumeration   getOldInfObjOtypToDept()
      {
         
         if (!getSession().getProperty("NoCacheInfObjOtypToDept").equals("true"))
         
         {
            if ( InfObjOtypToDeptCache != null ) return InfObjOtypToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_OBJ_OTYP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheInfObjOtypToDept").equals("true"))
         {
            InfObjOtypToDeptCache = new ObjectHashtable();
            for (Enumeration e = (INF_OBJ_OTYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               InfObjOtypToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (InfObjOtypToDeptCache.elements());
         }
         else
         {
         
            return (INF_OBJ_OTYPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_PHASE_PROG objects for this R_DEPT
      * old INF_PHASE_PROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_PHASE_PROG objects.
      */
  public Enumeration getOldINF_PHASE_PROGs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheINF_PHASE_PROGs");
    if (cache)
      getSession().setProperty("NoCacheINF_PHASE_PROGs", "false");
    else
      getSession().setProperty("NoCacheINF_PHASE_PROGs", "true");

    try {
      return getOldINF_PHASE_PROGs();
    } finally {
        getSession().setProperty("NoCacheINF_PHASE_PROGs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_PHASE_PROG objects for this R_DEPT
      * old INF_PHASE_PROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_PHASE_PROG objects.
      */
      public Enumeration   getOldINF_PHASE_PROGs()
      {
         
         if (!getSession().getProperty("NoCacheINF_PHASE_PROGs").equals("true"))
         
         {
            if ( INF_PHASE_PROGsCache != null ) return INF_PHASE_PROGsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_PHASE_PROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheINF_PHASE_PROGs").equals("true"))
         {
            INF_PHASE_PROGsCache = new ObjectHashtable();
            for (Enumeration e = (INF_PHASE_PROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               INF_PHASE_PROGsCache.put(pkey,cacheBO);                        
            }
         
            return (INF_PHASE_PROGsCache.elements());
         }
         else
         {
         
            return (INF_PHASE_PROGBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_PROJ_FP objects for this R_DEPT
      * old INF_PROJ_FP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_PROJ_FP objects.
      */
  public Enumeration getOldPFPIToDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCachePFPIToDept");
    if (cache)
      getSession().setProperty("NoCachePFPIToDept", "false");
    else
      getSession().setProperty("NoCachePFPIToDept", "true");

    try {
      return getOldPFPIToDept();
    } finally {
        getSession().setProperty("NoCachePFPIToDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_PROJ_FP objects for this R_DEPT
      * old INF_PROJ_FP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_PROJ_FP objects.
      */
      public Enumeration   getOldPFPIToDept()
      {
         
         if (!getSession().getProperty("NoCachePFPIToDept").equals("true"))
         
         {
            if ( PFPIToDeptCache != null ) return PFPIToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_PROJ_FP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCachePFPIToDept").equals("true"))
         {
            PFPIToDeptCache = new ObjectHashtable();
            for (Enumeration e = (INF_PROJ_FPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               PFPIToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (PFPIToDeptCache.elements());
         }
         else
         {
         
            return (INF_PROJ_FPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_REV_SRC objects for this R_DEPT
      * old INF_REV_SRC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_REV_SRC objects.
      */
  public Enumeration getOldRevSrcInfToDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRevSrcInfToDept");
    if (cache)
      getSession().setProperty("NoCacheRevSrcInfToDept", "false");
    else
      getSession().setProperty("NoCacheRevSrcInfToDept", "true");

    try {
      return getOldRevSrcInfToDept();
    } finally {
        getSession().setProperty("NoCacheRevSrcInfToDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_REV_SRC objects for this R_DEPT
      * old INF_REV_SRC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_REV_SRC objects.
      */
      public Enumeration   getOldRevSrcInfToDept()
      {
         
         if (!getSession().getProperty("NoCacheRevSrcInfToDept").equals("true"))
         
         {
            if ( RevSrcInfToDeptCache != null ) return RevSrcInfToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_REV_SRC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRevSrcInfToDept").equals("true"))
         {
            RevSrcInfToDeptCache = new ObjectHashtable();
            for (Enumeration e = (INF_REV_SRCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RevSrcInfToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (RevSrcInfToDeptCache.elements());
         }
         else
         {
         
            return (INF_REV_SRCBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_UNIT objects for this R_DEPT
      * old INF_UNIT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_UNIT objects.
      */
  public Enumeration getOldDeptToInfUnit(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToInfUnit");
    if (cache)
      getSession().setProperty("NoCacheDeptToInfUnit", "false");
    else
      getSession().setProperty("NoCacheDeptToInfUnit", "true");

    try {
      return getOldDeptToInfUnit();
    } finally {
        getSession().setProperty("NoCacheDeptToInfUnit", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_UNIT objects for this R_DEPT
      * old INF_UNIT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_UNIT objects.
      */
      public Enumeration   getOldDeptToInfUnit()
      {
         
         if (!getSession().getProperty("NoCacheDeptToInfUnit").equals("true"))
         
         {
            if ( DeptToInfUnitCache != null ) return DeptToInfUnitCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_UNIT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfUnit").equals("true"))
         {
            DeptToInfUnitCache = new ObjectHashtable();
            for (Enumeration e = (INF_UNITBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfUnitCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfUnitCache.elements());
         }
         else
         {
         
            return (INF_UNITBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old MA_DOC_AUTHDEPT objects for this R_DEPT
      * old MA_DOC_AUTHDEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old MA_DOC_AUTHDEPT objects.
      */
  public Enumeration getOldDeptMaAuthDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptMaAuthDept");
    if (cache)
      getSession().setProperty("NoCacheDeptMaAuthDept", "false");
    else
      getSession().setProperty("NoCacheDeptMaAuthDept", "true");

    try {
      return getOldDeptMaAuthDept();
    } finally {
        getSession().setProperty("NoCacheDeptMaAuthDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old MA_DOC_AUTHDEPT objects for this R_DEPT
      * old MA_DOC_AUTHDEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old MA_DOC_AUTHDEPT objects.
      */
      public Enumeration   getOldDeptMaAuthDept()
      {
         
         if (!getSession().getProperty("NoCacheDeptMaAuthDept").equals("true"))
         
         {
            if ( DeptMaAuthDeptCache != null ) return DeptMaAuthDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "MA_DOC_AUTHDEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptMaAuthDept").equals("true"))
         {
            DeptMaAuthDeptCache = new ObjectHashtable();
            for (Enumeration e = (MA_DOC_AUTHDEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptMaAuthDeptCache.put(pkey,cacheBO);                        
            }
         
            return (DeptMaAuthDeptCache.elements());
         }
         else
         {
         
            return (MA_DOC_AUTHDEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_ACTG_PRFL objects for this R_DEPT
      * old R_ACTG_PRFL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_ACTG_PRFL objects.
      */
  public Enumeration getOldDeptToActgPrfl(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToActgPrfl");
    if (cache)
      getSession().setProperty("NoCacheDeptToActgPrfl", "false");
    else
      getSession().setProperty("NoCacheDeptToActgPrfl", "true");

    try {
      return getOldDeptToActgPrfl();
    } finally {
        getSession().setProperty("NoCacheDeptToActgPrfl", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_ACTG_PRFL objects for this R_DEPT
      * old R_ACTG_PRFL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_ACTG_PRFL objects.
      */
      public Enumeration   getOldDeptToActgPrfl()
      {
         
         if (!getSession().getProperty("NoCacheDeptToActgPrfl").equals("true"))
         
         {
            if ( DeptToActgPrflCache != null ) return DeptToActgPrflCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ACTG_PRFL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToActgPrfl").equals("true"))
         {
            DeptToActgPrflCache = new ObjectHashtable();
            for (Enumeration e = (R_ACTG_PRFLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToActgPrflCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToActgPrflCache.elements());
         }
         else
         {
         
            return (R_ACTG_PRFLBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_ACTG_TMPL objects for this R_DEPT
      * old R_ACTG_TMPL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_ACTG_TMPL objects.
      */
  public Enumeration getOldR_ACTG_TMPLs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_ACTG_TMPLs");
    if (cache)
      getSession().setProperty("NoCacheR_ACTG_TMPLs", "false");
    else
      getSession().setProperty("NoCacheR_ACTG_TMPLs", "true");

    try {
      return getOldR_ACTG_TMPLs();
    } finally {
        getSession().setProperty("NoCacheR_ACTG_TMPLs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_ACTG_TMPL objects for this R_DEPT
      * old R_ACTG_TMPL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_ACTG_TMPL objects.
      */
      public Enumeration   getOldR_ACTG_TMPLs()
      {
         
         if (!getSession().getProperty("NoCacheR_ACTG_TMPLs").equals("true"))
         
         {
            if ( R_ACTG_TMPLsCache != null ) return R_ACTG_TMPLsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ACTG_TMPL";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_ACTG_TMPLs").equals("true"))
         {
            R_ACTG_TMPLsCache = new ObjectHashtable();
            for (Enumeration e = (R_ACTG_TMPLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_ACTG_TMPLsCache.put(pkey,cacheBO);                        
            }
         
            return (R_ACTG_TMPLsCache.elements());
         }
         else
         {
         
            return (R_ACTG_TMPLBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_ALT_ORG_STRUCT objects for this R_DEPT
      * old R_ALT_ORG_STRUCT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_ALT_ORG_STRUCT objects.
      */
  public Enumeration getOldDeptToStructDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToStructDept");
    if (cache)
      getSession().setProperty("NoCacheDeptToStructDept", "false");
    else
      getSession().setProperty("NoCacheDeptToStructDept", "true");

    try {
      return getOldDeptToStructDept();
    } finally {
        getSession().setProperty("NoCacheDeptToStructDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_ALT_ORG_STRUCT objects for this R_DEPT
      * old R_ALT_ORG_STRUCT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_ALT_ORG_STRUCT objects.
      */
      public Enumeration   getOldDeptToStructDept()
      {
         
         if (!getSession().getProperty("NoCacheDeptToStructDept").equals("true"))
         
         {
            if ( DeptToStructDeptCache != null ) return DeptToStructDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ALT_ORG_STRUCT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToStructDept").equals("true"))
         {
            DeptToStructDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_ALT_ORG_STRUCTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToStructDeptCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToStructDeptCache.elements());
         }
         else
         {
         
            return (R_ALT_ORG_STRUCTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_AP_CW_HDR objects for this R_DEPT
      * old R_AP_CW_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_AP_CW_HDR objects.
      */
  public Enumeration getOldDeptToApCwHdr(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToApCwHdr");
    if (cache)
      getSession().setProperty("NoCacheDeptToApCwHdr", "false");
    else
      getSession().setProperty("NoCacheDeptToApCwHdr", "true");

    try {
      return getOldDeptToApCwHdr();
    } finally {
        getSession().setProperty("NoCacheDeptToApCwHdr", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_AP_CW_HDR objects for this R_DEPT
      * old R_AP_CW_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_AP_CW_HDR objects.
      */
      public Enumeration   getOldDeptToApCwHdr()
      {
         
         if (!getSession().getProperty("NoCacheDeptToApCwHdr").equals("true"))
         
         {
            if ( DeptToApCwHdrCache != null ) return DeptToApCwHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_CW_HDR";
            param.fieldName = "CW_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToApCwHdr").equals("true"))
         {
            DeptToApCwHdrCache = new ObjectHashtable();
            for (Enumeration e = (R_AP_CW_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToApCwHdrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToApCwHdrCache.elements());
         }
         else
         {
         
            return (R_AP_CW_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_AP_INCT_RQST objects for this R_DEPT
      * old R_AP_INCT_RQST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_AP_INCT_RQST objects.
      */
  public Enumeration getOldR_AP_INCT_RQSTs2(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_AP_INCT_RQSTs2");
    if (cache)
      getSession().setProperty("NoCacheR_AP_INCT_RQSTs2", "false");
    else
      getSession().setProperty("NoCacheR_AP_INCT_RQSTs2", "true");

    try {
      return getOldR_AP_INCT_RQSTs2();
    } finally {
        getSession().setProperty("NoCacheR_AP_INCT_RQSTs2", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_AP_INCT_RQST objects for this R_DEPT
      * old R_AP_INCT_RQST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_AP_INCT_RQST objects.
      */
      public Enumeration   getOldR_AP_INCT_RQSTs2()
      {
         
         if (!getSession().getProperty("NoCacheR_AP_INCT_RQSTs2").equals("true"))
         
         {
            if ( R_AP_INCT_RQSTs2Cache != null ) return R_AP_INCT_RQSTs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_INCT_RQST";
            param.fieldName = "CLM_DEPT";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_AP_INCT_RQSTs2").equals("true"))
         {
            R_AP_INCT_RQSTs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_AP_INCT_RQSTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_AP_INCT_RQSTs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_AP_INCT_RQSTs2Cache.elements());
         }
         else
         {
         
            return (R_AP_INCT_RQSTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_APD_DEPT objects for this R_DEPT
      * old R_APD_DEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_APD_DEPT objects.
      */
  public Enumeration getOldRDeptToRApdDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRApdDept");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRApdDept", "false");
    else
      getSession().setProperty("NoCacheRDeptToRApdDept", "true");

    try {
      return getOldRDeptToRApdDept();
    } finally {
        getSession().setProperty("NoCacheRDeptToRApdDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_APD_DEPT objects for this R_DEPT
      * old R_APD_DEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_APD_DEPT objects.
      */
      public Enumeration   getOldRDeptToRApdDept()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRApdDept").equals("true"))
         
         {
            if ( RDeptToRApdDeptCache != null ) return RDeptToRApdDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_APD_DEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRApdDept").equals("true"))
         {
            RDeptToRApdDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_APD_DEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRApdDeptCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRApdDeptCache.elements());
         }
         else
         {
         
            return (R_APD_DEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_CITED_AUTH objects for this R_DEPT
      * old R_CITED_AUTH objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_CITED_AUTH objects.
      */
  public Enumeration getOldDeptToCitedAuth(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToCitedAuth");
    if (cache)
      getSession().setProperty("NoCacheDeptToCitedAuth", "false");
    else
      getSession().setProperty("NoCacheDeptToCitedAuth", "true");

    try {
      return getOldDeptToCitedAuth();
    } finally {
        getSession().setProperty("NoCacheDeptToCitedAuth", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_CITED_AUTH objects for this R_DEPT
      * old R_CITED_AUTH objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_CITED_AUTH objects.
      */
      public Enumeration   getOldDeptToCitedAuth()
      {
         
         if (!getSession().getProperty("NoCacheDeptToCitedAuth").equals("true"))
         
         {
            if ( DeptToCitedAuthCache != null ) return DeptToCitedAuthCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CITED_AUTH";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCitedAuth").equals("true"))
         {
            DeptToCitedAuthCache = new ObjectHashtable();
            for (Enumeration e = (R_CITED_AUTHBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCitedAuthCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCitedAuthCache.elements());
         }
         else
         {
         
            return (R_CITED_AUTHBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_CNTAC objects for this R_DEPT
      * old R_CNTAC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_CNTAC objects.
      */
  public Enumeration getOldDeptToCntac(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToCntac");
    if (cache)
      getSession().setProperty("NoCacheDeptToCntac", "false");
    else
      getSession().setProperty("NoCacheDeptToCntac", "true");

    try {
      return getOldDeptToCntac();
    } finally {
        getSession().setProperty("NoCacheDeptToCntac", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_CNTAC objects for this R_DEPT
      * old R_CNTAC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_CNTAC objects.
      */
      public Enumeration   getOldDeptToCntac()
      {
         
         if (!getSession().getProperty("NoCacheDeptToCntac").equals("true"))
         
         {
            if ( DeptToCntacCache != null ) return DeptToCntacCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CNTAC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCntac").equals("true"))
         {
            DeptToCntacCache = new ObjectHashtable();
            for (Enumeration e = (R_CNTACBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCntacCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCntacCache.elements());
         }
         else
         {
         
            return (R_CNTACBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_COMM_FA_THLD objects for this R_DEPT
      * old R_COMM_FA_THLD objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_COMM_FA_THLD objects.
      */
  public Enumeration getOldR_COMM_FA_THLDs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_COMM_FA_THLDs1");
    if (cache)
      getSession().setProperty("NoCacheR_COMM_FA_THLDs1", "false");
    else
      getSession().setProperty("NoCacheR_COMM_FA_THLDs1", "true");

    try {
      return getOldR_COMM_FA_THLDs1();
    } finally {
        getSession().setProperty("NoCacheR_COMM_FA_THLDs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_COMM_FA_THLD objects for this R_DEPT
      * old R_COMM_FA_THLD objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_COMM_FA_THLD objects.
      */
      public Enumeration   getOldR_COMM_FA_THLDs1()
      {
         
         if (!getSession().getProperty("NoCacheR_COMM_FA_THLDs1").equals("true"))
         
         {
            if ( R_COMM_FA_THLDs1Cache != null ) return R_COMM_FA_THLDs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_COMM_FA_THLD";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_COMM_FA_THLDs1").equals("true"))
         {
            R_COMM_FA_THLDs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_COMM_FA_THLDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_COMM_FA_THLDs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_COMM_FA_THLDs1Cache.elements());
         }
         else
         {
         
            return (R_COMM_FA_THLDBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_COMM_OBJ objects for this R_DEPT
      * old R_COMM_OBJ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_COMM_OBJ objects.
      */
  public Enumeration getOldR_COMM_OBJs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_COMM_OBJs1");
    if (cache)
      getSession().setProperty("NoCacheR_COMM_OBJs1", "false");
    else
      getSession().setProperty("NoCacheR_COMM_OBJs1", "true");

    try {
      return getOldR_COMM_OBJs1();
    } finally {
        getSession().setProperty("NoCacheR_COMM_OBJs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_COMM_OBJ objects for this R_DEPT
      * old R_COMM_OBJ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_COMM_OBJ objects.
      */
      public Enumeration   getOldR_COMM_OBJs1()
      {
         
         if (!getSession().getProperty("NoCacheR_COMM_OBJs1").equals("true"))
         
         {
            if ( R_COMM_OBJs1Cache != null ) return R_COMM_OBJs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_COMM_OBJ";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_COMM_OBJs1").equals("true"))
         {
            R_COMM_OBJs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_COMM_OBJBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_COMM_OBJs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_COMM_OBJs1Cache.elements());
         }
         else
         {
         
            return (R_COMM_OBJBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DEPT_FY objects for this R_DEPT
      * old R_DEPT_FY objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DEPT_FY objects.
      */
  public Enumeration getOldDeptToDeptFY(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToDeptFY");
    if (cache)
      getSession().setProperty("NoCacheDeptToDeptFY", "false");
    else
      getSession().setProperty("NoCacheDeptToDeptFY", "true");

    try {
      return getOldDeptToDeptFY();
    } finally {
        getSession().setProperty("NoCacheDeptToDeptFY", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DEPT_FY objects for this R_DEPT
      * old R_DEPT_FY objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DEPT_FY objects.
      */
      public Enumeration   getOldDeptToDeptFY()
      {
         
         if (!getSession().getProperty("NoCacheDeptToDeptFY").equals("true"))
         
         {
            if ( DeptToDeptFYCache != null ) return DeptToDeptFYCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DEPT_FY";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDeptFY").equals("true"))
         {
            DeptToDeptFYCache = new ObjectHashtable();
            for (Enumeration e = (R_DEPT_FYBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDeptFYCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDeptFYCache.elements());
         }
         else
         {
         
            return (R_DEPT_FYBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DEPT_OBJ_PYCTRL objects for this R_DEPT
      * old R_DEPT_OBJ_PYCTRL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DEPT_OBJ_PYCTRL objects.
      */
  public Enumeration getOldRDeptToRDeptObjPymtCtrl(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRDeptObjPymtCtrl");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRDeptObjPymtCtrl", "false");
    else
      getSession().setProperty("NoCacheRDeptToRDeptObjPymtCtrl", "true");

    try {
      return getOldRDeptToRDeptObjPymtCtrl();
    } finally {
        getSession().setProperty("NoCacheRDeptToRDeptObjPymtCtrl", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DEPT_OBJ_PYCTRL objects for this R_DEPT
      * old R_DEPT_OBJ_PYCTRL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DEPT_OBJ_PYCTRL objects.
      */
      public Enumeration   getOldRDeptToRDeptObjPymtCtrl()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRDeptObjPymtCtrl").equals("true"))
         
         {
            if ( RDeptToRDeptObjPymtCtrlCache != null ) return RDeptToRDeptObjPymtCtrlCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DEPT_OBJ_PYCTRL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRDeptObjPymtCtrl").equals("true"))
         {
            RDeptToRDeptObjPymtCtrlCache = new ObjectHashtable();
            for (Enumeration e = (R_DEPT_OBJ_PYCTRLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRDeptObjPymtCtrlCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRDeptObjPymtCtrlCache.elements());
         }
         else
         {
         
            return (R_DEPT_OBJ_PYCTRLBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DISCIV objects for this R_DEPT
      * old R_DISCIV objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DISCIV objects.
      */
  public Enumeration getOldDeptToDISCIV(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToDISCIV");
    if (cache)
      getSession().setProperty("NoCacheDeptToDISCIV", "false");
    else
      getSession().setProperty("NoCacheDeptToDISCIV", "true");

    try {
      return getOldDeptToDISCIV();
    } finally {
        getSession().setProperty("NoCacheDeptToDISCIV", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DISCIV objects for this R_DEPT
      * old R_DISCIV objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DISCIV objects.
      */
      public Enumeration   getOldDeptToDISCIV()
      {
         
         if (!getSession().getProperty("NoCacheDeptToDISCIV").equals("true"))
         
         {
            if ( DeptToDISCIVCache != null ) return DeptToDISCIVCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DISCIV";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDISCIV").equals("true"))
         {
            DeptToDISCIVCache = new ObjectHashtable();
            for (Enumeration e = (R_DISCIVBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDISCIVCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDISCIVCache.elements());
         }
         else
         {
         
            return (R_DISCIVBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DRWDWN_GRP objects for this R_DEPT
      * old R_DRWDWN_GRP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DRWDWN_GRP objects.
      */
  public Enumeration getOldDeptToDrwdwnGrp(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToDrwdwnGrp");
    if (cache)
      getSession().setProperty("NoCacheDeptToDrwdwnGrp", "false");
    else
      getSession().setProperty("NoCacheDeptToDrwdwnGrp", "true");

    try {
      return getOldDeptToDrwdwnGrp();
    } finally {
        getSession().setProperty("NoCacheDeptToDrwdwnGrp", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DRWDWN_GRP objects for this R_DEPT
      * old R_DRWDWN_GRP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DRWDWN_GRP objects.
      */
      public Enumeration   getOldDeptToDrwdwnGrp()
      {
         
         if (!getSession().getProperty("NoCacheDeptToDrwdwnGrp").equals("true"))
         
         {
            if ( DeptToDrwdwnGrpCache != null ) return DeptToDrwdwnGrpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DRWDWN_GRP";
            param.fieldName = "DRWDWN_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDrwdwnGrp").equals("true"))
         {
            DeptToDrwdwnGrpCache = new ObjectHashtable();
            for (Enumeration e = (R_DRWDWN_GRPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDrwdwnGrpCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDrwdwnGrpCache.elements());
         }
         else
         {
         
            return (R_DRWDWN_GRPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_ESCROW_DEF objects for this R_DEPT
      * old R_ESCROW_DEF objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_ESCROW_DEF objects.
      */
  public Enumeration getOldDeptToEscrowDef(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToEscrowDef");
    if (cache)
      getSession().setProperty("NoCacheDeptToEscrowDef", "false");
    else
      getSession().setProperty("NoCacheDeptToEscrowDef", "true");

    try {
      return getOldDeptToEscrowDef();
    } finally {
        getSession().setProperty("NoCacheDeptToEscrowDef", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_ESCROW_DEF objects for this R_DEPT
      * old R_ESCROW_DEF objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_ESCROW_DEF objects.
      */
      public Enumeration   getOldDeptToEscrowDef()
      {
         
         if (!getSession().getProperty("NoCacheDeptToEscrowDef").equals("true"))
         
         {
            if ( DeptToEscrowDefCache != null ) return DeptToEscrowDefCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ESCROW_DEF";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToEscrowDef").equals("true"))
         {
            DeptToEscrowDefCache = new ObjectHashtable();
            for (Enumeration e = (R_ESCROW_DEFBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToEscrowDefCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToEscrowDefCache.elements());
         }
         else
         {
         
            return (R_ESCROW_DEFBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FESREQ objects for this R_DEPT
      * old R_FESREQ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FESREQ objects.
      */
  public Enumeration getOldRDeptToRFesReq(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRFesReq");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRFesReq", "false");
    else
      getSession().setProperty("NoCacheRDeptToRFesReq", "true");

    try {
      return getOldRDeptToRFesReq();
    } finally {
        getSession().setProperty("NoCacheRDeptToRFesReq", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FESREQ objects for this R_DEPT
      * old R_FESREQ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FESREQ objects.
      */
      public Enumeration   getOldRDeptToRFesReq()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRFesReq").equals("true"))
         
         {
            if ( RDeptToRFesReqCache != null ) return RDeptToRFesReqCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FESREQ";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRFesReq").equals("true"))
         {
            RDeptToRFesReqCache = new ObjectHashtable();
            for (Enumeration e = (R_FESREQBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRFesReqCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRFesReqCache.elements());
         }
         else
         {
         
            return (R_FESREQBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FNDG_ALLOC objects for this R_DEPT
      * old R_FNDG_ALLOC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FNDG_ALLOC objects.
      */
  public Enumeration getOldRDeptToRFndgAlloc(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRFndgAlloc");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRFndgAlloc", "false");
    else
      getSession().setProperty("NoCacheRDeptToRFndgAlloc", "true");

    try {
      return getOldRDeptToRFndgAlloc();
    } finally {
        getSession().setProperty("NoCacheRDeptToRFndgAlloc", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FNDG_ALLOC objects for this R_DEPT
      * old R_FNDG_ALLOC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FNDG_ALLOC objects.
      */
      public Enumeration   getOldRDeptToRFndgAlloc()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRFndgAlloc").equals("true"))
         
         {
            if ( RDeptToRFndgAllocCache != null ) return RDeptToRFndgAllocCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FNDG_ALLOC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRFndgAlloc").equals("true"))
         {
            RDeptToRFndgAllocCache = new ObjectHashtable();
            for (Enumeration e = (R_FNDG_ALLOCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRFndgAllocCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRFndgAllocCache.elements());
         }
         else
         {
         
            return (R_FNDG_ALLOCBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FY_DEPT objects for this R_DEPT
      * old R_FY_DEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FY_DEPT objects.
      */
  public Enumeration getOldRDeptToRFyDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRFyDept");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRFyDept", "false");
    else
      getSession().setProperty("NoCacheRDeptToRFyDept", "true");

    try {
      return getOldRDeptToRFyDept();
    } finally {
        getSession().setProperty("NoCacheRDeptToRFyDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FY_DEPT objects for this R_DEPT
      * old R_FY_DEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FY_DEPT objects.
      */
      public Enumeration   getOldRDeptToRFyDept()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRFyDept").equals("true"))
         
         {
            if ( RDeptToRFyDeptCache != null ) return RDeptToRFyDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FY_DEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRFyDept").equals("true"))
         {
            RDeptToRFyDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_FY_DEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRFyDeptCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRFyDeptCache.elements());
         }
         else
         {
         
            return (R_FY_DEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_GRNT_APPL objects for this R_DEPT
      * old R_GRNT_APPL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_GRNT_APPL objects.
      */
  public Enumeration getOldRDeptToRGrntAppl(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRGrntAppl");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRGrntAppl", "false");
    else
      getSession().setProperty("NoCacheRDeptToRGrntAppl", "true");

    try {
      return getOldRDeptToRGrntAppl();
    } finally {
        getSession().setProperty("NoCacheRDeptToRGrntAppl", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_GRNT_APPL objects for this R_DEPT
      * old R_GRNT_APPL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_GRNT_APPL objects.
      */
      public Enumeration   getOldRDeptToRGrntAppl()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntAppl").equals("true"))
         
         {
            if ( RDeptToRGrntApplCache != null ) return RDeptToRGrntApplCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_APPL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntAppl").equals("true"))
         {
            RDeptToRGrntApplCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_APPLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntApplCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntApplCache.elements());
         }
         else
         {
         
            return (R_GRNT_APPLBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_GRNT_DT_TMPL objects for this R_DEPT
      * old R_GRNT_DT_TMPL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_GRNT_DT_TMPL objects.
      */
  public Enumeration getOldRDeptToRGrntDtTmpl(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRGrntDtTmpl");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRGrntDtTmpl", "false");
    else
      getSession().setProperty("NoCacheRDeptToRGrntDtTmpl", "true");

    try {
      return getOldRDeptToRGrntDtTmpl();
    } finally {
        getSession().setProperty("NoCacheRDeptToRGrntDtTmpl", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_GRNT_DT_TMPL objects for this R_DEPT
      * old R_GRNT_DT_TMPL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_GRNT_DT_TMPL objects.
      */
      public Enumeration   getOldRDeptToRGrntDtTmpl()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntDtTmpl").equals("true"))
         
         {
            if ( RDeptToRGrntDtTmplCache != null ) return RDeptToRGrntDtTmplCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_DT_TMPL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntDtTmpl").equals("true"))
         {
            RDeptToRGrntDtTmplCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_DT_TMPLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntDtTmplCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntDtTmplCache.elements());
         }
         else
         {
         
            return (R_GRNT_DT_TMPLBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_GRNT_OPTY objects for this R_DEPT
      * old R_GRNT_OPTY objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_GRNT_OPTY objects.
      */
  public Enumeration getOldDeptToGrntOpty(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToGrntOpty");
    if (cache)
      getSession().setProperty("NoCacheDeptToGrntOpty", "false");
    else
      getSession().setProperty("NoCacheDeptToGrntOpty", "true");

    try {
      return getOldDeptToGrntOpty();
    } finally {
        getSession().setProperty("NoCacheDeptToGrntOpty", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_GRNT_OPTY objects for this R_DEPT
      * old R_GRNT_OPTY objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_GRNT_OPTY objects.
      */
      public Enumeration   getOldDeptToGrntOpty()
      {
         
         if (!getSession().getProperty("NoCacheDeptToGrntOpty").equals("true"))
         
         {
            if ( DeptToGrntOptyCache != null ) return DeptToGrntOptyCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_OPTY";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGrntOpty").equals("true"))
         {
            DeptToGrntOptyCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_OPTYBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGrntOptyCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGrntOptyCache.elements());
         }
         else
         {
         
            return (R_GRNT_OPTYBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_GRNT_RESP objects for this R_DEPT
      * old R_GRNT_RESP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_GRNT_RESP objects.
      */
  public Enumeration getOldDeptToGrntResp(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToGrntResp");
    if (cache)
      getSession().setProperty("NoCacheDeptToGrntResp", "false");
    else
      getSession().setProperty("NoCacheDeptToGrntResp", "true");

    try {
      return getOldDeptToGrntResp();
    } finally {
        getSession().setProperty("NoCacheDeptToGrntResp", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_GRNT_RESP objects for this R_DEPT
      * old R_GRNT_RESP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_GRNT_RESP objects.
      */
      public Enumeration   getOldDeptToGrntResp()
      {
         
         if (!getSession().getProperty("NoCacheDeptToGrntResp").equals("true"))
         
         {
            if ( DeptToGrntRespCache != null ) return DeptToGrntRespCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_RESP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGrntResp").equals("true"))
         {
            DeptToGrntRespCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_RESPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGrntRespCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGrntRespCache.elements());
         }
         else
         {
         
            return (R_GRNT_RESPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_GRNT_USER objects for this R_DEPT
      * old R_GRNT_USER objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_GRNT_USER objects.
      */
  public Enumeration getOldDeptToGrntUser(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToGrntUser");
    if (cache)
      getSession().setProperty("NoCacheDeptToGrntUser", "false");
    else
      getSession().setProperty("NoCacheDeptToGrntUser", "true");

    try {
      return getOldDeptToGrntUser();
    } finally {
        getSession().setProperty("NoCacheDeptToGrntUser", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_GRNT_USER objects for this R_DEPT
      * old R_GRNT_USER objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_GRNT_USER objects.
      */
      public Enumeration   getOldDeptToGrntUser()
      {
         
         if (!getSession().getProperty("NoCacheDeptToGrntUser").equals("true"))
         
         {
            if ( DeptToGrntUserCache != null ) return DeptToGrntUserCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_USER";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGrntUser").equals("true"))
         {
            DeptToGrntUserCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_USERBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGrntUserCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGrntUserCache.elements());
         }
         else
         {
         
            return (R_GRNT_USERBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_INTG_CTRL objects for this R_DEPT
      * old R_INTG_CTRL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_INTG_CTRL objects.
      */
  public Enumeration getOldR_INTG_CTRL(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_INTG_CTRL");
    if (cache)
      getSession().setProperty("NoCacheR_INTG_CTRL", "false");
    else
      getSession().setProperty("NoCacheR_INTG_CTRL", "true");

    try {
      return getOldR_INTG_CTRL();
    } finally {
        getSession().setProperty("NoCacheR_INTG_CTRL", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_INTG_CTRL objects for this R_DEPT
      * old R_INTG_CTRL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_INTG_CTRL objects.
      */
      public Enumeration   getOldR_INTG_CTRL()
      {
         
         if (!getSession().getProperty("NoCacheR_INTG_CTRL").equals("true"))
         
         {
            if ( R_INTG_CTRLCache != null ) return R_INTG_CTRLCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_INTG_CTRL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_INTG_CTRL").equals("true"))
         {
            R_INTG_CTRLCache = new ObjectHashtable();
            for (Enumeration e = (R_INTG_CTRLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_INTG_CTRLCache.put(pkey,cacheBO);                        
            }
         
            return (R_INTG_CTRLCache.elements());
         }
         else
         {
         
            return (R_INTG_CTRLBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_MJR_PROG objects for this R_DEPT
      * old R_MJR_PROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_MJR_PROG objects.
      */
  public Enumeration getOldR_MJR_PROGs3(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_MJR_PROGs3");
    if (cache)
      getSession().setProperty("NoCacheR_MJR_PROGs3", "false");
    else
      getSession().setProperty("NoCacheR_MJR_PROGs3", "true");

    try {
      return getOldR_MJR_PROGs3();
    } finally {
        getSession().setProperty("NoCacheR_MJR_PROGs3", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_MJR_PROG objects for this R_DEPT
      * old R_MJR_PROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_MJR_PROG objects.
      */
      public Enumeration   getOldR_MJR_PROGs3()
      {
         
         if (!getSession().getProperty("NoCacheR_MJR_PROGs3").equals("true"))
         
         {
            if ( R_MJR_PROGs3Cache != null ) return R_MJR_PROGs3Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_MJR_PROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_MJR_PROGs3").equals("true"))
         {
            R_MJR_PROGs3Cache = new ObjectHashtable();
            for (Enumeration e = (R_MJR_PROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_MJR_PROGs3Cache.put(pkey,cacheBO);                        
            }
         
            return (R_MJR_PROGs3Cache.elements());
         }
         else
         {
         
            return (R_MJR_PROGBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_ONGOING_AWD_INFO objects for this R_DEPT
      * old R_ONGOING_AWD_INFO objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_ONGOING_AWD_INFO objects.
      */
  public Enumeration getOldDepartmentToOnGoingAwardInfo(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDepartmentToOnGoingAwardInfo");
    if (cache)
      getSession().setProperty("NoCacheDepartmentToOnGoingAwardInfo", "false");
    else
      getSession().setProperty("NoCacheDepartmentToOnGoingAwardInfo", "true");

    try {
      return getOldDepartmentToOnGoingAwardInfo();
    } finally {
        getSession().setProperty("NoCacheDepartmentToOnGoingAwardInfo", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_ONGOING_AWD_INFO objects for this R_DEPT
      * old R_ONGOING_AWD_INFO objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_ONGOING_AWD_INFO objects.
      */
      public Enumeration   getOldDepartmentToOnGoingAwardInfo()
      {
         
         if (!getSession().getProperty("NoCacheDepartmentToOnGoingAwardInfo").equals("true"))
         
         {
            if ( DepartmentToOnGoingAwardInfoCache != null ) return DepartmentToOnGoingAwardInfoCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ONGOING_AWD_INFO";
            param.fieldName = "CA_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDepartmentToOnGoingAwardInfo").equals("true"))
         {
            DepartmentToOnGoingAwardInfoCache = new ObjectHashtable();
            for (Enumeration e = (R_ONGOING_AWD_INFOBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DepartmentToOnGoingAwardInfoCache.put(pkey,cacheBO);                        
            }
         
            return (DepartmentToOnGoingAwardInfoCache.elements());
         }
         else
         {
         
            return (R_ONGOING_AWD_INFOBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PE_EVALR objects for this R_DEPT
      * old R_PE_EVALR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PE_EVALR objects.
      */
  public Enumeration getOldPerfEvalEvaluator(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCachePerfEvalEvaluator");
    if (cache)
      getSession().setProperty("NoCachePerfEvalEvaluator", "false");
    else
      getSession().setProperty("NoCachePerfEvalEvaluator", "true");

    try {
      return getOldPerfEvalEvaluator();
    } finally {
        getSession().setProperty("NoCachePerfEvalEvaluator", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PE_EVALR objects for this R_DEPT
      * old R_PE_EVALR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PE_EVALR objects.
      */
      public Enumeration   getOldPerfEvalEvaluator()
      {
         
         if (!getSession().getProperty("NoCachePerfEvalEvaluator").equals("true"))
         
         {
            if ( PerfEvalEvaluatorCache != null ) return PerfEvalEvaluatorCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PE_EVALR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCachePerfEvalEvaluator").equals("true"))
         {
            PerfEvalEvaluatorCache = new ObjectHashtable();
            for (Enumeration e = (R_PE_EVALRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               PerfEvalEvaluatorCache.put(pkey,cacheBO);                        
            }
         
            return (PerfEvalEvaluatorCache.elements());
         }
         else
         {
         
            return (R_PE_EVALRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PRCU_ST objects for this R_DEPT
      * old R_PRCU_ST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PRCU_ST objects.
      */
  public Enumeration getOldStateInstances(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheStateInstances");
    if (cache)
      getSession().setProperty("NoCacheStateInstances", "false");
    else
      getSession().setProperty("NoCacheStateInstances", "true");

    try {
      return getOldStateInstances();
    } finally {
        getSession().setProperty("NoCacheStateInstances", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PRCU_ST objects for this R_DEPT
      * old R_PRCU_ST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PRCU_ST objects.
      */
      public Enumeration   getOldStateInstances()
      {
         
         if (!getSession().getProperty("NoCacheStateInstances").equals("true"))
         
         {
            if ( StateInstancesCache != null ) return StateInstancesCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PRCU_ST";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheStateInstances").equals("true"))
         {
            StateInstancesCache = new ObjectHashtable();
            for (Enumeration e = (R_PRCU_STBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               StateInstancesCache.put(pkey,cacheBO);                        
            }
         
            return (StateInstancesCache.elements());
         }
         else
         {
         
            return (R_PRCU_STBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PYMT_HLD_TYP_DPT objects for this R_DEPT
      * old R_PYMT_HLD_TYP_DPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PYMT_HLD_TYP_DPT objects.
      */
  public Enumeration getOldRDeptToRPayHldByDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRPayHldByDept");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRPayHldByDept", "false");
    else
      getSession().setProperty("NoCacheRDeptToRPayHldByDept", "true");

    try {
      return getOldRDeptToRPayHldByDept();
    } finally {
        getSession().setProperty("NoCacheRDeptToRPayHldByDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PYMT_HLD_TYP_DPT objects for this R_DEPT
      * old R_PYMT_HLD_TYP_DPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PYMT_HLD_TYP_DPT objects.
      */
      public Enumeration   getOldRDeptToRPayHldByDept()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRPayHldByDept").equals("true"))
         
         {
            if ( RDeptToRPayHldByDeptCache != null ) return RDeptToRPayHldByDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PYMT_HLD_TYP_DPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRPayHldByDept").equals("true"))
         {
            RDeptToRPayHldByDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_PYMT_HLD_TYP_DPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRPayHldByDeptCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRPayHldByDeptCache.elements());
         }
         else
         {
         
            return (R_PYMT_HLD_TYP_DPTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_STPF objects for this R_DEPT
      * old R_STPF objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_STPF objects.
      */
  public Enumeration getOldR_STPF(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_STPF");
    if (cache)
      getSession().setProperty("NoCacheR_STPF", "false");
    else
      getSession().setProperty("NoCacheR_STPF", "true");

    try {
      return getOldR_STPF();
    } finally {
        getSession().setProperty("NoCacheR_STPF", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_STPF objects for this R_DEPT
      * old R_STPF objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_STPF objects.
      */
      public Enumeration   getOldR_STPF()
      {
         
         if (!getSession().getProperty("NoCacheR_STPF").equals("true"))
         
         {
            if ( R_STPFCache != null ) return R_STPFCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_STPF";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_STPF").equals("true"))
         {
            R_STPFCache = new ObjectHashtable();
            for (Enumeration e = (R_STPFBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_STPFCache.put(pkey,cacheBO);                        
            }
         
            return (R_STPFCache.elements());
         }
         else
         {
         
            return (R_STPFBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_UR_CTRL objects for this R_DEPT
      * old R_UR_CTRL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_UR_CTRL objects.
      */
  public Enumeration getOldUniversalRequestorControls(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheUniversalRequestorControls");
    if (cache)
      getSession().setProperty("NoCacheUniversalRequestorControls", "false");
    else
      getSession().setProperty("NoCacheUniversalRequestorControls", "true");

    try {
      return getOldUniversalRequestorControls();
    } finally {
        getSession().setProperty("NoCacheUniversalRequestorControls", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_UR_CTRL objects for this R_DEPT
      * old R_UR_CTRL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_UR_CTRL objects.
      */
      public Enumeration   getOldUniversalRequestorControls()
      {
         
         if (!getSession().getProperty("NoCacheUniversalRequestorControls").equals("true"))
         
         {
            if ( UniversalRequestorControlsCache != null ) return UniversalRequestorControlsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_UR_CTRL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheUniversalRequestorControls").equals("true"))
         {
            UniversalRequestorControlsCache = new ObjectHashtable();
            for (Enumeration e = (R_UR_CTRLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               UniversalRequestorControlsCache.put(pkey,cacheBO);                        
            }
         
            return (UniversalRequestorControlsCache.elements());
         }
         else
         {
         
            return (R_UR_CTRLBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_USER_GRP_TMPL objects for this R_DEPT
      * old R_USER_GRP_TMPL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_USER_GRP_TMPL objects.
      */
  public Enumeration getOldUserGrpTmplToDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheUserGrpTmplToDept");
    if (cache)
      getSession().setProperty("NoCacheUserGrpTmplToDept", "false");
    else
      getSession().setProperty("NoCacheUserGrpTmplToDept", "true");

    try {
      return getOldUserGrpTmplToDept();
    } finally {
        getSession().setProperty("NoCacheUserGrpTmplToDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_USER_GRP_TMPL objects for this R_DEPT
      * old R_USER_GRP_TMPL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_USER_GRP_TMPL objects.
      */
      public Enumeration   getOldUserGrpTmplToDept()
      {
         
         if (!getSession().getProperty("NoCacheUserGrpTmplToDept").equals("true"))
         
         {
            if ( UserGrpTmplToDeptCache != null ) return UserGrpTmplToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_USER_GRP_TMPL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheUserGrpTmplToDept").equals("true"))
         {
            UserGrpTmplToDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_USER_GRP_TMPLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               UserGrpTmplToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (UserGrpTmplToDeptCache.elements());
         }
         else
         {
         
            return (R_USER_GRP_TMPLBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_VEND_LST objects for this R_DEPT
      * old R_VEND_LST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_VEND_LST objects.
      */
  public Enumeration getOldR_VEND_LSTs2(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_VEND_LSTs2");
    if (cache)
      getSession().setProperty("NoCacheR_VEND_LSTs2", "false");
    else
      getSession().setProperty("NoCacheR_VEND_LSTs2", "true");

    try {
      return getOldR_VEND_LSTs2();
    } finally {
        getSession().setProperty("NoCacheR_VEND_LSTs2", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_VEND_LST objects for this R_DEPT
      * old R_VEND_LST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_VEND_LST objects.
      */
      public Enumeration   getOldR_VEND_LSTs2()
      {
         
         if (!getSession().getProperty("NoCacheR_VEND_LSTs2").equals("true"))
         
         {
            if ( R_VEND_LSTs2Cache != null ) return R_VEND_LSTs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_VEND_LST";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_VEND_LSTs2").equals("true"))
         {
            R_VEND_LSTs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_VEND_LSTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_VEND_LSTs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_VEND_LSTs2Cache.elements());
         }
         else
         {
         
            return (R_VEND_LSTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old REQ_ACTV_SACTV objects for this R_DEPT
      * old REQ_ACTV_SACTV objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old REQ_ACTV_SACTV objects.
      */
  public Enumeration getOldREQ_ACTV_SACTVs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheREQ_ACTV_SACTVs");
    if (cache)
      getSession().setProperty("NoCacheREQ_ACTV_SACTVs", "false");
    else
      getSession().setProperty("NoCacheREQ_ACTV_SACTVs", "true");

    try {
      return getOldREQ_ACTV_SACTVs();
    } finally {
        getSession().setProperty("NoCacheREQ_ACTV_SACTVs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old REQ_ACTV_SACTV objects for this R_DEPT
      * old REQ_ACTV_SACTV objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old REQ_ACTV_SACTV objects.
      */
      public Enumeration   getOldREQ_ACTV_SACTVs()
      {
         
         if (!getSession().getProperty("NoCacheREQ_ACTV_SACTVs").equals("true"))
         
         {
            if ( REQ_ACTV_SACTVsCache != null ) return REQ_ACTV_SACTVsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_ACTV_SACTV";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheREQ_ACTV_SACTVs").equals("true"))
         {
            REQ_ACTV_SACTVsCache = new ObjectHashtable();
            for (Enumeration e = (REQ_ACTV_SACTVBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               REQ_ACTV_SACTVsCache.put(pkey,cacheBO);                        
            }
         
            return (REQ_ACTV_SACTVsCache.elements());
         }
         else
         {
         
            return (REQ_ACTV_SACTVBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old REQ_DEPT_OBJ_REV objects for this R_DEPT
      * old REQ_DEPT_OBJ_REV objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old REQ_DEPT_OBJ_REV objects.
      */
  public Enumeration getOldREQ_DEPT_OBJ_REVs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheREQ_DEPT_OBJ_REVs");
    if (cache)
      getSession().setProperty("NoCacheREQ_DEPT_OBJ_REVs", "false");
    else
      getSession().setProperty("NoCacheREQ_DEPT_OBJ_REVs", "true");

    try {
      return getOldREQ_DEPT_OBJ_REVs();
    } finally {
        getSession().setProperty("NoCacheREQ_DEPT_OBJ_REVs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old REQ_DEPT_OBJ_REV objects for this R_DEPT
      * old REQ_DEPT_OBJ_REV objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old REQ_DEPT_OBJ_REV objects.
      */
      public Enumeration   getOldREQ_DEPT_OBJ_REVs()
      {
         
         if (!getSession().getProperty("NoCacheREQ_DEPT_OBJ_REVs").equals("true"))
         
         {
            if ( REQ_DEPT_OBJ_REVsCache != null ) return REQ_DEPT_OBJ_REVsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_DEPT_OBJ_REV";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheREQ_DEPT_OBJ_REVs").equals("true"))
         {
            REQ_DEPT_OBJ_REVsCache = new ObjectHashtable();
            for (Enumeration e = (REQ_DEPT_OBJ_REVBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               REQ_DEPT_OBJ_REVsCache.put(pkey,cacheBO);                        
            }
         
            return (REQ_DEPT_OBJ_REVsCache.elements());
         }
         else
         {
         
            return (REQ_DEPT_OBJ_REVBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old REQ_FUND_DEPT objects for this R_DEPT
      * old REQ_FUND_DEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old REQ_FUND_DEPT objects.
      */
  public Enumeration getOldReqFundDeptToRDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheReqFundDeptToRDept");
    if (cache)
      getSession().setProperty("NoCacheReqFundDeptToRDept", "false");
    else
      getSession().setProperty("NoCacheReqFundDeptToRDept", "true");

    try {
      return getOldReqFundDeptToRDept();
    } finally {
        getSession().setProperty("NoCacheReqFundDeptToRDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old REQ_FUND_DEPT objects for this R_DEPT
      * old REQ_FUND_DEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old REQ_FUND_DEPT objects.
      */
      public Enumeration   getOldReqFundDeptToRDept()
      {
         
         if (!getSession().getProperty("NoCacheReqFundDeptToRDept").equals("true"))
         
         {
            if ( ReqFundDeptToRDeptCache != null ) return ReqFundDeptToRDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_FUND_DEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheReqFundDeptToRDept").equals("true"))
         {
            ReqFundDeptToRDeptCache = new ObjectHashtable();
            for (Enumeration e = (REQ_FUND_DEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ReqFundDeptToRDeptCache.put(pkey,cacheBO);                        
            }
         
            return (ReqFundDeptToRDeptCache.elements());
         }
         else
         {
         
            return (REQ_FUND_DEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old REQ_FUND_UNIT_OBJ objects for this R_DEPT
      * old REQ_FUND_UNIT_OBJ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old REQ_FUND_UNIT_OBJ objects.
      */
  public Enumeration getOldREQ_FUND_UNIT_OBJs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheREQ_FUND_UNIT_OBJs");
    if (cache)
      getSession().setProperty("NoCacheREQ_FUND_UNIT_OBJs", "false");
    else
      getSession().setProperty("NoCacheREQ_FUND_UNIT_OBJs", "true");

    try {
      return getOldREQ_FUND_UNIT_OBJs();
    } finally {
        getSession().setProperty("NoCacheREQ_FUND_UNIT_OBJs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old REQ_FUND_UNIT_OBJ objects for this R_DEPT
      * old REQ_FUND_UNIT_OBJ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old REQ_FUND_UNIT_OBJ objects.
      */
      public Enumeration   getOldREQ_FUND_UNIT_OBJs()
      {
         
         if (!getSession().getProperty("NoCacheREQ_FUND_UNIT_OBJs").equals("true"))
         
         {
            if ( REQ_FUND_UNIT_OBJsCache != null ) return REQ_FUND_UNIT_OBJsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_FUND_UNIT_OBJ";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheREQ_FUND_UNIT_OBJs").equals("true"))
         {
            REQ_FUND_UNIT_OBJsCache = new ObjectHashtable();
            for (Enumeration e = (REQ_FUND_UNIT_OBJBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               REQ_FUND_UNIT_OBJsCache.put(pkey,cacheBO);                        
            }
         
            return (REQ_FUND_UNIT_OBJsCache.elements());
         }
         else
         {
         
            return (REQ_FUND_UNIT_OBJBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old REQ_FUND_UNIT_RSRC objects for this R_DEPT
      * old REQ_FUND_UNIT_RSRC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old REQ_FUND_UNIT_RSRC objects.
      */
  public Enumeration getOldREQ_FUND_UNIT_RSRCs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheREQ_FUND_UNIT_RSRCs");
    if (cache)
      getSession().setProperty("NoCacheREQ_FUND_UNIT_RSRCs", "false");
    else
      getSession().setProperty("NoCacheREQ_FUND_UNIT_RSRCs", "true");

    try {
      return getOldREQ_FUND_UNIT_RSRCs();
    } finally {
        getSession().setProperty("NoCacheREQ_FUND_UNIT_RSRCs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old REQ_FUND_UNIT_RSRC objects for this R_DEPT
      * old REQ_FUND_UNIT_RSRC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old REQ_FUND_UNIT_RSRC objects.
      */
      public Enumeration   getOldREQ_FUND_UNIT_RSRCs()
      {
         
         if (!getSession().getProperty("NoCacheREQ_FUND_UNIT_RSRCs").equals("true"))
         
         {
            if ( REQ_FUND_UNIT_RSRCsCache != null ) return REQ_FUND_UNIT_RSRCsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_FUND_UNIT_RSRC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheREQ_FUND_UNIT_RSRCs").equals("true"))
         {
            REQ_FUND_UNIT_RSRCsCache = new ObjectHashtable();
            for (Enumeration e = (REQ_FUND_UNIT_RSRCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               REQ_FUND_UNIT_RSRCsCache.put(pkey,cacheBO);                        
            }
         
            return (REQ_FUND_UNIT_RSRCsCache.elements());
         }
         else
         {
         
            return (REQ_FUND_UNIT_RSRCBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old REQ_UNIT objects for this R_DEPT
      * old REQ_UNIT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old REQ_UNIT objects.
      */
  public Enumeration getOldREQ_UNITs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheREQ_UNITs");
    if (cache)
      getSession().setProperty("NoCacheREQ_UNITs", "false");
    else
      getSession().setProperty("NoCacheREQ_UNITs", "true");

    try {
      return getOldREQ_UNITs();
    } finally {
        getSession().setProperty("NoCacheREQ_UNITs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old REQ_UNIT objects for this R_DEPT
      * old REQ_UNIT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old REQ_UNIT objects.
      */
      public Enumeration   getOldREQ_UNITs()
      {
         
         if (!getSession().getProperty("NoCacheREQ_UNITs").equals("true"))
         
         {
            if ( REQ_UNITsCache != null ) return REQ_UNITsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_UNIT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheREQ_UNITs").equals("true"))
         {
            REQ_UNITsCache = new ObjectHashtable();
            for (Enumeration e = (REQ_UNITBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               REQ_UNITsCache.put(pkey,cacheBO);                        
            }
         
            return (REQ_UNITsCache.elements());
         }
         else
         {
         
            return (REQ_UNITBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old REQ_UNIT_PROG objects for this R_DEPT
      * old REQ_UNIT_PROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old REQ_UNIT_PROG objects.
      */
  public Enumeration getOldDeptToReqUnitProg(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToReqUnitProg");
    if (cache)
      getSession().setProperty("NoCacheDeptToReqUnitProg", "false");
    else
      getSession().setProperty("NoCacheDeptToReqUnitProg", "true");

    try {
      return getOldDeptToReqUnitProg();
    } finally {
        getSession().setProperty("NoCacheDeptToReqUnitProg", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old REQ_UNIT_PROG objects for this R_DEPT
      * old REQ_UNIT_PROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old REQ_UNIT_PROG objects.
      */
      public Enumeration   getOldDeptToReqUnitProg()
      {
         
         if (!getSession().getProperty("NoCacheDeptToReqUnitProg").equals("true"))
         
         {
            if ( DeptToReqUnitProgCache != null ) return DeptToReqUnitProgCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_UNIT_PROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToReqUnitProg").equals("true"))
         {
            DeptToReqUnitProgCache = new ObjectHashtable();
            for (Enumeration e = (REQ_UNIT_PROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToReqUnitProgCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToReqUnitProgCache.elements());
         }
         else
         {
         
            return (REQ_UNIT_PROGBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old REQ_UNIT_SUNIT objects for this R_DEPT
      * old REQ_UNIT_SUNIT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old REQ_UNIT_SUNIT objects.
      */
  public Enumeration getOldREQ_UNIT_SUNITs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheREQ_UNIT_SUNITs");
    if (cache)
      getSession().setProperty("NoCacheREQ_UNIT_SUNITs", "false");
    else
      getSession().setProperty("NoCacheREQ_UNIT_SUNITs", "true");

    try {
      return getOldREQ_UNIT_SUNITs();
    } finally {
        getSession().setProperty("NoCacheREQ_UNIT_SUNITs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old REQ_UNIT_SUNIT objects for this R_DEPT
      * old REQ_UNIT_SUNIT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old REQ_UNIT_SUNIT objects.
      */
      public Enumeration   getOldREQ_UNIT_SUNITs()
      {
         
         if (!getSession().getProperty("NoCacheREQ_UNIT_SUNITs").equals("true"))
         
         {
            if ( REQ_UNIT_SUNITsCache != null ) return REQ_UNIT_SUNITsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "REQ_UNIT_SUNIT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheREQ_UNIT_SUNITs").equals("true"))
         {
            REQ_UNIT_SUNITsCache = new ObjectHashtable();
            for (Enumeration e = (REQ_UNIT_SUNITBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               REQ_UNIT_SUNITsCache.put(pkey,cacheBO);                        
            }
         
            return (REQ_UNIT_SUNITsCache.elements());
         }
         else
         {
         
            return (REQ_UNIT_SUNITBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_OTPT_PARM_DET objects for this R_DEPT
      * old R_OTPT_PARM_DET objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_OTPT_PARM_DET objects.
      */
  public Enumeration getOldR_OTPT_PARM_DETs3(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_OTPT_PARM_DETs3");
    if (cache)
      getSession().setProperty("NoCacheR_OTPT_PARM_DETs3", "false");
    else
      getSession().setProperty("NoCacheR_OTPT_PARM_DETs3", "true");

    try {
      return getOldR_OTPT_PARM_DETs3();
    } finally {
        getSession().setProperty("NoCacheR_OTPT_PARM_DETs3", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_OTPT_PARM_DET objects for this R_DEPT
      * old R_OTPT_PARM_DET objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_OTPT_PARM_DET objects.
      */
      public Enumeration   getOldR_OTPT_PARM_DETs3()
      {
         
         if (!getSession().getProperty("NoCacheR_OTPT_PARM_DETs3").equals("true"))
         
         {
            if ( R_OTPT_PARM_DETs3Cache != null ) return R_OTPT_PARM_DETs3Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_OTPT_PARM_DET";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_OTPT_PARM_DETs3").equals("true"))
         {
            R_OTPT_PARM_DETs3Cache = new ObjectHashtable();
            for (Enumeration e = (R_OTPT_PARM_DETBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_OTPT_PARM_DETs3Cache.put(pkey,cacheBO);                        
            }
         
            return (R_OTPT_PARM_DETs3Cache.elements());
         }
         else
         {
         
            return (R_OTPT_PARM_DETBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_GRNTR_EVNT_SCHED objects for this R_DEPT
      * old R_GRNTR_EVNT_SCHED objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_GRNTR_EVNT_SCHED objects.
      */
  public Enumeration getOldRDeptToRGrntrEvntSched2(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRGrntrEvntSched2");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRGrntrEvntSched2", "false");
    else
      getSession().setProperty("NoCacheRDeptToRGrntrEvntSched2", "true");

    try {
      return getOldRDeptToRGrntrEvntSched2();
    } finally {
        getSession().setProperty("NoCacheRDeptToRGrntrEvntSched2", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_GRNTR_EVNT_SCHED objects for this R_DEPT
      * old R_GRNTR_EVNT_SCHED objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_GRNTR_EVNT_SCHED objects.
      */
      public Enumeration   getOldRDeptToRGrntrEvntSched2()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntrEvntSched2").equals("true"))
         
         {
            if ( RDeptToRGrntrEvntSched2Cache != null ) return RDeptToRGrntrEvntSched2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNTR_EVNT_SCHED";
            param.fieldName = "AWD_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntrEvntSched2").equals("true"))
         {
            RDeptToRGrntrEvntSched2Cache = new ObjectHashtable();
            for (Enumeration e = (R_GRNTR_EVNT_SCHEDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntrEvntSched2Cache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntrEvntSched2Cache.elements());
         }
         else
         {
         
            return (R_GRNTR_EVNT_SCHEDBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FARO_PARM objects for this R_DEPT
      * old R_FARO_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FARO_PARM objects.
      */
  public Enumeration getOldR_FARO_PARMs3(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_FARO_PARMs3");
    if (cache)
      getSession().setProperty("NoCacheR_FARO_PARMs3", "false");
    else
      getSession().setProperty("NoCacheR_FARO_PARMs3", "true");

    try {
      return getOldR_FARO_PARMs3();
    } finally {
        getSession().setProperty("NoCacheR_FARO_PARMs3", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FARO_PARM objects for this R_DEPT
      * old R_FARO_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FARO_PARM objects.
      */
      public Enumeration   getOldR_FARO_PARMs3()
      {
         
         if (!getSession().getProperty("NoCacheR_FARO_PARMs3").equals("true"))
         
         {
            if ( R_FARO_PARMs3Cache != null ) return R_FARO_PARMs3Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FARO_PARM";
            param.fieldName = "NEW_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_FARO_PARMs3").equals("true"))
         {
            R_FARO_PARMs3Cache = new ObjectHashtable();
            for (Enumeration e = (R_FARO_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_FARO_PARMs3Cache.put(pkey,cacheBO);                        
            }
         
            return (R_FARO_PARMs3Cache.elements());
         }
         else
         {
         
            return (R_FARO_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_CLMTRK objects for this R_DEPT
      * old R_CLMTRK objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_CLMTRK objects.
      */
  public Enumeration getOldDeptToClmtrk1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToClmtrk1");
    if (cache)
      getSession().setProperty("NoCacheDeptToClmtrk1", "false");
    else
      getSession().setProperty("NoCacheDeptToClmtrk1", "true");

    try {
      return getOldDeptToClmtrk1();
    } finally {
        getSession().setProperty("NoCacheDeptToClmtrk1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_CLMTRK objects for this R_DEPT
      * old R_CLMTRK objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_CLMTRK objects.
      */
      public Enumeration   getOldDeptToClmtrk1()
      {
         
         if (!getSession().getProperty("NoCacheDeptToClmtrk1").equals("true"))
         
         {
            if ( DeptToClmtrk1Cache != null ) return DeptToClmtrk1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CLMTRK";
            param.fieldName = "AWD_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToClmtrk1").equals("true"))
         {
            DeptToClmtrk1Cache = new ObjectHashtable();
            for (Enumeration e = (R_CLMTRKBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToClmtrk1Cache.put(pkey,cacheBO);                        
            }
         
            return (DeptToClmtrk1Cache.elements());
         }
         else
         {
         
            return (R_CLMTRKBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old GT_DOC_PMGMTUSR objects for this R_DEPT
      * old GT_DOC_PMGMTUSR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old GT_DOC_PMGMTUSR objects.
      */
  public Enumeration getOldRDeptToGtDocProgMgmtUsr(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToGtDocProgMgmtUsr");
    if (cache)
      getSession().setProperty("NoCacheRDeptToGtDocProgMgmtUsr", "false");
    else
      getSession().setProperty("NoCacheRDeptToGtDocProgMgmtUsr", "true");

    try {
      return getOldRDeptToGtDocProgMgmtUsr();
    } finally {
        getSession().setProperty("NoCacheRDeptToGtDocProgMgmtUsr", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old GT_DOC_PMGMTUSR objects for this R_DEPT
      * old GT_DOC_PMGMTUSR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old GT_DOC_PMGMTUSR objects.
      */
      public Enumeration   getOldRDeptToGtDocProgMgmtUsr()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToGtDocProgMgmtUsr").equals("true"))
         
         {
            if ( RDeptToGtDocProgMgmtUsrCache != null ) return RDeptToGtDocProgMgmtUsrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_PMGMTUSR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToGtDocProgMgmtUsr").equals("true"))
         {
            RDeptToGtDocProgMgmtUsrCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_PMGMTUSRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToGtDocProgMgmtUsrCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToGtDocProgMgmtUsrCache.elements());
         }
         else
         {
         
            return (GT_DOC_PMGMTUSRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old ACRL_CLR_EXCL objects for this R_DEPT
      * old ACRL_CLR_EXCL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old ACRL_CLR_EXCL objects.
      */
  public Enumeration getOldACRL_CLR_EXCL(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheACRL_CLR_EXCL");
    if (cache)
      getSession().setProperty("NoCacheACRL_CLR_EXCL", "false");
    else
      getSession().setProperty("NoCacheACRL_CLR_EXCL", "true");

    try {
      return getOldACRL_CLR_EXCL();
    } finally {
        getSession().setProperty("NoCacheACRL_CLR_EXCL", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old ACRL_CLR_EXCL objects for this R_DEPT
      * old ACRL_CLR_EXCL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old ACRL_CLR_EXCL objects.
      */
      public Enumeration   getOldACRL_CLR_EXCL()
      {
         
         if (!getSession().getProperty("NoCacheACRL_CLR_EXCL").equals("true"))
         
         {
            if ( ACRL_CLR_EXCLCache != null ) return ACRL_CLR_EXCLCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ACRL_CLR_EXCL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheACRL_CLR_EXCL").equals("true"))
         {
            ACRL_CLR_EXCLCache = new ObjectHashtable();
            for (Enumeration e = (ACRL_CLR_EXCLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ACRL_CLR_EXCLCache.put(pkey,cacheBO);                        
            }
         
            return (ACRL_CLR_EXCLCache.elements());
         }
         else
         {
         
            return (ACRL_CLR_EXCLBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old RQ_DOC_CMPSHT objects for this R_DEPT
      * old RQ_DOC_CMPSHT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old RQ_DOC_CMPSHT objects.
      */
  public Enumeration getOldRQ_DOC_CMPSHT(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRQ_DOC_CMPSHT");
    if (cache)
      getSession().setProperty("NoCacheRQ_DOC_CMPSHT", "false");
    else
      getSession().setProperty("NoCacheRQ_DOC_CMPSHT", "true");

    try {
      return getOldRQ_DOC_CMPSHT();
    } finally {
        getSession().setProperty("NoCacheRQ_DOC_CMPSHT", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old RQ_DOC_CMPSHT objects for this R_DEPT
      * old RQ_DOC_CMPSHT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old RQ_DOC_CMPSHT objects.
      */
      public Enumeration   getOldRQ_DOC_CMPSHT()
      {
         
         if (!getSession().getProperty("NoCacheRQ_DOC_CMPSHT").equals("true"))
         
         {
            if ( RQ_DOC_CMPSHTCache != null ) return RQ_DOC_CMPSHTCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "RQ_DOC_CMPSHT";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRQ_DOC_CMPSHT").equals("true"))
         {
            RQ_DOC_CMPSHTCache = new ObjectHashtable();
            for (Enumeration e = (RQ_DOC_CMPSHTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RQ_DOC_CMPSHTCache.put(pkey,cacheBO);                        
            }
         
            return (RQ_DOC_CMPSHTCache.elements());
         }
         else
         {
         
            return (RQ_DOC_CMPSHTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_MJR_PGRP objects for this R_DEPT
      * old R_MJR_PGRP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_MJR_PGRP objects.
      */
  public Enumeration getOldR_MJR_PGRPs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_MJR_PGRPs1");
    if (cache)
      getSession().setProperty("NoCacheR_MJR_PGRPs1", "false");
    else
      getSession().setProperty("NoCacheR_MJR_PGRPs1", "true");

    try {
      return getOldR_MJR_PGRPs1();
    } finally {
        getSession().setProperty("NoCacheR_MJR_PGRPs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_MJR_PGRP objects for this R_DEPT
      * old R_MJR_PGRP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_MJR_PGRP objects.
      */
      public Enumeration   getOldR_MJR_PGRPs1()
      {
         
         if (!getSession().getProperty("NoCacheR_MJR_PGRPs1").equals("true"))
         
         {
            if ( R_MJR_PGRPs1Cache != null ) return R_MJR_PGRPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_MJR_PGRP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_MJR_PGRPs1").equals("true"))
         {
            R_MJR_PGRPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_MJR_PGRPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_MJR_PGRPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_MJR_PGRPs1Cache.elements());
         }
         else
         {
         
            return (R_MJR_PGRPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_INTR_ACTG_CRSWLK objects for this R_DEPT
      * old R_INTR_ACTG_CRSWLK objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_INTR_ACTG_CRSWLK objects.
      */
  public Enumeration getOldIntrActgToDocDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheIntrActgToDocDept");
    if (cache)
      getSession().setProperty("NoCacheIntrActgToDocDept", "false");
    else
      getSession().setProperty("NoCacheIntrActgToDocDept", "true");

    try {
      return getOldIntrActgToDocDept();
    } finally {
        getSession().setProperty("NoCacheIntrActgToDocDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_INTR_ACTG_CRSWLK objects for this R_DEPT
      * old R_INTR_ACTG_CRSWLK objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_INTR_ACTG_CRSWLK objects.
      */
      public Enumeration   getOldIntrActgToDocDept()
      {
         
         if (!getSession().getProperty("NoCacheIntrActgToDocDept").equals("true"))
         
         {
            if ( IntrActgToDocDeptCache != null ) return IntrActgToDocDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_INTR_ACTG_CRSWLK";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheIntrActgToDocDept").equals("true"))
         {
            IntrActgToDocDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_INTR_ACTG_CRSWLKBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               IntrActgToDocDeptCache.put(pkey,cacheBO);                        
            }
         
            return (IntrActgToDocDeptCache.elements());
         }
         else
         {
         
            return (R_INTR_ACTG_CRSWLKBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FACPAT objects for this R_DEPT
      * old R_FACPAT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FACPAT objects.
      */
  public Enumeration getOldFacpatToDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheFacpatToDept");
    if (cache)
      getSession().setProperty("NoCacheFacpatToDept", "false");
    else
      getSession().setProperty("NoCacheFacpatToDept", "true");

    try {
      return getOldFacpatToDept();
    } finally {
        getSession().setProperty("NoCacheFacpatToDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FACPAT objects for this R_DEPT
      * old R_FACPAT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FACPAT objects.
      */
      public Enumeration   getOldFacpatToDept()
      {
         
         if (!getSession().getProperty("NoCacheFacpatToDept").equals("true"))
         
         {
            if ( FacpatToDeptCache != null ) return FacpatToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FACPAT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheFacpatToDept").equals("true"))
         {
            FacpatToDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_FACPATBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               FacpatToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (FacpatToDeptCache.elements());
         }
         else
         {
         
            return (R_FACPATBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FACPAD objects for this R_DEPT
      * old R_FACPAD objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FACPAD objects.
      */
  public Enumeration getOldFacpadToDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheFacpadToDept");
    if (cache)
      getSession().setProperty("NoCacheFacpadToDept", "false");
    else
      getSession().setProperty("NoCacheFacpadToDept", "true");

    try {
      return getOldFacpadToDept();
    } finally {
        getSession().setProperty("NoCacheFacpadToDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FACPAD objects for this R_DEPT
      * old R_FACPAD objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FACPAD objects.
      */
      public Enumeration   getOldFacpadToDept()
      {
         
         if (!getSession().getProperty("NoCacheFacpadToDept").equals("true"))
         
         {
            if ( FacpadToDeptCache != null ) return FacpadToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FACPAD";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheFacpadToDept").equals("true"))
         {
            FacpadToDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_FACPADBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               FacpadToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (FacpadToDeptCache.elements());
         }
         else
         {
         
            return (R_FACPADBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DOCAT objects for this R_DEPT
      * old R_DOCAT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DOCAT objects.
      */
  public Enumeration getOldR_DOCATs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_DOCATs1");
    if (cache)
      getSession().setProperty("NoCacheR_DOCATs1", "false");
    else
      getSession().setProperty("NoCacheR_DOCATs1", "true");

    try {
      return getOldR_DOCATs1();
    } finally {
        getSession().setProperty("NoCacheR_DOCATs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DOCAT objects for this R_DEPT
      * old R_DOCAT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DOCAT objects.
      */
      public Enumeration   getOldR_DOCATs1()
      {
         
         if (!getSession().getProperty("NoCacheR_DOCATs1").equals("true"))
         
         {
            if ( R_DOCATs1Cache != null ) return R_DOCATs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DOCAT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DOCATs1").equals("true"))
         {
            R_DOCATs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DOCATBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DOCATs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DOCATs1Cache.elements());
         }
         else
         {
         
            return (R_DOCATBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_BFY_STPF_SPND objects for this R_DEPT
      * old R_BFY_STPF_SPND objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_BFY_STPF_SPND objects.
      */
  public Enumeration getOldRDept_RBfyStpfSpnd(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDept_RBfyStpfSpnd");
    if (cache)
      getSession().setProperty("NoCacheRDept_RBfyStpfSpnd", "false");
    else
      getSession().setProperty("NoCacheRDept_RBfyStpfSpnd", "true");

    try {
      return getOldRDept_RBfyStpfSpnd();
    } finally {
        getSession().setProperty("NoCacheRDept_RBfyStpfSpnd", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_BFY_STPF_SPND objects for this R_DEPT
      * old R_BFY_STPF_SPND objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_BFY_STPF_SPND objects.
      */
      public Enumeration   getOldRDept_RBfyStpfSpnd()
      {
         
         if (!getSession().getProperty("NoCacheRDept_RBfyStpfSpnd").equals("true"))
         
         {
            if ( RDept_RBfyStpfSpndCache != null ) return RDept_RBfyStpfSpndCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_BFY_STPF_SPND";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDept_RBfyStpfSpnd").equals("true"))
         {
            RDept_RBfyStpfSpndCache = new ObjectHashtable();
            for (Enumeration e = (R_BFY_STPF_SPNDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDept_RBfyStpfSpndCache.put(pkey,cacheBO);                        
            }
         
            return (RDept_RBfyStpfSpndCache.elements());
         }
         else
         {
         
            return (R_BFY_STPF_SPNDBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_AP_DISB_PARM objects for this R_DEPT
      * old R_AP_DISB_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_AP_DISB_PARM objects.
      */
  public Enumeration getOldR_AP_DISB_PARMs3(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_AP_DISB_PARMs3");
    if (cache)
      getSession().setProperty("NoCacheR_AP_DISB_PARMs3", "false");
    else
      getSession().setProperty("NoCacheR_AP_DISB_PARMs3", "true");

    try {
      return getOldR_AP_DISB_PARMs3();
    } finally {
        getSession().setProperty("NoCacheR_AP_DISB_PARMs3", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_AP_DISB_PARM objects for this R_DEPT
      * old R_AP_DISB_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_AP_DISB_PARM objects.
      */
      public Enumeration   getOldR_AP_DISB_PARMs3()
      {
         
         if (!getSession().getProperty("NoCacheR_AP_DISB_PARMs3").equals("true"))
         
         {
            if ( R_AP_DISB_PARMs3Cache != null ) return R_AP_DISB_PARMs3Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_DISB_PARM";
            param.fieldName = "DOC_DEPT";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_AP_DISB_PARMs3").equals("true"))
         {
            R_AP_DISB_PARMs3Cache = new ObjectHashtable();
            for (Enumeration e = (R_AP_DISB_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_AP_DISB_PARMs3Cache.put(pkey,cacheBO);                        
            }
         
            return (R_AP_DISB_PARMs3Cache.elements());
         }
         else
         {
         
            return (R_AP_DISB_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old MMR_DOC_HDR objects for this R_DEPT
      * old MMR_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old MMR_DOC_HDR objects.
      */
  public Enumeration getOldMMRDocHdrDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheMMRDocHdrDept");
    if (cache)
      getSession().setProperty("NoCacheMMRDocHdrDept", "false");
    else
      getSession().setProperty("NoCacheMMRDocHdrDept", "true");

    try {
      return getOldMMRDocHdrDept();
    } finally {
        getSession().setProperty("NoCacheMMRDocHdrDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old MMR_DOC_HDR objects for this R_DEPT
      * old MMR_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old MMR_DOC_HDR objects.
      */
      public Enumeration   getOldMMRDocHdrDept()
      {
         
         if (!getSession().getProperty("NoCacheMMRDocHdrDept").equals("true"))
         
         {
            if ( MMRDocHdrDeptCache != null ) return MMRDocHdrDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "MMR_DOC_HDR";
            param.fieldName = "NEW_RQSTR_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheMMRDocHdrDept").equals("true"))
         {
            MMRDocHdrDeptCache = new ObjectHashtable();
            for (Enumeration e = (MMR_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               MMRDocHdrDeptCache.put(pkey,cacheBO);                        
            }
         
            return (MMRDocHdrDeptCache.elements());
         }
         else
         {
         
            return (MMR_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old MA_DOC_SRTYINS objects for this R_DEPT
      * old MA_DOC_SRTYINS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old MA_DOC_SRTYINS objects.
      */
  public Enumeration getOldDeptToMaSrtyIns(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToMaSrtyIns");
    if (cache)
      getSession().setProperty("NoCacheDeptToMaSrtyIns", "false");
    else
      getSession().setProperty("NoCacheDeptToMaSrtyIns", "true");

    try {
      return getOldDeptToMaSrtyIns();
    } finally {
        getSession().setProperty("NoCacheDeptToMaSrtyIns", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old MA_DOC_SRTYINS objects for this R_DEPT
      * old MA_DOC_SRTYINS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old MA_DOC_SRTYINS objects.
      */
      public Enumeration   getOldDeptToMaSrtyIns()
      {
         
         if (!getSession().getProperty("NoCacheDeptToMaSrtyIns").equals("true"))
         
         {
            if ( DeptToMaSrtyInsCache != null ) return DeptToMaSrtyInsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "MA_DOC_SRTYINS";
            param.fieldName = "HLD_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToMaSrtyIns").equals("true"))
         {
            DeptToMaSrtyInsCache = new ObjectHashtable();
            for (Enumeration e = (MA_DOC_SRTYINSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToMaSrtyInsCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToMaSrtyInsCache.elements());
         }
         else
         {
         
            return (MA_DOC_SRTYINSBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old FNDC_DOC_FNDC objects for this R_DEPT
      * old FNDC_DOC_FNDC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old FNDC_DOC_FNDC objects.
      */
  public Enumeration getOldDeptToFndCDocFndC(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToFndCDocFndC");
    if (cache)
      getSession().setProperty("NoCacheDeptToFndCDocFndC", "false");
    else
      getSession().setProperty("NoCacheDeptToFndCDocFndC", "true");

    try {
      return getOldDeptToFndCDocFndC();
    } finally {
        getSession().setProperty("NoCacheDeptToFndCDocFndC", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old FNDC_DOC_FNDC objects for this R_DEPT
      * old FNDC_DOC_FNDC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old FNDC_DOC_FNDC objects.
      */
      public Enumeration   getOldDeptToFndCDocFndC()
      {
         
         if (!getSession().getProperty("NoCacheDeptToFndCDocFndC").equals("true"))
         
         {
            if ( DeptToFndCDocFndCCache != null ) return DeptToFndCDocFndCCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "FNDC_DOC_FNDC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToFndCDocFndC").equals("true"))
         {
            DeptToFndCDocFndCCache = new ObjectHashtable();
            for (Enumeration e = (FNDC_DOC_FNDCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToFndCDocFndCCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToFndCDocFndCCache.elements());
         }
         else
         {
         
            return (FNDC_DOC_FNDCBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old CMR_DOC_HDR objects for this R_DEPT
      * old CMR_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old CMR_DOC_HDR objects.
      */
  public Enumeration getOldRqstDeptToCMRDocHdr(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRqstDeptToCMRDocHdr");
    if (cache)
      getSession().setProperty("NoCacheRqstDeptToCMRDocHdr", "false");
    else
      getSession().setProperty("NoCacheRqstDeptToCMRDocHdr", "true");

    try {
      return getOldRqstDeptToCMRDocHdr();
    } finally {
        getSession().setProperty("NoCacheRqstDeptToCMRDocHdr", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old CMR_DOC_HDR objects for this R_DEPT
      * old CMR_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old CMR_DOC_HDR objects.
      */
      public Enumeration   getOldRqstDeptToCMRDocHdr()
      {
         
         if (!getSession().getProperty("NoCacheRqstDeptToCMRDocHdr").equals("true"))
         
         {
            if ( RqstDeptToCMRDocHdrCache != null ) return RqstDeptToCMRDocHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CMR_DOC_HDR";
            param.fieldName = "NEW_RQSTR_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRqstDeptToCMRDocHdr").equals("true"))
         {
            RqstDeptToCMRDocHdrCache = new ObjectHashtable();
            for (Enumeration e = (CMR_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RqstDeptToCMRDocHdrCache.put(pkey,cacheBO);                        
            }
         
            return (RqstDeptToCMRDocHdrCache.elements());
         }
         else
         {
         
            return (CMR_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_TASK objects for this R_DEPT
      * old R_TASK objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_TASK objects.
      */
  public Enumeration getOldR_TASKs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_TASKs1");
    if (cache)
      getSession().setProperty("NoCacheR_TASKs1", "false");
    else
      getSession().setProperty("NoCacheR_TASKs1", "true");

    try {
      return getOldR_TASKs1();
    } finally {
        getSession().setProperty("NoCacheR_TASKs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_TASK objects for this R_DEPT
      * old R_TASK objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_TASK objects.
      */
      public Enumeration   getOldR_TASKs1()
      {
         
         if (!getSession().getProperty("NoCacheR_TASKs1").equals("true"))
         
         {
            if ( R_TASKs1Cache != null ) return R_TASKs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_TASK";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_TASKs1").equals("true"))
         {
            R_TASKs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_TASKBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_TASKs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_TASKs1Cache.elements());
         }
         else
         {
         
            return (R_TASKBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PYMT_HLD_TIN objects for this R_DEPT
      * old R_PYMT_HLD_TIN objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PYMT_HLD_TIN objects.
      */
  public Enumeration getOldRDeptToRPayHldTin(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRPayHldTin");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRPayHldTin", "false");
    else
      getSession().setProperty("NoCacheRDeptToRPayHldTin", "true");

    try {
      return getOldRDeptToRPayHldTin();
    } finally {
        getSession().setProperty("NoCacheRDeptToRPayHldTin", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PYMT_HLD_TIN objects for this R_DEPT
      * old R_PYMT_HLD_TIN objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PYMT_HLD_TIN objects.
      */
      public Enumeration   getOldRDeptToRPayHldTin()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRPayHldTin").equals("true"))
         
         {
            if ( RDeptToRPayHldTinCache != null ) return RDeptToRPayHldTinCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PYMT_HLD_TIN";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRPayHldTin").equals("true"))
         {
            RDeptToRPayHldTinCache = new ObjectHashtable();
            for (Enumeration e = (R_PYMT_HLD_TINBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRPayHldTinCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRPayHldTinCache.elements());
         }
         else
         {
         
            return (R_PYMT_HLD_TINBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FSC objects for this R_DEPT
      * old R_FSC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FSC objects.
      */
  public Enumeration getOldRDeptToRFsc(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRFsc");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRFsc", "false");
    else
      getSession().setProperty("NoCacheRDeptToRFsc", "true");

    try {
      return getOldRDeptToRFsc();
    } finally {
        getSession().setProperty("NoCacheRDeptToRFsc", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FSC objects for this R_DEPT
      * old R_FSC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FSC objects.
      */
      public Enumeration   getOldRDeptToRFsc()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRFsc").equals("true"))
         
         {
            if ( RDeptToRFscCache != null ) return RDeptToRFscCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FSC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRFsc").equals("true"))
         {
            RDeptToRFscCache = new ObjectHashtable();
            for (Enumeration e = (R_FSCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRFscCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRFscCache.elements());
         }
         else
         {
         
            return (R_FSCBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FIN_CHRG_SETP objects for this R_DEPT
      * old R_FIN_CHRG_SETP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FIN_CHRG_SETP objects.
      */
  public Enumeration getOldR_FIN_CHRG_SETP(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_FIN_CHRG_SETP");
    if (cache)
      getSession().setProperty("NoCacheR_FIN_CHRG_SETP", "false");
    else
      getSession().setProperty("NoCacheR_FIN_CHRG_SETP", "true");

    try {
      return getOldR_FIN_CHRG_SETP();
    } finally {
        getSession().setProperty("NoCacheR_FIN_CHRG_SETP", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FIN_CHRG_SETP objects for this R_DEPT
      * old R_FIN_CHRG_SETP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FIN_CHRG_SETP objects.
      */
      public Enumeration   getOldR_FIN_CHRG_SETP()
      {
         
         if (!getSession().getProperty("NoCacheR_FIN_CHRG_SETP").equals("true"))
         
         {
            if ( R_FIN_CHRG_SETPCache != null ) return R_FIN_CHRG_SETPCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FIN_CHRG_SETP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_FIN_CHRG_SETP").equals("true"))
         {
            R_FIN_CHRG_SETPCache = new ObjectHashtable();
            for (Enumeration e = (R_FIN_CHRG_SETPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_FIN_CHRG_SETPCache.put(pkey,cacheBO);                        
            }
         
            return (R_FIN_CHRG_SETPCache.elements());
         }
         else
         {
         
            return (R_FIN_CHRG_SETPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FARO_PARM objects for this R_DEPT
      * old R_FARO_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FARO_PARM objects.
      */
  public Enumeration getOldR_FARO_PARMs2(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_FARO_PARMs2");
    if (cache)
      getSession().setProperty("NoCacheR_FARO_PARMs2", "false");
    else
      getSession().setProperty("NoCacheR_FARO_PARMs2", "true");

    try {
      return getOldR_FARO_PARMs2();
    } finally {
        getSession().setProperty("NoCacheR_FARO_PARMs2", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FARO_PARM objects for this R_DEPT
      * old R_FARO_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FARO_PARM objects.
      */
      public Enumeration   getOldR_FARO_PARMs2()
      {
         
         if (!getSession().getProperty("NoCacheR_FARO_PARMs2").equals("true"))
         
         {
            if ( R_FARO_PARMs2Cache != null ) return R_FARO_PARMs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FARO_PARM";
            param.fieldName = "OLD_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_FARO_PARMs2").equals("true"))
         {
            R_FARO_PARMs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_FARO_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_FARO_PARMs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_FARO_PARMs2Cache.elements());
         }
         else
         {
         
            return (R_FARO_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_CNTRC_GOAL_LN objects for this R_DEPT
      * old R_CNTRC_GOAL_LN objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_CNTRC_GOAL_LN objects.
      */
  public Enumeration getOldRDeptToRCntrcGlln1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRCntrcGlln1");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRCntrcGlln1", "false");
    else
      getSession().setProperty("NoCacheRDeptToRCntrcGlln1", "true");

    try {
      return getOldRDeptToRCntrcGlln1();
    } finally {
        getSession().setProperty("NoCacheRDeptToRCntrcGlln1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_CNTRC_GOAL_LN objects for this R_DEPT
      * old R_CNTRC_GOAL_LN objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_CNTRC_GOAL_LN objects.
      */
      public Enumeration   getOldRDeptToRCntrcGlln1()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRCntrcGlln1").equals("true"))
         
         {
            if ( RDeptToRCntrcGlln1Cache != null ) return RDeptToRCntrcGlln1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CNTRC_GOAL_LN";
            param.fieldName = "RESP_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRCntrcGlln1").equals("true"))
         {
            RDeptToRCntrcGlln1Cache = new ObjectHashtable();
            for (Enumeration e = (R_CNTRC_GOAL_LNBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRCntrcGlln1Cache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRCntrcGlln1Cache.elements());
         }
         else
         {
         
            return (R_CNTRC_GOAL_LNBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_BFY_STPF_BSA objects for this R_DEPT
      * old R_BFY_STPF_BSA objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_BFY_STPF_BSA objects.
      */
  public Enumeration getOldRDept_RBfyStpfBsa(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDept_RBfyStpfBsa");
    if (cache)
      getSession().setProperty("NoCacheRDept_RBfyStpfBsa", "false");
    else
      getSession().setProperty("NoCacheRDept_RBfyStpfBsa", "true");

    try {
      return getOldRDept_RBfyStpfBsa();
    } finally {
        getSession().setProperty("NoCacheRDept_RBfyStpfBsa", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_BFY_STPF_BSA objects for this R_DEPT
      * old R_BFY_STPF_BSA objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_BFY_STPF_BSA objects.
      */
      public Enumeration   getOldRDept_RBfyStpfBsa()
      {
         
         if (!getSession().getProperty("NoCacheRDept_RBfyStpfBsa").equals("true"))
         
         {
            if ( RDept_RBfyStpfBsaCache != null ) return RDept_RBfyStpfBsaCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_BFY_STPF_BSA";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDept_RBfyStpfBsa").equals("true"))
         {
            RDept_RBfyStpfBsaCache = new ObjectHashtable();
            for (Enumeration e = (R_BFY_STPF_BSABaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDept_RBfyStpfBsaCache.put(pkey,cacheBO);                        
            }
         
            return (RDept_RBfyStpfBsaCache.elements());
         }
         else
         {
         
            return (R_BFY_STPF_BSABaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_ADC_PARM objects for this R_DEPT
      * old R_ADC_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_ADC_PARM objects.
      */
  public Enumeration getOldRDeptToRAdcParm(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRAdcParm");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRAdcParm", "false");
    else
      getSession().setProperty("NoCacheRDeptToRAdcParm", "true");

    try {
      return getOldRDeptToRAdcParm();
    } finally {
        getSession().setProperty("NoCacheRDeptToRAdcParm", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_ADC_PARM objects for this R_DEPT
      * old R_ADC_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_ADC_PARM objects.
      */
      public Enumeration   getOldRDeptToRAdcParm()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRAdcParm").equals("true"))
         
         {
            if ( RDeptToRAdcParmCache != null ) return RDeptToRAdcParmCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ADC_PARM";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRAdcParm").equals("true"))
         {
            RDeptToRAdcParmCache = new ObjectHashtable();
            for (Enumeration e = (R_ADC_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRAdcParmCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRAdcParmCache.elements());
         }
         else
         {
         
            return (R_ADC_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old GT_DOC_PRTNRUSR objects for this R_DEPT
      * old GT_DOC_PRTNRUSR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old GT_DOC_PRTNRUSR objects.
      */
  public Enumeration getOldRDeptToGtDocPrtnrUsr(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToGtDocPrtnrUsr");
    if (cache)
      getSession().setProperty("NoCacheRDeptToGtDocPrtnrUsr", "false");
    else
      getSession().setProperty("NoCacheRDeptToGtDocPrtnrUsr", "true");

    try {
      return getOldRDeptToGtDocPrtnrUsr();
    } finally {
        getSession().setProperty("NoCacheRDeptToGtDocPrtnrUsr", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old GT_DOC_PRTNRUSR objects for this R_DEPT
      * old GT_DOC_PRTNRUSR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old GT_DOC_PRTNRUSR objects.
      */
      public Enumeration   getOldRDeptToGtDocPrtnrUsr()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToGtDocPrtnrUsr").equals("true"))
         
         {
            if ( RDeptToGtDocPrtnrUsrCache != null ) return RDeptToGtDocPrtnrUsrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_PRTNRUSR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToGtDocPrtnrUsr").equals("true"))
         {
            RDeptToGtDocPrtnrUsrCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_PRTNRUSRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToGtDocPrtnrUsrCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToGtDocPrtnrUsrCache.elements());
         }
         else
         {
         
            return (GT_DOC_PRTNRUSRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old CSAL_PROC_PARM objects for this R_DEPT
      * old CSAL_PROC_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old CSAL_PROC_PARM objects.
      */
  public Enumeration getOldRdeptToCsalProcParm(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRdeptToCsalProcParm");
    if (cache)
      getSession().setProperty("NoCacheRdeptToCsalProcParm", "false");
    else
      getSession().setProperty("NoCacheRdeptToCsalProcParm", "true");

    try {
      return getOldRdeptToCsalProcParm();
    } finally {
        getSession().setProperty("NoCacheRdeptToCsalProcParm", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old CSAL_PROC_PARM objects for this R_DEPT
      * old CSAL_PROC_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old CSAL_PROC_PARM objects.
      */
      public Enumeration   getOldRdeptToCsalProcParm()
      {
         
         if (!getSession().getProperty("NoCacheRdeptToCsalProcParm").equals("true"))
         
         {
            if ( RdeptToCsalProcParmCache != null ) return RdeptToCsalProcParmCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CSAL_PROC_PARM";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToCsalProcParm").equals("true"))
         {
            RdeptToCsalProcParmCache = new ObjectHashtable();
            for (Enumeration e = (CSAL_PROC_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToCsalProcParmCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToCsalProcParmCache.elements());
         }
         else
         {
         
            return (CSAL_PROC_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old VCM_DOC_PRVNT objects for this R_DEPT
      * old VCM_DOC_PRVNT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old VCM_DOC_PRVNT objects.
      */
  public Enumeration getOldVmPrvntDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheVmPrvntDept");
    if (cache)
      getSession().setProperty("NoCacheVmPrvntDept", "false");
    else
      getSession().setProperty("NoCacheVmPrvntDept", "true");

    try {
      return getOldVmPrvntDept();
    } finally {
        getSession().setProperty("NoCacheVmPrvntDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old VCM_DOC_PRVNT objects for this R_DEPT
      * old VCM_DOC_PRVNT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old VCM_DOC_PRVNT objects.
      */
      public Enumeration   getOldVmPrvntDept()
      {
         
         if (!getSession().getProperty("NoCacheVmPrvntDept").equals("true"))
         
         {
            if ( VmPrvntDeptCache != null ) return VmPrvntDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "VCM_DOC_PRVNT";
            param.fieldName = "NEW_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheVmPrvntDept").equals("true"))
         {
            VmPrvntDeptCache = new ObjectHashtable();
            for (Enumeration e = (VCM_DOC_PRVNTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               VmPrvntDeptCache.put(pkey,cacheBO);                        
            }
         
            return (VmPrvntDeptCache.elements());
         }
         else
         {
         
            return (VCM_DOC_PRVNTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_UTLY_ACTG_PRFL objects for this R_DEPT
      * old R_UTLY_ACTG_PRFL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_UTLY_ACTG_PRFL objects.
      */
  public Enumeration getOldRDeptToRUtlyActgPrfl(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRUtlyActgPrfl");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRUtlyActgPrfl", "false");
    else
      getSession().setProperty("NoCacheRDeptToRUtlyActgPrfl", "true");

    try {
      return getOldRDeptToRUtlyActgPrfl();
    } finally {
        getSession().setProperty("NoCacheRDeptToRUtlyActgPrfl", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_UTLY_ACTG_PRFL objects for this R_DEPT
      * old R_UTLY_ACTG_PRFL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_UTLY_ACTG_PRFL objects.
      */
      public Enumeration   getOldRDeptToRUtlyActgPrfl()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRUtlyActgPrfl").equals("true"))
         
         {
            if ( RDeptToRUtlyActgPrflCache != null ) return RDeptToRUtlyActgPrflCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_UTLY_ACTG_PRFL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRUtlyActgPrfl").equals("true"))
         {
            RDeptToRUtlyActgPrflCache = new ObjectHashtable();
            for (Enumeration e = (R_UTLY_ACTG_PRFLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRUtlyActgPrflCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRUtlyActgPrflCache.elements());
         }
         else
         {
         
            return (R_UTLY_ACTG_PRFLBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_UNIT objects for this R_DEPT
      * old R_UNIT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_UNIT objects.
      */
  public Enumeration getOldR_UNITs2(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_UNITs2");
    if (cache)
      getSession().setProperty("NoCacheR_UNITs2", "false");
    else
      getSession().setProperty("NoCacheR_UNITs2", "true");

    try {
      return getOldR_UNITs2();
    } finally {
        getSession().setProperty("NoCacheR_UNITs2", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_UNIT objects for this R_DEPT
      * old R_UNIT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_UNIT objects.
      */
      public Enumeration   getOldR_UNITs2()
      {
         
         if (!getSession().getProperty("NoCacheR_UNITs2").equals("true"))
         
         {
            if ( R_UNITs2Cache != null ) return R_UNITs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_UNIT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_UNITs2").equals("true"))
         {
            R_UNITs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_UNITBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_UNITs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_UNITs2Cache.elements());
         }
         else
         {
         
            return (R_UNITBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_TASK_ORD objects for this R_DEPT
      * old R_TASK_ORD objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_TASK_ORD objects.
      */
  public Enumeration getOldR_TASK_ORDs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_TASK_ORDs1");
    if (cache)
      getSession().setProperty("NoCacheR_TASK_ORDs1", "false");
    else
      getSession().setProperty("NoCacheR_TASK_ORDs1", "true");

    try {
      return getOldR_TASK_ORDs1();
    } finally {
        getSession().setProperty("NoCacheR_TASK_ORDs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_TASK_ORD objects for this R_DEPT
      * old R_TASK_ORD objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_TASK_ORD objects.
      */
      public Enumeration   getOldR_TASK_ORDs1()
      {
         
         if (!getSession().getProperty("NoCacheR_TASK_ORDs1").equals("true"))
         
         {
            if ( R_TASK_ORDs1Cache != null ) return R_TASK_ORDs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_TASK_ORD";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_TASK_ORDs1").equals("true"))
         {
            R_TASK_ORDs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_TASK_ORDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_TASK_ORDs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_TASK_ORDs1Cache.elements());
         }
         else
         {
         
            return (R_TASK_ORDBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_RGN objects for this R_DEPT
      * old R_RGN objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_RGN objects.
      */
  public Enumeration getOldRDeptToRRgn(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRRgn");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRRgn", "false");
    else
      getSession().setProperty("NoCacheRDeptToRRgn", "true");

    try {
      return getOldRDeptToRRgn();
    } finally {
        getSession().setProperty("NoCacheRDeptToRRgn", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_RGN objects for this R_DEPT
      * old R_RGN objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_RGN objects.
      */
      public Enumeration   getOldRDeptToRRgn()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRRgn").equals("true"))
         
         {
            if ( RDeptToRRgnCache != null ) return RDeptToRRgnCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_RGN";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRRgn").equals("true"))
         {
            RDeptToRRgnCache = new ObjectHashtable();
            for (Enumeration e = (R_RGNBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRRgnCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRRgnCache.elements());
         }
         else
         {
         
            return (R_RGNBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PGRP objects for this R_DEPT
      * old R_PGRP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PGRP objects.
      */
  public Enumeration getOldR_PGRPs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_PGRPs1");
    if (cache)
      getSession().setProperty("NoCacheR_PGRPs1", "false");
    else
      getSession().setProperty("NoCacheR_PGRPs1", "true");

    try {
      return getOldR_PGRPs1();
    } finally {
        getSession().setProperty("NoCacheR_PGRPs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PGRP objects for this R_DEPT
      * old R_PGRP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PGRP objects.
      */
      public Enumeration   getOldR_PGRPs1()
      {
         
         if (!getSession().getProperty("NoCacheR_PGRPs1").equals("true"))
         
         {
            if ( R_PGRPs1Cache != null ) return R_PGRPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PGRP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_PGRPs1").equals("true"))
         {
            R_PGRPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_PGRPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_PGRPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_PGRPs1Cache.elements());
         }
         else
         {
         
            return (R_PGRPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PART_USG objects for this R_DEPT
      * old R_PART_USG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PART_USG objects.
      */
  public Enumeration getOldDeptToPartUsg(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToPartUsg");
    if (cache)
      getSession().setProperty("NoCacheDeptToPartUsg", "false");
    else
      getSession().setProperty("NoCacheDeptToPartUsg", "true");

    try {
      return getOldDeptToPartUsg();
    } finally {
        getSession().setProperty("NoCacheDeptToPartUsg", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PART_USG objects for this R_DEPT
      * old R_PART_USG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PART_USG objects.
      */
      public Enumeration   getOldDeptToPartUsg()
      {
         
         if (!getSession().getProperty("NoCacheDeptToPartUsg").equals("true"))
         
         {
            if ( DeptToPartUsgCache != null ) return DeptToPartUsgCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PART_USG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToPartUsg").equals("true"))
         {
            DeptToPartUsgCache = new ObjectHashtable();
            for (Enumeration e = (R_PART_USGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToPartUsgCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToPartUsgCache.elements());
         }
         else
         {
         
            return (R_PART_USGBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_MJR_PTYP objects for this R_DEPT
      * old R_MJR_PTYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_MJR_PTYP objects.
      */
  public Enumeration getOldR_MJR_PTYPs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_MJR_PTYPs1");
    if (cache)
      getSession().setProperty("NoCacheR_MJR_PTYPs1", "false");
    else
      getSession().setProperty("NoCacheR_MJR_PTYPs1", "true");

    try {
      return getOldR_MJR_PTYPs1();
    } finally {
        getSession().setProperty("NoCacheR_MJR_PTYPs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_MJR_PTYP objects for this R_DEPT
      * old R_MJR_PTYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_MJR_PTYP objects.
      */
      public Enumeration   getOldR_MJR_PTYPs1()
      {
         
         if (!getSession().getProperty("NoCacheR_MJR_PTYPs1").equals("true"))
         
         {
            if ( R_MJR_PTYPs1Cache != null ) return R_MJR_PTYPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_MJR_PTYP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_MJR_PTYPs1").equals("true"))
         {
            R_MJR_PTYPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_MJR_PTYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_MJR_PTYPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_MJR_PTYPs1Cache.elements());
         }
         else
         {
         
            return (R_MJR_PTYPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DSTC objects for this R_DEPT
      * old R_DSTC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DSTC objects.
      */
  public Enumeration getOldR_DSTCs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_DSTCs1");
    if (cache)
      getSession().setProperty("NoCacheR_DSTCs1", "false");
    else
      getSession().setProperty("NoCacheR_DSTCs1", "true");

    try {
      return getOldR_DSTCs1();
    } finally {
        getSession().setProperty("NoCacheR_DSTCs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DSTC objects for this R_DEPT
      * old R_DSTC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DSTC objects.
      */
      public Enumeration   getOldR_DSTCs1()
      {
         
         if (!getSession().getProperty("NoCacheR_DSTCs1").equals("true"))
         
         {
            if ( R_DSTCs1Cache != null ) return R_DSTCs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DSTC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DSTCs1").equals("true"))
         {
            R_DSTCs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DSTCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DSTCs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DSTCs1Cache.elements());
         }
         else
         {
         
            return (R_DSTCBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_CNTRC_GOAL_LN objects for this R_DEPT
      * old R_CNTRC_GOAL_LN objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_CNTRC_GOAL_LN objects.
      */
  public Enumeration getOldRDeptToRCntrcGlln(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRCntrcGlln");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRCntrcGlln", "false");
    else
      getSession().setProperty("NoCacheRDeptToRCntrcGlln", "true");

    try {
      return getOldRDeptToRCntrcGlln();
    } finally {
        getSession().setProperty("NoCacheRDeptToRCntrcGlln", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_CNTRC_GOAL_LN objects for this R_DEPT
      * old R_CNTRC_GOAL_LN objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_CNTRC_GOAL_LN objects.
      */
      public Enumeration   getOldRDeptToRCntrcGlln()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRCntrcGlln").equals("true"))
         
         {
            if ( RDeptToRCntrcGllnCache != null ) return RDeptToRCntrcGllnCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CNTRC_GOAL_LN";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRCntrcGlln").equals("true"))
         {
            RDeptToRCntrcGllnCache = new ObjectHashtable();
            for (Enumeration e = (R_CNTRC_GOAL_LNBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRCntrcGllnCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRCntrcGllnCache.elements());
         }
         else
         {
         
            return (R_CNTRC_GOAL_LNBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_CASH_SW_SETP objects for this R_DEPT
      * old R_CASH_SW_SETP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_CASH_SW_SETP objects.
      */
  public Enumeration getOldRCashSweepToRDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRCashSweepToRDept");
    if (cache)
      getSession().setProperty("NoCacheRCashSweepToRDept", "false");
    else
      getSession().setProperty("NoCacheRCashSweepToRDept", "true");

    try {
      return getOldRCashSweepToRDept();
    } finally {
        getSession().setProperty("NoCacheRCashSweepToRDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_CASH_SW_SETP objects for this R_DEPT
      * old R_CASH_SW_SETP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_CASH_SW_SETP objects.
      */
      public Enumeration   getOldRCashSweepToRDept()
      {
         
         if (!getSession().getProperty("NoCacheRCashSweepToRDept").equals("true"))
         
         {
            if ( RCashSweepToRDeptCache != null ) return RCashSweepToRDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CASH_SW_SETP";
            param.fieldName = "PRTP_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRCashSweepToRDept").equals("true"))
         {
            RCashSweepToRDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_CASH_SW_SETPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RCashSweepToRDeptCache.put(pkey,cacheBO);                        
            }
         
            return (RCashSweepToRDeptCache.elements());
         }
         else
         {
         
            return (R_CASH_SW_SETPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_AP_CLM_ACCT objects for this R_DEPT
      * old R_AP_CLM_ACCT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_AP_CLM_ACCT objects.
      */
  public Enumeration getOldR_AP_CLM_ACCTs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_AP_CLM_ACCTs1");
    if (cache)
      getSession().setProperty("NoCacheR_AP_CLM_ACCTs1", "false");
    else
      getSession().setProperty("NoCacheR_AP_CLM_ACCTs1", "true");

    try {
      return getOldR_AP_CLM_ACCTs1();
    } finally {
        getSession().setProperty("NoCacheR_AP_CLM_ACCTs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_AP_CLM_ACCT objects for this R_DEPT
      * old R_AP_CLM_ACCT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_AP_CLM_ACCT objects.
      */
      public Enumeration   getOldR_AP_CLM_ACCTs1()
      {
         
         if (!getSession().getProperty("NoCacheR_AP_CLM_ACCTs1").equals("true"))
         
         {
            if ( R_AP_CLM_ACCTs1Cache != null ) return R_AP_CLM_ACCTs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_CLM_ACCT";
            param.fieldName = "CLM_DEPT";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_AP_CLM_ACCTs1").equals("true"))
         {
            R_AP_CLM_ACCTs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_AP_CLM_ACCTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_AP_CLM_ACCTs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_AP_CLM_ACCTs1Cache.elements());
         }
         else
         {
         
            return (R_AP_CLM_ACCTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_ALT_ORG_STRUCT objects for this R_DEPT
      * old R_ALT_ORG_STRUCT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_ALT_ORG_STRUCT objects.
      */
  public Enumeration getOldDeptToAltDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToAltDept");
    if (cache)
      getSession().setProperty("NoCacheDeptToAltDept", "false");
    else
      getSession().setProperty("NoCacheDeptToAltDept", "true");

    try {
      return getOldDeptToAltDept();
    } finally {
        getSession().setProperty("NoCacheDeptToAltDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_ALT_ORG_STRUCT objects for this R_DEPT
      * old R_ALT_ORG_STRUCT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_ALT_ORG_STRUCT objects.
      */
      public Enumeration   getOldDeptToAltDept()
      {
         
         if (!getSession().getProperty("NoCacheDeptToAltDept").equals("true"))
         
         {
            if ( DeptToAltDeptCache != null ) return DeptToAltDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ALT_ORG_STRUCT";
            param.fieldName = "ALT_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToAltDept").equals("true"))
         {
            DeptToAltDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_ALT_ORG_STRUCTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToAltDeptCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToAltDeptCache.elements());
         }
         else
         {
         
            return (R_ALT_ORG_STRUCTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old ONLN_PRN_BAT_PARM objects for this R_DEPT
      * old ONLN_PRN_BAT_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old ONLN_PRN_BAT_PARM objects.
      */
  public Enumeration getOldONLN_PRN_BAT_PARM1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheONLN_PRN_BAT_PARM1");
    if (cache)
      getSession().setProperty("NoCacheONLN_PRN_BAT_PARM1", "false");
    else
      getSession().setProperty("NoCacheONLN_PRN_BAT_PARM1", "true");

    try {
      return getOldONLN_PRN_BAT_PARM1();
    } finally {
        getSession().setProperty("NoCacheONLN_PRN_BAT_PARM1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old ONLN_PRN_BAT_PARM objects for this R_DEPT
      * old ONLN_PRN_BAT_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old ONLN_PRN_BAT_PARM objects.
      */
      public Enumeration   getOldONLN_PRN_BAT_PARM1()
      {
         
         if (!getSession().getProperty("NoCacheONLN_PRN_BAT_PARM1").equals("true"))
         
         {
            if ( ONLN_PRN_BAT_PARM1Cache != null ) return ONLN_PRN_BAT_PARM1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ONLN_PRN_BAT_PARM";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheONLN_PRN_BAT_PARM1").equals("true"))
         {
            ONLN_PRN_BAT_PARM1Cache = new ObjectHashtable();
            for (Enumeration e = (ONLN_PRN_BAT_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ONLN_PRN_BAT_PARM1Cache.put(pkey,cacheBO);                        
            }
         
            return (ONLN_PRN_BAT_PARM1Cache.elements());
         }
         else
         {
         
            return (ONLN_PRN_BAT_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_APPR objects for this R_DEPT
      * old INF_APPR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_APPR objects.
      */
  public Enumeration getOldINF_APPRs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheINF_APPRs1");
    if (cache)
      getSession().setProperty("NoCacheINF_APPRs1", "false");
    else
      getSession().setProperty("NoCacheINF_APPRs1", "true");

    try {
      return getOldINF_APPRs1();
    } finally {
        getSession().setProperty("NoCacheINF_APPRs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_APPR objects for this R_DEPT
      * old INF_APPR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_APPR objects.
      */
      public Enumeration   getOldINF_APPRs1()
      {
         
         if (!getSession().getProperty("NoCacheINF_APPRs1").equals("true"))
         
         {
            if ( INF_APPRs1Cache != null ) return INF_APPRs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_APPR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheINF_APPRs1").equals("true"))
         {
            INF_APPRs1Cache = new ObjectHashtable();
            for (Enumeration e = (INF_APPRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               INF_APPRs1Cache.put(pkey,cacheBO);                        
            }
         
            return (INF_APPRs1Cache.elements());
         }
         else
         {
         
            return (INF_APPRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old GT_DOC_RPTUSER objects for this R_DEPT
      * old GT_DOC_RPTUSER objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old GT_DOC_RPTUSER objects.
      */
  public Enumeration getOldRDeptToGtDocRptuser(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToGtDocRptuser");
    if (cache)
      getSession().setProperty("NoCacheRDeptToGtDocRptuser", "false");
    else
      getSession().setProperty("NoCacheRDeptToGtDocRptuser", "true");

    try {
      return getOldRDeptToGtDocRptuser();
    } finally {
        getSession().setProperty("NoCacheRDeptToGtDocRptuser", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old GT_DOC_RPTUSER objects for this R_DEPT
      * old GT_DOC_RPTUSER objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old GT_DOC_RPTUSER objects.
      */
      public Enumeration   getOldRDeptToGtDocRptuser()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToGtDocRptuser").equals("true"))
         
         {
            if ( RDeptToGtDocRptuserCache != null ) return RDeptToGtDocRptuserCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_RPTUSER";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToGtDocRptuser").equals("true"))
         {
            RDeptToGtDocRptuserCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_RPTUSERBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToGtDocRptuserCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToGtDocRptuserCache.elements());
         }
         else
         {
         
            return (GT_DOC_RPTUSERBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old DOC_HDR objects for this R_DEPT
      * old DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old DOC_HDR objects.
      */
  public Enumeration getOldDOC_HDRs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDOC_HDRs");
    if (cache)
      getSession().setProperty("NoCacheDOC_HDRs", "false");
    else
      getSession().setProperty("NoCacheDOC_HDRs", "true");

    try {
      return getOldDOC_HDRs();
    } finally {
        getSession().setProperty("NoCacheDOC_HDRs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old DOC_HDR objects for this R_DEPT
      * old DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old DOC_HDR objects.
      */
      public Enumeration   getOldDOC_HDRs()
      {
         
         if (!getSession().getProperty("NoCacheDOC_HDRs").equals("true"))
         
         {
            if ( DOC_HDRsCache != null ) return DOC_HDRsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "DOC_HDR";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDOC_HDRs").equals("true"))
         {
            DOC_HDRsCache = new ObjectHashtable();
            for (Enumeration e = (DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DOC_HDRsCache.put(pkey,cacheBO);                        
            }
         
            return (DOC_HDRsCache.elements());
         }
         else
         {
         
            return (DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old VCM_DOC_AUTHDEPT objects for this R_DEPT
      * old VCM_DOC_AUTHDEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old VCM_DOC_AUTHDEPT objects.
      */
  public Enumeration getOldVmAuthDeptDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheVmAuthDeptDept");
    if (cache)
      getSession().setProperty("NoCacheVmAuthDeptDept", "false");
    else
      getSession().setProperty("NoCacheVmAuthDeptDept", "true");

    try {
      return getOldVmAuthDeptDept();
    } finally {
        getSession().setProperty("NoCacheVmAuthDeptDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old VCM_DOC_AUTHDEPT objects for this R_DEPT
      * old VCM_DOC_AUTHDEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old VCM_DOC_AUTHDEPT objects.
      */
      public Enumeration   getOldVmAuthDeptDept()
      {
         
         if (!getSession().getProperty("NoCacheVmAuthDeptDept").equals("true"))
         
         {
            if ( VmAuthDeptDeptCache != null ) return VmAuthDeptDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "VCM_DOC_AUTHDEPT";
            param.fieldName = "NEW_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheVmAuthDeptDept").equals("true"))
         {
            VmAuthDeptDeptCache = new ObjectHashtable();
            for (Enumeration e = (VCM_DOC_AUTHDEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               VmAuthDeptDeptCache.put(pkey,cacheBO);                        
            }
         
            return (VmAuthDeptDeptCache.elements());
         }
         else
         {
         
            return (VCM_DOC_AUTHDEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PRVNT_SPND objects for this R_DEPT
      * old R_PRVNT_SPND objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PRVNT_SPND objects.
      */
  public Enumeration getOldR_PRVNT_SPNDs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_PRVNT_SPNDs");
    if (cache)
      getSession().setProperty("NoCacheR_PRVNT_SPNDs", "false");
    else
      getSession().setProperty("NoCacheR_PRVNT_SPNDs", "true");

    try {
      return getOldR_PRVNT_SPNDs();
    } finally {
        getSession().setProperty("NoCacheR_PRVNT_SPNDs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PRVNT_SPND objects for this R_DEPT
      * old R_PRVNT_SPND objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PRVNT_SPND objects.
      */
      public Enumeration   getOldR_PRVNT_SPNDs()
      {
         
         if (!getSession().getProperty("NoCacheR_PRVNT_SPNDs").equals("true"))
         
         {
            if ( R_PRVNT_SPNDsCache != null ) return R_PRVNT_SPNDsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PRVNT_SPND";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_PRVNT_SPNDs").equals("true"))
         {
            R_PRVNT_SPNDsCache = new ObjectHashtable();
            for (Enumeration e = (R_PRVNT_SPNDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_PRVNT_SPNDsCache.put(pkey,cacheBO);                        
            }
         
            return (R_PRVNT_SPNDsCache.elements());
         }
         else
         {
         
            return (R_PRVNT_SPNDBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PART_RF objects for this R_DEPT
      * old R_PART_RF objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PART_RF objects.
      */
  public Enumeration getOldDeptToPartRf(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToPartRf");
    if (cache)
      getSession().setProperty("NoCacheDeptToPartRf", "false");
    else
      getSession().setProperty("NoCacheDeptToPartRf", "true");

    try {
      return getOldDeptToPartRf();
    } finally {
        getSession().setProperty("NoCacheDeptToPartRf", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PART_RF objects for this R_DEPT
      * old R_PART_RF objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PART_RF objects.
      */
      public Enumeration   getOldDeptToPartRf()
      {
         
         if (!getSession().getProperty("NoCacheDeptToPartRf").equals("true"))
         
         {
            if ( DeptToPartRfCache != null ) return DeptToPartRfCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PART_RF";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToPartRf").equals("true"))
         {
            DeptToPartRfCache = new ObjectHashtable();
            for (Enumeration e = (R_PART_RFBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToPartRfCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToPartRfCache.elements());
         }
         else
         {
         
            return (R_PART_RFBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_GRNTR_RPT objects for this R_DEPT
      * old R_GRNTR_RPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_GRNTR_RPT objects.
      */
  public Enumeration getOldRDeptToRGrntrRpt(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRGrntrRpt");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRGrntrRpt", "false");
    else
      getSession().setProperty("NoCacheRDeptToRGrntrRpt", "true");

    try {
      return getOldRDeptToRGrntrRpt();
    } finally {
        getSession().setProperty("NoCacheRDeptToRGrntrRpt", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_GRNTR_RPT objects for this R_DEPT
      * old R_GRNTR_RPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_GRNTR_RPT objects.
      */
      public Enumeration   getOldRDeptToRGrntrRpt()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntrRpt").equals("true"))
         
         {
            if ( RDeptToRGrntrRptCache != null ) return RDeptToRGrntrRptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNTR_RPT";
            param.fieldName = "APPL_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntrRpt").equals("true"))
         {
            RDeptToRGrntrRptCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNTR_RPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntrRptCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntrRptCache.elements());
         }
         else
         {
         
            return (R_GRNTR_RPTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DEBT_AUTH objects for this R_DEPT
      * old R_DEBT_AUTH objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DEBT_AUTH objects.
      */
  public Enumeration getOldDeptToDebtAuth(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToDebtAuth");
    if (cache)
      getSession().setProperty("NoCacheDeptToDebtAuth", "false");
    else
      getSession().setProperty("NoCacheDeptToDebtAuth", "true");

    try {
      return getOldDeptToDebtAuth();
    } finally {
        getSession().setProperty("NoCacheDeptToDebtAuth", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DEBT_AUTH objects for this R_DEPT
      * old R_DEBT_AUTH objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DEBT_AUTH objects.
      */
      public Enumeration   getOldDeptToDebtAuth()
      {
         
         if (!getSession().getProperty("NoCacheDeptToDebtAuth").equals("true"))
         
         {
            if ( DeptToDebtAuthCache != null ) return DeptToDebtAuthCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DEBT_AUTH";
            param.fieldName = "RESP_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDebtAuth").equals("true"))
         {
            DeptToDebtAuthCache = new ObjectHashtable();
            for (Enumeration e = (R_DEBT_AUTHBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDebtAuthCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDebtAuthCache.elements());
         }
         else
         {
         
            return (R_DEBT_AUTHBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_CSAL_SRCTR_SETP objects for this R_DEPT
      * old R_CSAL_SRCTR_SETP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_CSAL_SRCTR_SETP objects.
      */
  public Enumeration getOldRdeptToRcsalSrctrSetp(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRdeptToRcsalSrctrSetp");
    if (cache)
      getSession().setProperty("NoCacheRdeptToRcsalSrctrSetp", "false");
    else
      getSession().setProperty("NoCacheRdeptToRcsalSrctrSetp", "true");

    try {
      return getOldRdeptToRcsalSrctrSetp();
    } finally {
        getSession().setProperty("NoCacheRdeptToRcsalSrctrSetp", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_CSAL_SRCTR_SETP objects for this R_DEPT
      * old R_CSAL_SRCTR_SETP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_CSAL_SRCTR_SETP objects.
      */
      public Enumeration   getOldRdeptToRcsalSrctrSetp()
      {
         
         if (!getSession().getProperty("NoCacheRdeptToRcsalSrctrSetp").equals("true"))
         
         {
            if ( RdeptToRcsalSrctrSetpCache != null ) return RdeptToRcsalSrctrSetpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CSAL_SRCTR_SETP";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToRcsalSrctrSetp").equals("true"))
         {
            RdeptToRcsalSrctrSetpCache = new ObjectHashtable();
            for (Enumeration e = (R_CSAL_SRCTR_SETPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToRcsalSrctrSetpCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToRcsalSrctrSetpCache.elements());
         }
         else
         {
         
            return (R_CSAL_SRCTR_SETPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_AP_UPROC_PRCU_AL objects for this R_DEPT
      * old R_AP_UPROC_PRCU_AL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_AP_UPROC_PRCU_AL objects.
      */
  public Enumeration getOldRDeptToRApUprocPrcuAl(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRApUprocPrcuAl");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRApUprocPrcuAl", "false");
    else
      getSession().setProperty("NoCacheRDeptToRApUprocPrcuAl", "true");

    try {
      return getOldRDeptToRApUprocPrcuAl();
    } finally {
        getSession().setProperty("NoCacheRDeptToRApUprocPrcuAl", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_AP_UPROC_PRCU_AL objects for this R_DEPT
      * old R_AP_UPROC_PRCU_AL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_AP_UPROC_PRCU_AL objects.
      */
      public Enumeration   getOldRDeptToRApUprocPrcuAl()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRApUprocPrcuAl").equals("true"))
         
         {
            if ( RDeptToRApUprocPrcuAlCache != null ) return RDeptToRApUprocPrcuAlCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_UPROC_PRCU_AL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRApUprocPrcuAl").equals("true"))
         {
            RDeptToRApUprocPrcuAlCache = new ObjectHashtable();
            for (Enumeration e = (R_AP_UPROC_PRCU_ALBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRApUprocPrcuAlCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRApUprocPrcuAlCache.elements());
         }
         else
         {
         
            return (R_AP_UPROC_PRCU_ALBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_AP_CW_CHK_NO objects for this R_DEPT
      * old R_AP_CW_CHK_NO objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_AP_CW_CHK_NO objects.
      */
  public Enumeration getOldDeptToApCwChk(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToApCwChk");
    if (cache)
      getSession().setProperty("NoCacheDeptToApCwChk", "false");
    else
      getSession().setProperty("NoCacheDeptToApCwChk", "true");

    try {
      return getOldDeptToApCwChk();
    } finally {
        getSession().setProperty("NoCacheDeptToApCwChk", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_AP_CW_CHK_NO objects for this R_DEPT
      * old R_AP_CW_CHK_NO objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_AP_CW_CHK_NO objects.
      */
      public Enumeration   getOldDeptToApCwChk()
      {
         
         if (!getSession().getProperty("NoCacheDeptToApCwChk").equals("true"))
         
         {
            if ( DeptToApCwChkCache != null ) return DeptToApCwChkCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_CW_CHK_NO";
            param.fieldName = "CW_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToApCwChk").equals("true"))
         {
            DeptToApCwChkCache = new ObjectHashtable();
            for (Enumeration e = (R_AP_CW_CHK_NOBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToApCwChkCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToApCwChkCache.elements());
         }
         else
         {
         
            return (R_AP_CW_CHK_NOBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_ADC_PARM objects for this R_DEPT
      * old R_ADC_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_ADC_PARM objects.
      */
  public Enumeration getOldRDept1ToRAdcParm1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDept1ToRAdcParm1");
    if (cache)
      getSession().setProperty("NoCacheRDept1ToRAdcParm1", "false");
    else
      getSession().setProperty("NoCacheRDept1ToRAdcParm1", "true");

    try {
      return getOldRDept1ToRAdcParm1();
    } finally {
        getSession().setProperty("NoCacheRDept1ToRAdcParm1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_ADC_PARM objects for this R_DEPT
      * old R_ADC_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_ADC_PARM objects.
      */
      public Enumeration   getOldRDept1ToRAdcParm1()
      {
         
         if (!getSession().getProperty("NoCacheRDept1ToRAdcParm1").equals("true"))
         
         {
            if ( RDept1ToRAdcParm1Cache != null ) return RDept1ToRAdcParm1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ADC_PARM";
            param.fieldName = "SRC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDept1ToRAdcParm1").equals("true"))
         {
            RDept1ToRAdcParm1Cache = new ObjectHashtable();
            for (Enumeration e = (R_ADC_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDept1ToRAdcParm1Cache.put(pkey,cacheBO);                        
            }
         
            return (RDept1ToRAdcParm1Cache.elements());
         }
         else
         {
         
            return (R_ADC_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old MD_DOC_HDR objects for this R_DEPT
      * old MD_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old MD_DOC_HDR objects.
      */
  public Enumeration getOldDeptToMDHdr(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToMDHdr");
    if (cache)
      getSession().setProperty("NoCacheDeptToMDHdr", "false");
    else
      getSession().setProperty("NoCacheDeptToMDHdr", "true");

    try {
      return getOldDeptToMDHdr();
    } finally {
        getSession().setProperty("NoCacheDeptToMDHdr", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old MD_DOC_HDR objects for this R_DEPT
      * old MD_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old MD_DOC_HDR objects.
      */
      public Enumeration   getOldDeptToMDHdr()
      {
         
         if (!getSession().getProperty("NoCacheDeptToMDHdr").equals("true"))
         
         {
            if ( DeptToMDHdrCache != null ) return DeptToMDHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "MD_DOC_HDR";
            param.fieldName = "PY_HLD_TYP_DEPT_DC";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToMDHdr").equals("true"))
         {
            DeptToMDHdrCache = new ObjectHashtable();
            for (Enumeration e = (MD_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToMDHdrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToMDHdrCache.elements());
         }
         else
         {
         
            return (MD_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old CAM_PROC_PARM objects for this R_DEPT
      * old CAM_PROC_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old CAM_PROC_PARM objects.
      */
  public Enumeration getOldDeptToCamProcParm(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToCamProcParm");
    if (cache)
      getSession().setProperty("NoCacheDeptToCamProcParm", "false");
    else
      getSession().setProperty("NoCacheDeptToCamProcParm", "true");

    try {
      return getOldDeptToCamProcParm();
    } finally {
        getSession().setProperty("NoCacheDeptToCamProcParm", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old CAM_PROC_PARM objects for this R_DEPT
      * old CAM_PROC_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old CAM_PROC_PARM objects.
      */
      public Enumeration   getOldDeptToCamProcParm()
      {
         
         if (!getSession().getProperty("NoCacheDeptToCamProcParm").equals("true"))
         
         {
            if ( DeptToCamProcParmCache != null ) return DeptToCamProcParmCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "CAM_PROC_PARM";
            param.fieldName = "JV_DOC_DEPT";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCamProcParm").equals("true"))
         {
            DeptToCamProcParmCache = new ObjectHashtable();
            for (Enumeration e = (CAM_PROC_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCamProcParmCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCamProcParmCache.elements());
         }
         else
         {
         
            return (CAM_PROC_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_STAT_UNIT_SETP objects for this R_DEPT
      * old R_STAT_UNIT_SETP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_STAT_UNIT_SETP objects.
      */
  public Enumeration getOldRdeptToRstatUnitSetp(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRdeptToRstatUnitSetp");
    if (cache)
      getSession().setProperty("NoCacheRdeptToRstatUnitSetp", "false");
    else
      getSession().setProperty("NoCacheRdeptToRstatUnitSetp", "true");

    try {
      return getOldRdeptToRstatUnitSetp();
    } finally {
        getSession().setProperty("NoCacheRdeptToRstatUnitSetp", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_STAT_UNIT_SETP objects for this R_DEPT
      * old R_STAT_UNIT_SETP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_STAT_UNIT_SETP objects.
      */
      public Enumeration   getOldRdeptToRstatUnitSetp()
      {
         
         if (!getSession().getProperty("NoCacheRdeptToRstatUnitSetp").equals("true"))
         
         {
            if ( RdeptToRstatUnitSetpCache != null ) return RdeptToRstatUnitSetpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_STAT_UNIT_SETP";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToRstatUnitSetp").equals("true"))
         {
            RdeptToRstatUnitSetpCache = new ObjectHashtable();
            for (Enumeration e = (R_STAT_UNIT_SETPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToRstatUnitSetpCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToRstatUnitSetpCache.elements());
         }
         else
         {
         
            return (R_STAT_UNIT_SETPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PROG_STA objects for this R_DEPT
      * old R_PROG_STA objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PROG_STA objects.
      */
  public Enumeration getOldDeptToProgSta(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToProgSta");
    if (cache)
      getSession().setProperty("NoCacheDeptToProgSta", "false");
    else
      getSession().setProperty("NoCacheDeptToProgSta", "true");

    try {
      return getOldDeptToProgSta();
    } finally {
        getSession().setProperty("NoCacheDeptToProgSta", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PROG_STA objects for this R_DEPT
      * old R_PROG_STA objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PROG_STA objects.
      */
      public Enumeration   getOldDeptToProgSta()
      {
         
         if (!getSession().getProperty("NoCacheDeptToProgSta").equals("true"))
         
         {
            if ( DeptToProgStaCache != null ) return DeptToProgStaCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PROG_STA";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToProgSta").equals("true"))
         {
            DeptToProgStaCache = new ObjectHashtable();
            for (Enumeration e = (R_PROG_STABaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToProgStaCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToProgStaCache.elements());
         }
         else
         {
         
            return (R_PROG_STABaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PROG objects for this R_DEPT
      * old R_PROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PROG objects.
      */
  public Enumeration getOldR_PROGs2(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_PROGs2");
    if (cache)
      getSession().setProperty("NoCacheR_PROGs2", "false");
    else
      getSession().setProperty("NoCacheR_PROGs2", "true");

    try {
      return getOldR_PROGs2();
    } finally {
        getSession().setProperty("NoCacheR_PROGs2", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PROG objects for this R_DEPT
      * old R_PROG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PROG objects.
      */
      public Enumeration   getOldR_PROGs2()
      {
         
         if (!getSession().getProperty("NoCacheR_PROGs2").equals("true"))
         
         {
            if ( R_PROGs2Cache != null ) return R_PROGs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PROG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_PROGs2").equals("true"))
         {
            R_PROGs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_PROGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_PROGs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_PROGs2Cache.elements());
         }
         else
         {
         
            return (R_PROGBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_ONGOING_AWD_INFO objects for this R_DEPT
      * old R_ONGOING_AWD_INFO objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_ONGOING_AWD_INFO objects.
      */
  public Enumeration getOldDeptToOnGoingAwardInfo(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToOnGoingAwardInfo");
    if (cache)
      getSession().setProperty("NoCacheDeptToOnGoingAwardInfo", "false");
    else
      getSession().setProperty("NoCacheDeptToOnGoingAwardInfo", "true");

    try {
      return getOldDeptToOnGoingAwardInfo();
    } finally {
        getSession().setProperty("NoCacheDeptToOnGoingAwardInfo", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_ONGOING_AWD_INFO objects for this R_DEPT
      * old R_ONGOING_AWD_INFO objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_ONGOING_AWD_INFO objects.
      */
      public Enumeration   getOldDeptToOnGoingAwardInfo()
      {
         
         if (!getSession().getProperty("NoCacheDeptToOnGoingAwardInfo").equals("true"))
         
         {
            if ( DeptToOnGoingAwardInfoCache != null ) return DeptToOnGoingAwardInfoCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ONGOING_AWD_INFO";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToOnGoingAwardInfo").equals("true"))
         {
            DeptToOnGoingAwardInfoCache = new ObjectHashtable();
            for (Enumeration e = (R_ONGOING_AWD_INFOBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToOnGoingAwardInfoCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToOnGoingAwardInfoCache.elements());
         }
         else
         {
         
            return (R_ONGOING_AWD_INFOBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_NEG_DRW_EXCP_DTL objects for this R_DEPT
      * old R_NEG_DRW_EXCP_DTL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_NEG_DRW_EXCP_DTL objects.
      */
  public Enumeration getOldNegDrawExcpDtlRecs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheNegDrawExcpDtlRecs");
    if (cache)
      getSession().setProperty("NoCacheNegDrawExcpDtlRecs", "false");
    else
      getSession().setProperty("NoCacheNegDrawExcpDtlRecs", "true");

    try {
      return getOldNegDrawExcpDtlRecs();
    } finally {
        getSession().setProperty("NoCacheNegDrawExcpDtlRecs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_NEG_DRW_EXCP_DTL objects for this R_DEPT
      * old R_NEG_DRW_EXCP_DTL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_NEG_DRW_EXCP_DTL objects.
      */
      public Enumeration   getOldNegDrawExcpDtlRecs()
      {
         
         if (!getSession().getProperty("NoCacheNegDrawExcpDtlRecs").equals("true"))
         
         {
            if ( NegDrawExcpDtlRecsCache != null ) return NegDrawExcpDtlRecsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_NEG_DRW_EXCP_DTL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheNegDrawExcpDtlRecs").equals("true"))
         {
            NegDrawExcpDtlRecsCache = new ObjectHashtable();
            for (Enumeration e = (R_NEG_DRW_EXCP_DTLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               NegDrawExcpDtlRecsCache.put(pkey,cacheBO);                        
            }
         
            return (NegDrawExcpDtlRecsCache.elements());
         }
         else
         {
         
            return (R_NEG_DRW_EXCP_DTLBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_LCLS objects for this R_DEPT
      * old R_LCLS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_LCLS objects.
      */
  public Enumeration getOldR_LCLSs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_LCLSs1");
    if (cache)
      getSession().setProperty("NoCacheR_LCLSs1", "false");
    else
      getSession().setProperty("NoCacheR_LCLSs1", "true");

    try {
      return getOldR_LCLSs1();
    } finally {
        getSession().setProperty("NoCacheR_LCLSs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_LCLS objects for this R_DEPT
      * old R_LCLS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_LCLS objects.
      */
      public Enumeration   getOldR_LCLSs1()
      {
         
         if (!getSession().getProperty("NoCacheR_LCLSs1").equals("true"))
         
         {
            if ( R_LCLSs1Cache != null ) return R_LCLSs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_LCLS";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_LCLSs1").equals("true"))
         {
            R_LCLSs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_LCLSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_LCLSs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_LCLSs1Cache.elements());
         }
         else
         {
         
            return (R_LCLSBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_GRNT_NOTIFUSR objects for this R_DEPT
      * old R_GRNT_NOTIFUSR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_GRNT_NOTIFUSR objects.
      */
  public Enumeration getOldDeptToGrntNotifUsr(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToGrntNotifUsr");
    if (cache)
      getSession().setProperty("NoCacheDeptToGrntNotifUsr", "false");
    else
      getSession().setProperty("NoCacheDeptToGrntNotifUsr", "true");

    try {
      return getOldDeptToGrntNotifUsr();
    } finally {
        getSession().setProperty("NoCacheDeptToGrntNotifUsr", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_GRNT_NOTIFUSR objects for this R_DEPT
      * old R_GRNT_NOTIFUSR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_GRNT_NOTIFUSR objects.
      */
      public Enumeration   getOldDeptToGrntNotifUsr()
      {
         
         if (!getSession().getProperty("NoCacheDeptToGrntNotifUsr").equals("true"))
         
         {
            if ( DeptToGrntNotifUsrCache != null ) return DeptToGrntNotifUsrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_NOTIFUSR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGrntNotifUsr").equals("true"))
         {
            DeptToGrntNotifUsrCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_NOTIFUSRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGrntNotifUsrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGrntNotifUsrCache.elements());
         }
         else
         {
         
            return (R_GRNT_NOTIFUSRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_ADC_PARM objects for this R_DEPT
      * old R_ADC_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_ADC_PARM objects.
      */
  public Enumeration getOldRDept2ToRAdcParm2(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDept2ToRAdcParm2");
    if (cache)
      getSession().setProperty("NoCacheRDept2ToRAdcParm2", "false");
    else
      getSession().setProperty("NoCacheRDept2ToRAdcParm2", "true");

    try {
      return getOldRDept2ToRAdcParm2();
    } finally {
        getSession().setProperty("NoCacheRDept2ToRAdcParm2", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_ADC_PARM objects for this R_DEPT
      * old R_ADC_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_ADC_PARM objects.
      */
      public Enumeration   getOldRDept2ToRAdcParm2()
      {
         
         if (!getSession().getProperty("NoCacheRDept2ToRAdcParm2").equals("true"))
         
         {
            if ( RDept2ToRAdcParm2Cache != null ) return RDept2ToRAdcParm2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ADC_PARM";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDept2ToRAdcParm2").equals("true"))
         {
            RDept2ToRAdcParm2Cache = new ObjectHashtable();
            for (Enumeration e = (R_ADC_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDept2ToRAdcParm2Cache.put(pkey,cacheBO);                        
            }
         
            return (RDept2ToRAdcParm2Cache.elements());
         }
         else
         {
         
            return (R_ADC_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_ACAT objects for this R_DEPT
      * old R_ACAT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_ACAT objects.
      */
  public Enumeration getOldR_ACATs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_ACATs1");
    if (cache)
      getSession().setProperty("NoCacheR_ACATs1", "false");
    else
      getSession().setProperty("NoCacheR_ACATs1", "true");

    try {
      return getOldR_ACATs1();
    } finally {
        getSession().setProperty("NoCacheR_ACATs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_ACAT objects for this R_DEPT
      * old R_ACAT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_ACAT objects.
      */
      public Enumeration   getOldR_ACATs1()
      {
         
         if (!getSession().getProperty("NoCacheR_ACATs1").equals("true"))
         
         {
            if ( R_ACATs1Cache != null ) return R_ACATs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ACAT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_ACATs1").equals("true"))
         {
            R_ACATs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_ACATBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_ACATs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_ACATs1Cache.elements());
         }
         else
         {
         
            return (R_ACATBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old LIC_RNEW_DT_STRG objects for this R_DEPT
      * old LIC_RNEW_DT_STRG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old LIC_RNEW_DT_STRG objects.
      */
  public Enumeration getOldLrdsToDept1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheLrdsToDept1");
    if (cache)
      getSession().setProperty("NoCacheLrdsToDept1", "false");
    else
      getSession().setProperty("NoCacheLrdsToDept1", "true");

    try {
      return getOldLrdsToDept1();
    } finally {
        getSession().setProperty("NoCacheLrdsToDept1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old LIC_RNEW_DT_STRG objects for this R_DEPT
      * old LIC_RNEW_DT_STRG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old LIC_RNEW_DT_STRG objects.
      */
      public Enumeration   getOldLrdsToDept1()
      {
         
         if (!getSession().getProperty("NoCacheLrdsToDept1").equals("true"))
         
         {
            if ( LrdsToDept1Cache != null ) return LrdsToDept1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "LIC_RNEW_DT_STRG";
            param.fieldName = "REMT_DEPT";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheLrdsToDept1").equals("true"))
         {
            LrdsToDept1Cache = new ObjectHashtable();
            for (Enumeration e = (LIC_RNEW_DT_STRGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               LrdsToDept1Cache.put(pkey,cacheBO);                        
            }
         
            return (LrdsToDept1Cache.elements());
         }
         else
         {
         
            return (LIC_RNEW_DT_STRGBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old LIC_RNEW_DT_STRG objects for this R_DEPT
      * old LIC_RNEW_DT_STRG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old LIC_RNEW_DT_STRG objects.
      */
  public Enumeration getOldLrdsToDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheLrdsToDept");
    if (cache)
      getSession().setProperty("NoCacheLrdsToDept", "false");
    else
      getSession().setProperty("NoCacheLrdsToDept", "true");

    try {
      return getOldLrdsToDept();
    } finally {
        getSession().setProperty("NoCacheLrdsToDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old LIC_RNEW_DT_STRG objects for this R_DEPT
      * old LIC_RNEW_DT_STRG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old LIC_RNEW_DT_STRG objects.
      */
      public Enumeration   getOldLrdsToDept()
      {
         
         if (!getSession().getProperty("NoCacheLrdsToDept").equals("true"))
         
         {
            if ( LrdsToDeptCache != null ) return LrdsToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "LIC_RNEW_DT_STRG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheLrdsToDept").equals("true"))
         {
            LrdsToDeptCache = new ObjectHashtable();
            for (Enumeration e = (LIC_RNEW_DT_STRGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               LrdsToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (LrdsToDeptCache.elements());
         }
         else
         {
         
            return (LIC_RNEW_DT_STRGBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old ARRA_DOC_SRCPQTR objects for this R_DEPT
      * old ARRA_DOC_SRCPQTR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old ARRA_DOC_SRCPQTR objects.
      */
  public Enumeration getOldDeptToARRADocSRcpQtr(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToARRADocSRcpQtr");
    if (cache)
      getSession().setProperty("NoCacheDeptToARRADocSRcpQtr", "false");
    else
      getSession().setProperty("NoCacheDeptToARRADocSRcpQtr", "true");

    try {
      return getOldDeptToARRADocSRcpQtr();
    } finally {
        getSession().setProperty("NoCacheDeptToARRADocSRcpQtr", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old ARRA_DOC_SRCPQTR objects for this R_DEPT
      * old ARRA_DOC_SRCPQTR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old ARRA_DOC_SRCPQTR objects.
      */
      public Enumeration   getOldDeptToARRADocSRcpQtr()
      {
         
         if (!getSession().getProperty("NoCacheDeptToARRADocSRcpQtr").equals("true"))
         
         {
            if ( DeptToARRADocSRcpQtrCache != null ) return DeptToARRADocSRcpQtrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ARRA_DOC_SRCPQTR";
            param.fieldName = "AWD_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToARRADocSRcpQtr").equals("true"))
         {
            DeptToARRADocSRcpQtrCache = new ObjectHashtable();
            for (Enumeration e = (ARRA_DOC_SRCPQTRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToARRADocSRcpQtrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToARRADocSRcpQtrCache.elements());
         }
         else
         {
         
            return (ARRA_DOC_SRCPQTRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old ACRL_CLR_MGMT objects for this R_DEPT
      * old ACRL_CLR_MGMT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old ACRL_CLR_MGMT objects.
      */
  public Enumeration getOldACRL_CLR_MGMT_2(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheACRL_CLR_MGMT_2");
    if (cache)
      getSession().setProperty("NoCacheACRL_CLR_MGMT_2", "false");
    else
      getSession().setProperty("NoCacheACRL_CLR_MGMT_2", "true");

    try {
      return getOldACRL_CLR_MGMT_2();
    } finally {
        getSession().setProperty("NoCacheACRL_CLR_MGMT_2", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old ACRL_CLR_MGMT objects for this R_DEPT
      * old ACRL_CLR_MGMT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old ACRL_CLR_MGMT objects.
      */
      public Enumeration   getOldACRL_CLR_MGMT_2()
      {
         
         if (!getSession().getProperty("NoCacheACRL_CLR_MGMT_2").equals("true"))
         
         {
            if ( ACRL_CLR_MGMT_2Cache != null ) return ACRL_CLR_MGMT_2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ACRL_CLR_MGMT";
            param.fieldName = "RFED_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheACRL_CLR_MGMT_2").equals("true"))
         {
            ACRL_CLR_MGMT_2Cache = new ObjectHashtable();
            for (Enumeration e = (ACRL_CLR_MGMTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ACRL_CLR_MGMT_2Cache.put(pkey,cacheBO);                        
            }
         
            return (ACRL_CLR_MGMT_2Cache.elements());
         }
         else
         {
         
            return (ACRL_CLR_MGMTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old TRVL_COA_OVRD objects for this R_DEPT
      * old TRVL_COA_OVRD objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old TRVL_COA_OVRD objects.
      */
  public Enumeration getOldTRVLCoaOVrdToRDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheTRVLCoaOVrdToRDept");
    if (cache)
      getSession().setProperty("NoCacheTRVLCoaOVrdToRDept", "false");
    else
      getSession().setProperty("NoCacheTRVLCoaOVrdToRDept", "true");

    try {
      return getOldTRVLCoaOVrdToRDept();
    } finally {
        getSession().setProperty("NoCacheTRVLCoaOVrdToRDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old TRVL_COA_OVRD objects for this R_DEPT
      * old TRVL_COA_OVRD objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old TRVL_COA_OVRD objects.
      */
      public Enumeration   getOldTRVLCoaOVrdToRDept()
      {
         
         if (!getSession().getProperty("NoCacheTRVLCoaOVrdToRDept").equals("true"))
         
         {
            if ( TRVLCoaOVrdToRDeptCache != null ) return TRVLCoaOVrdToRDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "TRVL_COA_OVRD";
            param.fieldName = "HOME_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheTRVLCoaOVrdToRDept").equals("true"))
         {
            TRVLCoaOVrdToRDeptCache = new ObjectHashtable();
            for (Enumeration e = (TRVL_COA_OVRDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               TRVLCoaOVrdToRDeptCache.put(pkey,cacheBO);                        
            }
         
            return (TRVLCoaOVrdToRDeptCache.elements());
         }
         else
         {
         
            return (TRVL_COA_OVRDBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_SRC_OF_FUND objects for this R_DEPT
      * old R_SRC_OF_FUND objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_SRC_OF_FUND objects.
      */
  public Enumeration getOldDeptToSrcOfFund(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToSrcOfFund");
    if (cache)
      getSession().setProperty("NoCacheDeptToSrcOfFund", "false");
    else
      getSession().setProperty("NoCacheDeptToSrcOfFund", "true");

    try {
      return getOldDeptToSrcOfFund();
    } finally {
        getSession().setProperty("NoCacheDeptToSrcOfFund", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_SRC_OF_FUND objects for this R_DEPT
      * old R_SRC_OF_FUND objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_SRC_OF_FUND objects.
      */
      public Enumeration   getOldDeptToSrcOfFund()
      {
         
         if (!getSession().getProperty("NoCacheDeptToSrcOfFund").equals("true"))
         
         {
            if ( DeptToSrcOfFundCache != null ) return DeptToSrcOfFundCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_SRC_OF_FUND";
            param.fieldName = "GRNT_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToSrcOfFund").equals("true"))
         {
            DeptToSrcOfFundCache = new ObjectHashtable();
            for (Enumeration e = (R_SRC_OF_FUNDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToSrcOfFundCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToSrcOfFundCache.elements());
         }
         else
         {
         
            return (R_SRC_OF_FUNDBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_REIM_GEN_PARAM objects for this R_DEPT
      * old R_REIM_GEN_PARAM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_REIM_GEN_PARAM objects.
      */
  public Enumeration getOldR_REIM_GEN_PARAM(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_REIM_GEN_PARAM");
    if (cache)
      getSession().setProperty("NoCacheR_REIM_GEN_PARAM", "false");
    else
      getSession().setProperty("NoCacheR_REIM_GEN_PARAM", "true");

    try {
      return getOldR_REIM_GEN_PARAM();
    } finally {
        getSession().setProperty("NoCacheR_REIM_GEN_PARAM", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_REIM_GEN_PARAM objects for this R_DEPT
      * old R_REIM_GEN_PARAM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_REIM_GEN_PARAM objects.
      */
      public Enumeration   getOldR_REIM_GEN_PARAM()
      {
         
         if (!getSession().getProperty("NoCacheR_REIM_GEN_PARAM").equals("true"))
         
         {
            if ( R_REIM_GEN_PARAMCache != null ) return R_REIM_GEN_PARAMCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_REIM_GEN_PARAM";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_REIM_GEN_PARAM").equals("true"))
         {
            R_REIM_GEN_PARAMCache = new ObjectHashtable();
            for (Enumeration e = (R_REIM_GEN_PARAMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_REIM_GEN_PARAMCache.put(pkey,cacheBO);                        
            }
         
            return (R_REIM_GEN_PARAMCache.elements());
         }
         else
         {
         
            return (R_REIM_GEN_PARAMBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_REIM_EXP_ADJ objects for this R_DEPT
      * old R_REIM_EXP_ADJ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_REIM_EXP_ADJ objects.
      */
  public Enumeration getOldDocDeptToReimExpAdj(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDocDeptToReimExpAdj");
    if (cache)
      getSession().setProperty("NoCacheDocDeptToReimExpAdj", "false");
    else
      getSession().setProperty("NoCacheDocDeptToReimExpAdj", "true");

    try {
      return getOldDocDeptToReimExpAdj();
    } finally {
        getSession().setProperty("NoCacheDocDeptToReimExpAdj", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_REIM_EXP_ADJ objects for this R_DEPT
      * old R_REIM_EXP_ADJ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_REIM_EXP_ADJ objects.
      */
      public Enumeration   getOldDocDeptToReimExpAdj()
      {
         
         if (!getSession().getProperty("NoCacheDocDeptToReimExpAdj").equals("true"))
         
         {
            if ( DocDeptToReimExpAdjCache != null ) return DocDeptToReimExpAdjCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_REIM_EXP_ADJ";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDocDeptToReimExpAdj").equals("true"))
         {
            DocDeptToReimExpAdjCache = new ObjectHashtable();
            for (Enumeration e = (R_REIM_EXP_ADJBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DocDeptToReimExpAdjCache.put(pkey,cacheBO);                        
            }
         
            return (DocDeptToReimExpAdjCache.elements());
         }
         else
         {
         
            return (R_REIM_EXP_ADJBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FA_INTN_EXCEPT objects for this R_DEPT
      * old R_FA_INTN_EXCEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FA_INTN_EXCEPT objects.
      */
  public Enumeration getOldRFAIntnExcepToRDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRFAIntnExcepToRDept");
    if (cache)
      getSession().setProperty("NoCacheRFAIntnExcepToRDept", "false");
    else
      getSession().setProperty("NoCacheRFAIntnExcepToRDept", "true");

    try {
      return getOldRFAIntnExcepToRDept();
    } finally {
        getSession().setProperty("NoCacheRFAIntnExcepToRDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FA_INTN_EXCEPT objects for this R_DEPT
      * old R_FA_INTN_EXCEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FA_INTN_EXCEPT objects.
      */
      public Enumeration   getOldRFAIntnExcepToRDept()
      {
         
         if (!getSession().getProperty("NoCacheRFAIntnExcepToRDept").equals("true"))
         
         {
            if ( RFAIntnExcepToRDeptCache != null ) return RFAIntnExcepToRDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FA_INTN_EXCEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRFAIntnExcepToRDept").equals("true"))
         {
            RFAIntnExcepToRDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_FA_INTN_EXCEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RFAIntnExcepToRDeptCache.put(pkey,cacheBO);                        
            }
         
            return (RFAIntnExcepToRDeptCache.elements());
         }
         else
         {
         
            return (R_FA_INTN_EXCEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DEBT_HIST objects for this R_DEPT
      * old R_DEBT_HIST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DEBT_HIST objects.
      */
  public Enumeration getOldDeptToDebtHist1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToDebtHist1");
    if (cache)
      getSession().setProperty("NoCacheDeptToDebtHist1", "false");
    else
      getSession().setProperty("NoCacheDeptToDebtHist1", "true");

    try {
      return getOldDeptToDebtHist1();
    } finally {
        getSession().setProperty("NoCacheDeptToDebtHist1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DEBT_HIST objects for this R_DEPT
      * old R_DEBT_HIST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DEBT_HIST objects.
      */
      public Enumeration   getOldDeptToDebtHist1()
      {
         
         if (!getSession().getProperty("NoCacheDeptToDebtHist1").equals("true"))
         
         {
            if ( DeptToDebtHist1Cache != null ) return DeptToDebtHist1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DEBT_HIST";
            param.fieldName = "RESP_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDebtHist1").equals("true"))
         {
            DeptToDebtHist1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DEBT_HISTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDebtHist1Cache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDebtHist1Cache.elements());
         }
         else
         {
         
            return (R_DEBT_HISTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_CORSPD objects for this R_DEPT
      * old R_CORSPD objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_CORSPD objects.
      */
  public Enumeration getOldR_CORSPDs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_CORSPDs1");
    if (cache)
      getSession().setProperty("NoCacheR_CORSPDs1", "false");
    else
      getSession().setProperty("NoCacheR_CORSPDs1", "true");

    try {
      return getOldR_CORSPDs1();
    } finally {
        getSession().setProperty("NoCacheR_CORSPDs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_CORSPD objects for this R_DEPT
      * old R_CORSPD objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_CORSPD objects.
      */
      public Enumeration   getOldR_CORSPDs1()
      {
         
         if (!getSession().getProperty("NoCacheR_CORSPDs1").equals("true"))
         
         {
            if ( R_CORSPDs1Cache != null ) return R_CORSPDs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CORSPD";
            param.fieldName = "SPFC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_CORSPDs1").equals("true"))
         {
            R_CORSPDs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_CORSPDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_CORSPDs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_CORSPDs1Cache.elements());
         }
         else
         {
         
            return (R_CORSPDBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_AP_CWCAN_PARM objects for this R_DEPT
      * old R_AP_CWCAN_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_AP_CWCAN_PARM objects.
      */
  public Enumeration getOldDeptToCWCanParm(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToCWCanParm");
    if (cache)
      getSession().setProperty("NoCacheDeptToCWCanParm", "false");
    else
      getSession().setProperty("NoCacheDeptToCWCanParm", "true");

    try {
      return getOldDeptToCWCanParm();
    } finally {
        getSession().setProperty("NoCacheDeptToCWCanParm", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_AP_CWCAN_PARM objects for this R_DEPT
      * old R_AP_CWCAN_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_AP_CWCAN_PARM objects.
      */
      public Enumeration   getOldDeptToCWCanParm()
      {
         
         if (!getSession().getProperty("NoCacheDeptToCWCanParm").equals("true"))
         
         {
            if ( DeptToCWCanParmCache != null ) return DeptToCWCanParmCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_CWCAN_PARM";
            param.fieldName = "CW_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCWCanParm").equals("true"))
         {
            DeptToCWCanParmCache = new ObjectHashtable();
            for (Enumeration e = (R_AP_CWCAN_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCWCanParmCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCWCanParmCache.elements());
         }
         else
         {
         
            return (R_AP_CWCAN_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old AUTO_CA_NO objects for this R_DEPT
      * old AUTO_CA_NO objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old AUTO_CA_NO objects.
      */
  public Enumeration getOldDeptToAutoCano(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToAutoCano");
    if (cache)
      getSession().setProperty("NoCacheDeptToAutoCano", "false");
    else
      getSession().setProperty("NoCacheDeptToAutoCano", "true");

    try {
      return getOldDeptToAutoCano();
    } finally {
        getSession().setProperty("NoCacheDeptToAutoCano", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old AUTO_CA_NO objects for this R_DEPT
      * old AUTO_CA_NO objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old AUTO_CA_NO objects.
      */
      public Enumeration   getOldDeptToAutoCano()
      {
         
         if (!getSession().getProperty("NoCacheDeptToAutoCano").equals("true"))
         
         {
            if ( DeptToAutoCanoCache != null ) return DeptToAutoCanoCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "AUTO_CA_NO";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToAutoCano").equals("true"))
         {
            DeptToAutoCanoCache = new ObjectHashtable();
            for (Enumeration e = (AUTO_CA_NOBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToAutoCanoCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToAutoCanoCache.elements());
         }
         else
         {
         
            return (AUTO_CA_NOBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old TRVL_COA_OVRD objects for this R_DEPT
      * old TRVL_COA_OVRD objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old TRVL_COA_OVRD objects.
      */
  public Enumeration getOldTRVLCoaOvrdToDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheTRVLCoaOvrdToDept");
    if (cache)
      getSession().setProperty("NoCacheTRVLCoaOvrdToDept", "false");
    else
      getSession().setProperty("NoCacheTRVLCoaOvrdToDept", "true");

    try {
      return getOldTRVLCoaOvrdToDept();
    } finally {
        getSession().setProperty("NoCacheTRVLCoaOvrdToDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old TRVL_COA_OVRD objects for this R_DEPT
      * old TRVL_COA_OVRD objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old TRVL_COA_OVRD objects.
      */
      public Enumeration   getOldTRVLCoaOvrdToDept()
      {
         
         if (!getSession().getProperty("NoCacheTRVLCoaOvrdToDept").equals("true"))
         
         {
            if ( TRVLCoaOvrdToDeptCache != null ) return TRVLCoaOvrdToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "TRVL_COA_OVRD";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheTRVLCoaOvrdToDept").equals("true"))
         {
            TRVLCoaOvrdToDeptCache = new ObjectHashtable();
            for (Enumeration e = (TRVL_COA_OVRDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               TRVLCoaOvrdToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (TRVLCoaOvrdToDeptCache.elements());
         }
         else
         {
         
            return (TRVL_COA_OVRDBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_TASK_ORD_BUYR_LN objects for this R_DEPT
      * old R_TASK_ORD_BUYR_LN objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_TASK_ORD_BUYR_LN objects.
      */
  public Enumeration getOldDept1ToTaskOrdBuyrLn1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDept1ToTaskOrdBuyrLn1");
    if (cache)
      getSession().setProperty("NoCacheDept1ToTaskOrdBuyrLn1", "false");
    else
      getSession().setProperty("NoCacheDept1ToTaskOrdBuyrLn1", "true");

    try {
      return getOldDept1ToTaskOrdBuyrLn1();
    } finally {
        getSession().setProperty("NoCacheDept1ToTaskOrdBuyrLn1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_TASK_ORD_BUYR_LN objects for this R_DEPT
      * old R_TASK_ORD_BUYR_LN objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_TASK_ORD_BUYR_LN objects.
      */
      public Enumeration   getOldDept1ToTaskOrdBuyrLn1()
      {
         
         if (!getSession().getProperty("NoCacheDept1ToTaskOrdBuyrLn1").equals("true"))
         
         {
            if ( Dept1ToTaskOrdBuyrLn1Cache != null ) return Dept1ToTaskOrdBuyrLn1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_TASK_ORD_BUYR_LN";
            param.fieldName = "BUYR_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDept1ToTaskOrdBuyrLn1").equals("true"))
         {
            Dept1ToTaskOrdBuyrLn1Cache = new ObjectHashtable();
            for (Enumeration e = (R_TASK_ORD_BUYR_LNBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               Dept1ToTaskOrdBuyrLn1Cache.put(pkey,cacheBO);                        
            }
         
            return (Dept1ToTaskOrdBuyrLn1Cache.elements());
         }
         else
         {
         
            return (R_TASK_ORD_BUYR_LNBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_TASK_ORD_BUYR_LN objects for this R_DEPT
      * old R_TASK_ORD_BUYR_LN objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_TASK_ORD_BUYR_LN objects.
      */
  public Enumeration getOldDeptToTaskOrdBuyrLn(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToTaskOrdBuyrLn");
    if (cache)
      getSession().setProperty("NoCacheDeptToTaskOrdBuyrLn", "false");
    else
      getSession().setProperty("NoCacheDeptToTaskOrdBuyrLn", "true");

    try {
      return getOldDeptToTaskOrdBuyrLn();
    } finally {
        getSession().setProperty("NoCacheDeptToTaskOrdBuyrLn", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_TASK_ORD_BUYR_LN objects for this R_DEPT
      * old R_TASK_ORD_BUYR_LN objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_TASK_ORD_BUYR_LN objects.
      */
      public Enumeration   getOldDeptToTaskOrdBuyrLn()
      {
         
         if (!getSession().getProperty("NoCacheDeptToTaskOrdBuyrLn").equals("true"))
         
         {
            if ( DeptToTaskOrdBuyrLnCache != null ) return DeptToTaskOrdBuyrLnCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_TASK_ORD_BUYR_LN";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToTaskOrdBuyrLn").equals("true"))
         {
            DeptToTaskOrdBuyrLnCache = new ObjectHashtable();
            for (Enumeration e = (R_TASK_ORD_BUYR_LNBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToTaskOrdBuyrLnCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToTaskOrdBuyrLnCache.elements());
         }
         else
         {
         
            return (R_TASK_ORD_BUYR_LNBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_SYS_CROSWALK objects for this R_DEPT
      * old R_SYS_CROSWALK objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_SYS_CROSWALK objects.
      */
  public Enumeration getOldR_SYS_CROSWALKs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_SYS_CROSWALKs");
    if (cache)
      getSession().setProperty("NoCacheR_SYS_CROSWALKs", "false");
    else
      getSession().setProperty("NoCacheR_SYS_CROSWALKs", "true");

    try {
      return getOldR_SYS_CROSWALKs();
    } finally {
        getSession().setProperty("NoCacheR_SYS_CROSWALKs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_SYS_CROSWALK objects for this R_DEPT
      * old R_SYS_CROSWALK objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_SYS_CROSWALK objects.
      */
      public Enumeration   getOldR_SYS_CROSWALKs()
      {
         
         if (!getSession().getProperty("NoCacheR_SYS_CROSWALKs").equals("true"))
         
         {
            if ( R_SYS_CROSWALKsCache != null ) return R_SYS_CROSWALKsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_SYS_CROSWALK";
            param.fieldName = "CTRL_ELEM_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_SYS_CROSWALKs").equals("true"))
         {
            R_SYS_CROSWALKsCache = new ObjectHashtable();
            for (Enumeration e = (R_SYS_CROSWALKBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_SYS_CROSWALKsCache.put(pkey,cacheBO);                        
            }
         
            return (R_SYS_CROSWALKsCache.elements());
         }
         else
         {
         
            return (R_SYS_CROSWALKBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PTYP objects for this R_DEPT
      * old R_PTYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PTYP objects.
      */
  public Enumeration getOldR_PTYPs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_PTYPs1");
    if (cache)
      getSession().setProperty("NoCacheR_PTYPs1", "false");
    else
      getSession().setProperty("NoCacheR_PTYPs1", "true");

    try {
      return getOldR_PTYPs1();
    } finally {
        getSession().setProperty("NoCacheR_PTYPs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PTYP objects for this R_DEPT
      * old R_PTYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PTYP objects.
      */
      public Enumeration   getOldR_PTYPs1()
      {
         
         if (!getSession().getProperty("NoCacheR_PTYPs1").equals("true"))
         
         {
            if ( R_PTYPs1Cache != null ) return R_PTYPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PTYP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_PTYPs1").equals("true"))
         {
            R_PTYPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_PTYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_PTYPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_PTYPs1Cache.elements());
         }
         else
         {
         
            return (R_PTYPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PLBS_OFST_REQ objects for this R_DEPT
      * old R_PLBS_OFST_REQ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PLBS_OFST_REQ objects.
      */
  public Enumeration getOldRdeptToRplbsOfstReq(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRdeptToRplbsOfstReq");
    if (cache)
      getSession().setProperty("NoCacheRdeptToRplbsOfstReq", "false");
    else
      getSession().setProperty("NoCacheRdeptToRplbsOfstReq", "true");

    try {
      return getOldRdeptToRplbsOfstReq();
    } finally {
        getSession().setProperty("NoCacheRdeptToRplbsOfstReq", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PLBS_OFST_REQ objects for this R_DEPT
      * old R_PLBS_OFST_REQ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PLBS_OFST_REQ objects.
      */
      public Enumeration   getOldRdeptToRplbsOfstReq()
      {
         
         if (!getSession().getProperty("NoCacheRdeptToRplbsOfstReq").equals("true"))
         
         {
            if ( RdeptToRplbsOfstReqCache != null ) return RdeptToRplbsOfstReqCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PLBS_OFST_REQ";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToRplbsOfstReq").equals("true"))
         {
            RdeptToRplbsOfstReqCache = new ObjectHashtable();
            for (Enumeration e = (R_PLBS_OFST_REQBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToRplbsOfstReqCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToRplbsOfstReqCache.elements());
         }
         else
         {
         
            return (R_PLBS_OFST_REQBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PLBS_DIST objects for this R_DEPT
      * old R_PLBS_DIST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PLBS_DIST objects.
      */
  public Enumeration getOldRdeptToRplbsDist(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRdeptToRplbsDist");
    if (cache)
      getSession().setProperty("NoCacheRdeptToRplbsDist", "false");
    else
      getSession().setProperty("NoCacheRdeptToRplbsDist", "true");

    try {
      return getOldRdeptToRplbsDist();
    } finally {
        getSession().setProperty("NoCacheRdeptToRplbsDist", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PLBS_DIST objects for this R_DEPT
      * old R_PLBS_DIST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PLBS_DIST objects.
      */
      public Enumeration   getOldRdeptToRplbsDist()
      {
         
         if (!getSession().getProperty("NoCacheRdeptToRplbsDist").equals("true"))
         
         {
            if ( RdeptToRplbsDistCache != null ) return RdeptToRplbsDistCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PLBS_DIST";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToRplbsDist").equals("true"))
         {
            RdeptToRplbsDistCache = new ObjectHashtable();
            for (Enumeration e = (R_PLBS_DISTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToRplbsDistCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToRplbsDistCache.elements());
         }
         else
         {
         
            return (R_PLBS_DISTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_GRNTR_RPT objects for this R_DEPT
      * old R_GRNTR_RPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_GRNTR_RPT objects.
      */
  public Enumeration getOldRDeptToRGrntrRpt1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRGrntrRpt1");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRGrntrRpt1", "false");
    else
      getSession().setProperty("NoCacheRDeptToRGrntrRpt1", "true");

    try {
      return getOldRDeptToRGrntrRpt1();
    } finally {
        getSession().setProperty("NoCacheRDeptToRGrntrRpt1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_GRNTR_RPT objects for this R_DEPT
      * old R_GRNTR_RPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_GRNTR_RPT objects.
      */
      public Enumeration   getOldRDeptToRGrntrRpt1()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntrRpt1").equals("true"))
         
         {
            if ( RDeptToRGrntrRpt1Cache != null ) return RDeptToRGrntrRpt1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNTR_RPT";
            param.fieldName = "AWD_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntrRpt1").equals("true"))
         {
            RDeptToRGrntrRpt1Cache = new ObjectHashtable();
            for (Enumeration e = (R_GRNTR_RPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntrRpt1Cache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntrRpt1Cache.elements());
         }
         else
         {
         
            return (R_GRNTR_RPTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FNCAT objects for this R_DEPT
      * old R_FNCAT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FNCAT objects.
      */
  public Enumeration getOldR_FNCATs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_FNCATs1");
    if (cache)
      getSession().setProperty("NoCacheR_FNCATs1", "false");
    else
      getSession().setProperty("NoCacheR_FNCATs1", "true");

    try {
      return getOldR_FNCATs1();
    } finally {
        getSession().setProperty("NoCacheR_FNCATs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FNCAT objects for this R_DEPT
      * old R_FNCAT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FNCAT objects.
      */
      public Enumeration   getOldR_FNCATs1()
      {
         
         if (!getSession().getProperty("NoCacheR_FNCATs1").equals("true"))
         
         {
            if ( R_FNCATs1Cache != null ) return R_FNCATs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FNCAT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_FNCATs1").equals("true"))
         {
            R_FNCATs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_FNCATBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_FNCATs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_FNCATs1Cache.elements());
         }
         else
         {
         
            return (R_FNCATBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_CSAL_STPCTR_SETP objects for this R_DEPT
      * old R_CSAL_STPCTR_SETP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_CSAL_STPCTR_SETP objects.
      */
  public Enumeration getOldRdeptToRcsalStpctrSetp(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRdeptToRcsalStpctrSetp");
    if (cache)
      getSession().setProperty("NoCacheRdeptToRcsalStpctrSetp", "false");
    else
      getSession().setProperty("NoCacheRdeptToRcsalStpctrSetp", "true");

    try {
      return getOldRdeptToRcsalStpctrSetp();
    } finally {
        getSession().setProperty("NoCacheRdeptToRcsalStpctrSetp", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_CSAL_STPCTR_SETP objects for this R_DEPT
      * old R_CSAL_STPCTR_SETP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_CSAL_STPCTR_SETP objects.
      */
      public Enumeration   getOldRdeptToRcsalStpctrSetp()
      {
         
         if (!getSession().getProperty("NoCacheRdeptToRcsalStpctrSetp").equals("true"))
         
         {
            if ( RdeptToRcsalStpctrSetpCache != null ) return RdeptToRcsalStpctrSetpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CSAL_STPCTR_SETP";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToRcsalStpctrSetp").equals("true"))
         {
            RdeptToRcsalStpctrSetpCache = new ObjectHashtable();
            for (Enumeration e = (R_CSAL_STPCTR_SETPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToRcsalStpctrSetpCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToRcsalStpctrSetpCache.elements());
         }
         else
         {
         
            return (R_CSAL_STPCTR_SETPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_BUR objects for this R_DEPT
      * old R_BUR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_BUR objects.
      */
  public Enumeration getOldR_BURs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_BURs1");
    if (cache)
      getSession().setProperty("NoCacheR_BURs1", "false");
    else
      getSession().setProperty("NoCacheR_BURs1", "true");

    try {
      return getOldR_BURs1();
    } finally {
        getSession().setProperty("NoCacheR_BURs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_BUR objects for this R_DEPT
      * old R_BUR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_BUR objects.
      */
      public Enumeration   getOldR_BURs1()
      {
         
         if (!getSession().getProperty("NoCacheR_BURs1").equals("true"))
         
         {
            if ( R_BURs1Cache != null ) return R_BURs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_BUR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_BURs1").equals("true"))
         {
            R_BURs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_BURBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_BURs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_BURs1Cache.elements());
         }
         else
         {
         
            return (R_BURBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_BFY_STPF_NACTG objects for this R_DEPT
      * old R_BFY_STPF_NACTG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_BFY_STPF_NACTG objects.
      */
  public Enumeration getOldRDept_RBfyStpfNactg(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDept_RBfyStpfNactg");
    if (cache)
      getSession().setProperty("NoCacheRDept_RBfyStpfNactg", "false");
    else
      getSession().setProperty("NoCacheRDept_RBfyStpfNactg", "true");

    try {
      return getOldRDept_RBfyStpfNactg();
    } finally {
        getSession().setProperty("NoCacheRDept_RBfyStpfNactg", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_BFY_STPF_NACTG objects for this R_DEPT
      * old R_BFY_STPF_NACTG objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_BFY_STPF_NACTG objects.
      */
      public Enumeration   getOldRDept_RBfyStpfNactg()
      {
         
         if (!getSession().getProperty("NoCacheRDept_RBfyStpfNactg").equals("true"))
         
         {
            if ( RDept_RBfyStpfNactgCache != null ) return RDept_RBfyStpfNactgCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_BFY_STPF_NACTG";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDept_RBfyStpfNactg").equals("true"))
         {
            RDept_RBfyStpfNactgCache = new ObjectHashtable();
            for (Enumeration e = (R_BFY_STPF_NACTGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDept_RBfyStpfNactgCache.put(pkey,cacheBO);                        
            }
         
            return (RDept_RBfyStpfNactgCache.elements());
         }
         else
         {
         
            return (R_BFY_STPF_NACTGBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old AUTO_DOC_NO objects for this R_DEPT
      * old AUTO_DOC_NO objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old AUTO_DOC_NO objects.
      */
  public Enumeration getOldAUTO_DOC_NOs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheAUTO_DOC_NOs");
    if (cache)
      getSession().setProperty("NoCacheAUTO_DOC_NOs", "false");
    else
      getSession().setProperty("NoCacheAUTO_DOC_NOs", "true");

    try {
      return getOldAUTO_DOC_NOs();
    } finally {
        getSession().setProperty("NoCacheAUTO_DOC_NOs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old AUTO_DOC_NO objects for this R_DEPT
      * old AUTO_DOC_NO objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old AUTO_DOC_NO objects.
      */
      public Enumeration   getOldAUTO_DOC_NOs()
      {
         
         if (!getSession().getProperty("NoCacheAUTO_DOC_NOs").equals("true"))
         
         {
            if ( AUTO_DOC_NOsCache != null ) return AUTO_DOC_NOsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "AUTO_DOC_NO";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheAUTO_DOC_NOs").equals("true"))
         {
            AUTO_DOC_NOsCache = new ObjectHashtable();
            for (Enumeration e = (AUTO_DOC_NOBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               AUTO_DOC_NOsCache.put(pkey,cacheBO);                        
            }
         
            return (AUTO_DOC_NOsCache.elements());
         }
         else
         {
         
            return (AUTO_DOC_NOBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old VCC_DOC_VCUST objects for this R_DEPT
      * old VCC_DOC_VCUST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old VCC_DOC_VCUST objects.
      */
  public Enumeration getOldRDeptVcVcust(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptVcVcust");
    if (cache)
      getSession().setProperty("NoCacheRDeptVcVcust", "false");
    else
      getSession().setProperty("NoCacheRDeptVcVcust", "true");

    try {
      return getOldRDeptVcVcust();
    } finally {
        getSession().setProperty("NoCacheRDeptVcVcust", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old VCC_DOC_VCUST objects for this R_DEPT
      * old VCC_DOC_VCUST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old VCC_DOC_VCUST objects.
      */
      public Enumeration   getOldRDeptVcVcust()
      {
         
         if (!getSession().getProperty("NoCacheRDeptVcVcust").equals("true"))
         
         {
            if ( RDeptVcVcustCache != null ) return RDeptVcVcustCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "VCC_DOC_VCUST";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptVcVcust").equals("true"))
         {
            RDeptVcVcustCache = new ObjectHashtable();
            for (Enumeration e = (VCC_DOC_VCUSTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptVcVcustCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptVcVcustCache.elements());
         }
         else
         {
         
            return (VCC_DOC_VCUSTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old VCC_DOC_AUTHDEPT objects for this R_DEPT
      * old VCC_DOC_AUTHDEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old VCC_DOC_AUTHDEPT objects.
      */
  public Enumeration getOldRDeptVcAuthDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptVcAuthDept");
    if (cache)
      getSession().setProperty("NoCacheRDeptVcAuthDept", "false");
    else
      getSession().setProperty("NoCacheRDeptVcAuthDept", "true");

    try {
      return getOldRDeptVcAuthDept();
    } finally {
        getSession().setProperty("NoCacheRDeptVcAuthDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old VCC_DOC_AUTHDEPT objects for this R_DEPT
      * old VCC_DOC_AUTHDEPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old VCC_DOC_AUTHDEPT objects.
      */
      public Enumeration   getOldRDeptVcAuthDept()
      {
         
         if (!getSession().getProperty("NoCacheRDeptVcAuthDept").equals("true"))
         
         {
            if ( RDeptVcAuthDeptCache != null ) return RDeptVcAuthDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "VCC_DOC_AUTHDEPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptVcAuthDept").equals("true"))
         {
            RDeptVcAuthDeptCache = new ObjectHashtable();
            for (Enumeration e = (VCC_DOC_AUTHDEPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptVcAuthDeptCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptVcAuthDeptCache.elements());
         }
         else
         {
         
            return (VCC_DOC_AUTHDEPTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old RQ_DOC_HDR objects for this R_DEPT
      * old RQ_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old RQ_DOC_HDR objects.
      */
  public Enumeration getOldRQ_DOC_HDR(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRQ_DOC_HDR");
    if (cache)
      getSession().setProperty("NoCacheRQ_DOC_HDR", "false");
    else
      getSession().setProperty("NoCacheRQ_DOC_HDR", "true");

    try {
      return getOldRQ_DOC_HDR();
    } finally {
        getSession().setProperty("NoCacheRQ_DOC_HDR", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old RQ_DOC_HDR objects for this R_DEPT
      * old RQ_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old RQ_DOC_HDR objects.
      */
      public Enumeration   getOldRQ_DOC_HDR()
      {
         
         if (!getSession().getProperty("NoCacheRQ_DOC_HDR").equals("true"))
         
         {
            if ( RQ_DOC_HDRCache != null ) return RQ_DOC_HDRCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "RQ_DOC_HDR";
            param.fieldName = "RQSTR_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRQ_DOC_HDR").equals("true"))
         {
            RQ_DOC_HDRCache = new ObjectHashtable();
            for (Enumeration e = (RQ_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RQ_DOC_HDRCache.put(pkey,cacheBO);                        
            }
         
            return (RQ_DOC_HDRCache.elements());
         }
         else
         {
         
            return (RQ_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_REIMRQD_RCYCSEL objects for this R_DEPT
      * old R_REIMRQD_RCYCSEL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_REIMRQD_RCYCSEL objects.
      */
  public Enumeration getOldReimReqRcycSelToDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheReimReqRcycSelToDept");
    if (cache)
      getSession().setProperty("NoCacheReimReqRcycSelToDept", "false");
    else
      getSession().setProperty("NoCacheReimReqRcycSelToDept", "true");

    try {
      return getOldReimReqRcycSelToDept();
    } finally {
        getSession().setProperty("NoCacheReimReqRcycSelToDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_REIMRQD_RCYCSEL objects for this R_DEPT
      * old R_REIMRQD_RCYCSEL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_REIMRQD_RCYCSEL objects.
      */
      public Enumeration   getOldReimReqRcycSelToDept()
      {
         
         if (!getSession().getProperty("NoCacheReimReqRcycSelToDept").equals("true"))
         
         {
            if ( ReimReqRcycSelToDeptCache != null ) return ReimReqRcycSelToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_REIMRQD_RCYCSEL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheReimReqRcycSelToDept").equals("true"))
         {
            ReimReqRcycSelToDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_REIMRQD_RCYCSELBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ReimReqRcycSelToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (ReimReqRcycSelToDeptCache.elements());
         }
         else
         {
         
            return (R_REIMRQD_RCYCSELBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PRTST objects for this R_DEPT
      * old R_PRTST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PRTST objects.
      */
  public Enumeration getOldRDeptToRPrtst(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRPrtst");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRPrtst", "false");
    else
      getSession().setProperty("NoCacheRDeptToRPrtst", "true");

    try {
      return getOldRDeptToRPrtst();
    } finally {
        getSession().setProperty("NoCacheRDeptToRPrtst", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PRTST objects for this R_DEPT
      * old R_PRTST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PRTST objects.
      */
      public Enumeration   getOldRDeptToRPrtst()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRPrtst").equals("true"))
         
         {
            if ( RDeptToRPrtstCache != null ) return RDeptToRPrtstCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PRTST";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRPrtst").equals("true"))
         {
            RDeptToRPrtstCache = new ObjectHashtable();
            for (Enumeration e = (R_PRTSTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRPrtstCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRPrtstCache.elements());
         }
         else
         {
         
            return (R_PRTSTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_LOC_TBL objects for this R_DEPT
      * old R_LOC_TBL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_LOC_TBL objects.
      */
  public Enumeration getOldR_LOC_TBLs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_LOC_TBLs1");
    if (cache)
      getSession().setProperty("NoCacheR_LOC_TBLs1", "false");
    else
      getSession().setProperty("NoCacheR_LOC_TBLs1", "true");

    try {
      return getOldR_LOC_TBLs1();
    } finally {
        getSession().setProperty("NoCacheR_LOC_TBLs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_LOC_TBL objects for this R_DEPT
      * old R_LOC_TBL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_LOC_TBL objects.
      */
      public Enumeration   getOldR_LOC_TBLs1()
      {
         
         if (!getSession().getProperty("NoCacheR_LOC_TBLs1").equals("true"))
         
         {
            if ( R_LOC_TBLs1Cache != null ) return R_LOC_TBLs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_LOC_TBL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_LOC_TBLs1").equals("true"))
         {
            R_LOC_TBLs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_LOC_TBLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_LOC_TBLs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_LOC_TBLs1Cache.elements());
         }
         else
         {
         
            return (R_LOC_TBLBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_INT_CST_PARM objects for this R_DEPT
      * old R_INT_CST_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_INT_CST_PARM objects.
      */
  public Enumeration getOldRDept1ToRIntCst(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDept1ToRIntCst");
    if (cache)
      getSession().setProperty("NoCacheRDept1ToRIntCst", "false");
    else
      getSession().setProperty("NoCacheRDept1ToRIntCst", "true");

    try {
      return getOldRDept1ToRIntCst();
    } finally {
        getSession().setProperty("NoCacheRDept1ToRIntCst", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_INT_CST_PARM objects for this R_DEPT
      * old R_INT_CST_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_INT_CST_PARM objects.
      */
      public Enumeration   getOldRDept1ToRIntCst()
      {
         
         if (!getSession().getProperty("NoCacheRDept1ToRIntCst").equals("true"))
         
         {
            if ( RDept1ToRIntCstCache != null ) return RDept1ToRIntCstCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_INT_CST_PARM";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDept1ToRIntCst").equals("true"))
         {
            RDept1ToRIntCstCache = new ObjectHashtable();
            for (Enumeration e = (R_INT_CST_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDept1ToRIntCstCache.put(pkey,cacheBO);                        
            }
         
            return (RDept1ToRIntCstCache.elements());
         }
         else
         {
         
            return (R_INT_CST_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_GRNTR_EVNT_SCHED objects for this R_DEPT
      * old R_GRNTR_EVNT_SCHED objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_GRNTR_EVNT_SCHED objects.
      */
  public Enumeration getOldRDeptToRGrntrEvntSched(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRGrntrEvntSched");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRGrntrEvntSched", "false");
    else
      getSession().setProperty("NoCacheRDeptToRGrntrEvntSched", "true");

    try {
      return getOldRDeptToRGrntrEvntSched();
    } finally {
        getSession().setProperty("NoCacheRDeptToRGrntrEvntSched", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_GRNTR_EVNT_SCHED objects for this R_DEPT
      * old R_GRNTR_EVNT_SCHED objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_GRNTR_EVNT_SCHED objects.
      */
      public Enumeration   getOldRDeptToRGrntrEvntSched()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntrEvntSched").equals("true"))
         
         {
            if ( RDeptToRGrntrEvntSchedCache != null ) return RDeptToRGrntrEvntSchedCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNTR_EVNT_SCHED";
            param.fieldName = "OPTY_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntrEvntSched").equals("true"))
         {
            RDeptToRGrntrEvntSchedCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNTR_EVNT_SCHEDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntrEvntSchedCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntrEvntSchedCache.elements());
         }
         else
         {
         
            return (R_GRNTR_EVNT_SCHEDBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_ESCROW_HIST objects for this R_DEPT
      * old R_ESCROW_HIST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_ESCROW_HIST objects.
      */
  public Enumeration getOldDeptToEscrowHist(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToEscrowHist");
    if (cache)
      getSession().setProperty("NoCacheDeptToEscrowHist", "false");
    else
      getSession().setProperty("NoCacheDeptToEscrowHist", "true");

    try {
      return getOldDeptToEscrowHist();
    } finally {
        getSession().setProperty("NoCacheDeptToEscrowHist", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_ESCROW_HIST objects for this R_DEPT
      * old R_ESCROW_HIST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_ESCROW_HIST objects.
      */
      public Enumeration   getOldDeptToEscrowHist()
      {
         
         if (!getSession().getProperty("NoCacheDeptToEscrowHist").equals("true"))
         
         {
            if ( DeptToEscrowHistCache != null ) return DeptToEscrowHistCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ESCROW_HIST";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToEscrowHist").equals("true"))
         {
            DeptToEscrowHistCache = new ObjectHashtable();
            for (Enumeration e = (R_ESCROW_HISTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToEscrowHistCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToEscrowHistCache.elements());
         }
         else
         {
         
            return (R_ESCROW_HISTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DISB_MGMT_RSTR objects for this R_DEPT
      * old R_DISB_MGMT_RSTR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DISB_MGMT_RSTR objects.
      */
  public Enumeration getOldR_DISB_MGMT_RSTRs2(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_DISB_MGMT_RSTRs2");
    if (cache)
      getSession().setProperty("NoCacheR_DISB_MGMT_RSTRs2", "false");
    else
      getSession().setProperty("NoCacheR_DISB_MGMT_RSTRs2", "true");

    try {
      return getOldR_DISB_MGMT_RSTRs2();
    } finally {
        getSession().setProperty("NoCacheR_DISB_MGMT_RSTRs2", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DISB_MGMT_RSTR objects for this R_DEPT
      * old R_DISB_MGMT_RSTR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DISB_MGMT_RSTR objects.
      */
      public Enumeration   getOldR_DISB_MGMT_RSTRs2()
      {
         
         if (!getSession().getProperty("NoCacheR_DISB_MGMT_RSTRs2").equals("true"))
         
         {
            if ( R_DISB_MGMT_RSTRs2Cache != null ) return R_DISB_MGMT_RSTRs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DISB_MGMT_RSTR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DISB_MGMT_RSTRs2").equals("true"))
         {
            R_DISB_MGMT_RSTRs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_DISB_MGMT_RSTRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DISB_MGMT_RSTRs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DISB_MGMT_RSTRs2Cache.elements());
         }
         else
         {
         
            return (R_DISB_MGMT_RSTRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old DEBT_DOC_DEBTINST objects for this R_DEPT
      * old DEBT_DOC_DEBTINST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old DEBT_DOC_DEBTINST objects.
      */
  public Enumeration getOldDeptToDebtDocDebtInst(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToDebtDocDebtInst");
    if (cache)
      getSession().setProperty("NoCacheDeptToDebtDocDebtInst", "false");
    else
      getSession().setProperty("NoCacheDeptToDebtDocDebtInst", "true");

    try {
      return getOldDeptToDebtDocDebtInst();
    } finally {
        getSession().setProperty("NoCacheDeptToDebtDocDebtInst", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old DEBT_DOC_DEBTINST objects for this R_DEPT
      * old DEBT_DOC_DEBTINST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old DEBT_DOC_DEBTINST objects.
      */
      public Enumeration   getOldDeptToDebtDocDebtInst()
      {
         
         if (!getSession().getProperty("NoCacheDeptToDebtDocDebtInst").equals("true"))
         
         {
            if ( DeptToDebtDocDebtInstCache != null ) return DeptToDebtDocDebtInstCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "DEBT_DOC_DEBTINST";
            param.fieldName = "RESP_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDebtDocDebtInst").equals("true"))
         {
            DeptToDebtDocDebtInstCache = new ObjectHashtable();
            for (Enumeration e = (DEBT_DOC_DEBTINSTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDebtDocDebtInstCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDebtDocDebtInstCache.elements());
         }
         else
         {
         
            return (DEBT_DOC_DEBTINSTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old SO_DOC_HDR objects for this R_DEPT
      * old SO_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old SO_DOC_HDR objects.
      */
  public Enumeration getOldSO_DOC_HDRs2(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheSO_DOC_HDRs2");
    if (cache)
      getSession().setProperty("NoCacheSO_DOC_HDRs2", "false");
    else
      getSession().setProperty("NoCacheSO_DOC_HDRs2", "true");

    try {
      return getOldSO_DOC_HDRs2();
    } finally {
        getSession().setProperty("NoCacheSO_DOC_HDRs2", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old SO_DOC_HDR objects for this R_DEPT
      * old SO_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old SO_DOC_HDR objects.
      */
      public Enumeration   getOldSO_DOC_HDRs2()
      {
         
         if (!getSession().getProperty("NoCacheSO_DOC_HDRs2").equals("true"))
         
         {
            if ( SO_DOC_HDRs2Cache != null ) return SO_DOC_HDRs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "SO_DOC_HDR";
            param.fieldName = "NVEND_LST_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheSO_DOC_HDRs2").equals("true"))
         {
            SO_DOC_HDRs2Cache = new ObjectHashtable();
            for (Enumeration e = (SO_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               SO_DOC_HDRs2Cache.put(pkey,cacheBO);                        
            }
         
            return (SO_DOC_HDRs2Cache.elements());
         }
         else
         {
         
            return (SO_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_EQUIP objects for this R_DEPT
      * old R_EQUIP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_EQUIP objects.
      */
  public Enumeration getOldRDeptToREquip(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToREquip");
    if (cache)
      getSession().setProperty("NoCacheRDeptToREquip", "false");
    else
      getSession().setProperty("NoCacheRDeptToREquip", "true");

    try {
      return getOldRDeptToREquip();
    } finally {
        getSession().setProperty("NoCacheRDeptToREquip", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_EQUIP objects for this R_DEPT
      * old R_EQUIP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_EQUIP objects.
      */
      public Enumeration   getOldRDeptToREquip()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToREquip").equals("true"))
         
         {
            if ( RDeptToREquipCache != null ) return RDeptToREquipCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_EQUIP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToREquip").equals("true"))
         {
            RDeptToREquipCache = new ObjectHashtable();
            for (Enumeration e = (R_EQUIPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToREquipCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToREquipCache.elements());
         }
         else
         {
         
            return (R_EQUIPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DRSCLS objects for this R_DEPT
      * old R_DRSCLS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DRSCLS objects.
      */
  public Enumeration getOldR_DRSCLSs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_DRSCLSs1");
    if (cache)
      getSession().setProperty("NoCacheR_DRSCLSs1", "false");
    else
      getSession().setProperty("NoCacheR_DRSCLSs1", "true");

    try {
      return getOldR_DRSCLSs1();
    } finally {
        getSession().setProperty("NoCacheR_DRSCLSs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DRSCLS objects for this R_DEPT
      * old R_DRSCLS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DRSCLS objects.
      */
      public Enumeration   getOldR_DRSCLSs1()
      {
         
         if (!getSession().getProperty("NoCacheR_DRSCLSs1").equals("true"))
         
         {
            if ( R_DRSCLSs1Cache != null ) return R_DRSCLSs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DRSCLS";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DRSCLSs1").equals("true"))
         {
            R_DRSCLSs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DRSCLSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DRSCLSs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DRSCLSs1Cache.elements());
         }
         else
         {
         
            return (R_DRSCLSBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DIV objects for this R_DEPT
      * old R_DIV objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DIV objects.
      */
  public Enumeration getOldR_DIVs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_DIVs1");
    if (cache)
      getSession().setProperty("NoCacheR_DIVs1", "false");
    else
      getSession().setProperty("NoCacheR_DIVs1", "true");

    try {
      return getOldR_DIVs1();
    } finally {
        getSession().setProperty("NoCacheR_DIVs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DIV objects for this R_DEPT
      * old R_DIV objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DIV objects.
      */
      public Enumeration   getOldR_DIVs1()
      {
         
         if (!getSession().getProperty("NoCacheR_DIVs1").equals("true"))
         
         {
            if ( R_DIVs1Cache != null ) return R_DIVs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DIV";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DIVs1").equals("true"))
         {
            R_DIVs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DIVBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DIVs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DIVs1Cache.elements());
         }
         else
         {
         
            return (R_DIVBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old PHM_DOC_LINE objects for this R_DEPT
      * old PHM_DOC_LINE objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old PHM_DOC_LINE objects.
      */
  public Enumeration getOldRDeptToPHMDocLn(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToPHMDocLn");
    if (cache)
      getSession().setProperty("NoCacheRDeptToPHMDocLn", "false");
    else
      getSession().setProperty("NoCacheRDeptToPHMDocLn", "true");

    try {
      return getOldRDeptToPHMDocLn();
    } finally {
        getSession().setProperty("NoCacheRDeptToPHMDocLn", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old PHM_DOC_LINE objects for this R_DEPT
      * old PHM_DOC_LINE objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old PHM_DOC_LINE objects.
      */
      public Enumeration   getOldRDeptToPHMDocLn()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToPHMDocLn").equals("true"))
         
         {
            if ( RDeptToPHMDocLnCache != null ) return RDeptToPHMDocLnCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "PHM_DOC_LINE";
            param.fieldName = "PR_AWD_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToPHMDocLn").equals("true"))
         {
            RDeptToPHMDocLnCache = new ObjectHashtable();
            for (Enumeration e = (PHM_DOC_LINEBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToPHMDocLnCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToPHMDocLnCache.elements());
         }
         else
         {
         
            return (PHM_DOC_LINEBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_APBY2 objects for this R_DEPT
      * old INF_APBY2 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_APBY2 objects.
      */
  public Enumeration getOldDeptToInfApBY2(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToInfApBY2");
    if (cache)
      getSession().setProperty("NoCacheDeptToInfApBY2", "false");
    else
      getSession().setProperty("NoCacheDeptToInfApBY2", "true");

    try {
      return getOldDeptToInfApBY2();
    } finally {
        getSession().setProperty("NoCacheDeptToInfApBY2", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_APBY2 objects for this R_DEPT
      * old INF_APBY2 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_APBY2 objects.
      */
      public Enumeration   getOldDeptToInfApBY2()
      {
         
         if (!getSession().getProperty("NoCacheDeptToInfApBY2").equals("true"))
         
         {
            if ( DeptToInfApBY2Cache != null ) return DeptToInfApBY2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_APBY2";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfApBY2").equals("true"))
         {
            DeptToInfApBY2Cache = new ObjectHashtable();
            for (Enumeration e = (INF_APBY2BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfApBY2Cache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfApBY2Cache.elements());
         }
         else
         {
         
            return (INF_APBY2BaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old AP_EDI_HDR objects for this R_DEPT
      * old AP_EDI_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old AP_EDI_HDR objects.
      */
  public Enumeration getOldDeptToApEdiHdr(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToApEdiHdr");
    if (cache)
      getSession().setProperty("NoCacheDeptToApEdiHdr", "false");
    else
      getSession().setProperty("NoCacheDeptToApEdiHdr", "true");

    try {
      return getOldDeptToApEdiHdr();
    } finally {
        getSession().setProperty("NoCacheDeptToApEdiHdr", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old AP_EDI_HDR objects for this R_DEPT
      * old AP_EDI_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old AP_EDI_HDR objects.
      */
      public Enumeration   getOldDeptToApEdiHdr()
      {
         
         if (!getSession().getProperty("NoCacheDeptToApEdiHdr").equals("true"))
         
         {
            if ( DeptToApEdiHdrCache != null ) return DeptToApEdiHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "AP_EDI_HDR";
            param.fieldName = "IN_DOC_DEPT";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToApEdiHdr").equals("true"))
         {
            DeptToApEdiHdrCache = new ObjectHashtable();
            for (Enumeration e = (AP_EDI_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToApEdiHdrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToApEdiHdrCache.elements());
         }
         else
         {
         
            return (AP_EDI_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_REIM_EXP_ADJ objects for this R_DEPT
      * old R_REIM_EXP_ADJ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_REIM_EXP_ADJ objects.
      */
  public Enumeration getOldDeptToReimExpAdj(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToReimExpAdj");
    if (cache)
      getSession().setProperty("NoCacheDeptToReimExpAdj", "false");
    else
      getSession().setProperty("NoCacheDeptToReimExpAdj", "true");

    try {
      return getOldDeptToReimExpAdj();
    } finally {
        getSession().setProperty("NoCacheDeptToReimExpAdj", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_REIM_EXP_ADJ objects for this R_DEPT
      * old R_REIM_EXP_ADJ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_REIM_EXP_ADJ objects.
      */
      public Enumeration   getOldDeptToReimExpAdj()
      {
         
         if (!getSession().getProperty("NoCacheDeptToReimExpAdj").equals("true"))
         
         {
            if ( DeptToReimExpAdjCache != null ) return DeptToReimExpAdjCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_REIM_EXP_ADJ";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToReimExpAdj").equals("true"))
         {
            DeptToReimExpAdjCache = new ObjectHashtable();
            for (Enumeration e = (R_REIM_EXP_ADJBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToReimExpAdjCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToReimExpAdjCache.elements());
         }
         else
         {
         
            return (R_REIM_EXP_ADJBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PROG_DOC_CRSREF objects for this R_DEPT
      * old R_PROG_DOC_CRSREF objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PROG_DOC_CRSREF objects.
      */
  public Enumeration getOldPrgDocCrsRefToDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCachePrgDocCrsRefToDept");
    if (cache)
      getSession().setProperty("NoCachePrgDocCrsRefToDept", "false");
    else
      getSession().setProperty("NoCachePrgDocCrsRefToDept", "true");

    try {
      return getOldPrgDocCrsRefToDept();
    } finally {
        getSession().setProperty("NoCachePrgDocCrsRefToDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PROG_DOC_CRSREF objects for this R_DEPT
      * old R_PROG_DOC_CRSREF objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PROG_DOC_CRSREF objects.
      */
      public Enumeration   getOldPrgDocCrsRefToDept()
      {
         
         if (!getSession().getProperty("NoCachePrgDocCrsRefToDept").equals("true"))
         
         {
            if ( PrgDocCrsRefToDeptCache != null ) return PrgDocCrsRefToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PROG_DOC_CRSREF";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCachePrgDocCrsRefToDept").equals("true"))
         {
            PrgDocCrsRefToDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_PROG_DOC_CRSREFBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               PrgDocCrsRefToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (PrgDocCrsRefToDeptCache.elements());
         }
         else
         {
         
            return (R_PROG_DOC_CRSREFBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PHASE objects for this R_DEPT
      * old R_PHASE objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PHASE objects.
      */
  public Enumeration getOldR_PHASEs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_PHASEs");
    if (cache)
      getSession().setProperty("NoCacheR_PHASEs", "false");
    else
      getSession().setProperty("NoCacheR_PHASEs", "true");

    try {
      return getOldR_PHASEs();
    } finally {
        getSession().setProperty("NoCacheR_PHASEs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PHASE objects for this R_DEPT
      * old R_PHASE objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PHASE objects.
      */
      public Enumeration   getOldR_PHASEs()
      {
         
         if (!getSession().getProperty("NoCacheR_PHASEs").equals("true"))
         
         {
            if ( R_PHASEsCache != null ) return R_PHASEsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PHASE";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_PHASEs").equals("true"))
         {
            R_PHASEsCache = new ObjectHashtable();
            for (Enumeration e = (R_PHASEBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_PHASEsCache.put(pkey,cacheBO);                        
            }
         
            return (R_PHASEsCache.elements());
         }
         else
         {
         
            return (R_PHASEBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_LOC objects for this R_DEPT
      * old R_LOC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_LOC objects.
      */
  public Enumeration getOldR_LOCs2(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_LOCs2");
    if (cache)
      getSession().setProperty("NoCacheR_LOCs2", "false");
    else
      getSession().setProperty("NoCacheR_LOCs2", "true");

    try {
      return getOldR_LOCs2();
    } finally {
        getSession().setProperty("NoCacheR_LOCs2", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_LOC objects for this R_DEPT
      * old R_LOC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_LOC objects.
      */
      public Enumeration   getOldR_LOCs2()
      {
         
         if (!getSession().getProperty("NoCacheR_LOCs2").equals("true"))
         
         {
            if ( R_LOCs2Cache != null ) return R_LOCs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_LOC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_LOCs2").equals("true"))
         {
            R_LOCs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_LOCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_LOCs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_LOCs2Cache.elements());
         }
         else
         {
         
            return (R_LOCBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_GRNT_DT_DET objects for this R_DEPT
      * old R_GRNT_DT_DET objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_GRNT_DT_DET objects.
      */
  public Enumeration getOldRDeptToRGrntDtDet(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRGrntDtDet");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRGrntDtDet", "false");
    else
      getSession().setProperty("NoCacheRDeptToRGrntDtDet", "true");

    try {
      return getOldRDeptToRGrntDtDet();
    } finally {
        getSession().setProperty("NoCacheRDeptToRGrntDtDet", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_GRNT_DT_DET objects for this R_DEPT
      * old R_GRNT_DT_DET objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_GRNT_DT_DET objects.
      */
      public Enumeration   getOldRDeptToRGrntDtDet()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntDtDet").equals("true"))
         
         {
            if ( RDeptToRGrntDtDetCache != null ) return RDeptToRGrntDtDetCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_DT_DET";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntDtDet").equals("true"))
         {
            RDeptToRGrntDtDetCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_DT_DETBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntDtDetCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntDtDetCache.elements());
         }
         else
         {
         
            return (R_GRNT_DT_DETBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_GRNTR_EVNT_SCHED objects for this R_DEPT
      * old R_GRNTR_EVNT_SCHED objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_GRNTR_EVNT_SCHED objects.
      */
  public Enumeration getOldRDeptToRGrntrEvntSched1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRGrntrEvntSched1");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRGrntrEvntSched1", "false");
    else
      getSession().setProperty("NoCacheRDeptToRGrntrEvntSched1", "true");

    try {
      return getOldRDeptToRGrntrEvntSched1();
    } finally {
        getSession().setProperty("NoCacheRDeptToRGrntrEvntSched1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_GRNTR_EVNT_SCHED objects for this R_DEPT
      * old R_GRNTR_EVNT_SCHED objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_GRNTR_EVNT_SCHED objects.
      */
      public Enumeration   getOldRDeptToRGrntrEvntSched1()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntrEvntSched1").equals("true"))
         
         {
            if ( RDeptToRGrntrEvntSched1Cache != null ) return RDeptToRGrntrEvntSched1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNTR_EVNT_SCHED";
            param.fieldName = "APPL_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntrEvntSched1").equals("true"))
         {
            RDeptToRGrntrEvntSched1Cache = new ObjectHashtable();
            for (Enumeration e = (R_GRNTR_EVNT_SCHEDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntrEvntSched1Cache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntrEvntSched1Cache.elements());
         }
         else
         {
         
            return (R_GRNTR_EVNT_SCHEDBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FDT_OPT objects for this R_DEPT
      * old R_FDT_OPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FDT_OPT objects.
      */
  public Enumeration getOldDeptToFDTOpt(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToFDTOpt");
    if (cache)
      getSession().setProperty("NoCacheDeptToFDTOpt", "false");
    else
      getSession().setProperty("NoCacheDeptToFDTOpt", "true");

    try {
      return getOldDeptToFDTOpt();
    } finally {
        getSession().setProperty("NoCacheDeptToFDTOpt", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FDT_OPT objects for this R_DEPT
      * old R_FDT_OPT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FDT_OPT objects.
      */
      public Enumeration   getOldDeptToFDTOpt()
      {
         
         if (!getSession().getProperty("NoCacheDeptToFDTOpt").equals("true"))
         
         {
            if ( DeptToFDTOptCache != null ) return DeptToFDTOptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FDT_OPT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToFDTOpt").equals("true"))
         {
            DeptToFDTOptCache = new ObjectHashtable();
            for (Enumeration e = (R_FDT_OPTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToFDTOptCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToFDTOptCache.elements());
         }
         else
         {
         
            return (R_FDT_OPTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DRSRC objects for this R_DEPT
      * old R_DRSRC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DRSRC objects.
      */
  public Enumeration getOldR_DRSRCs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_DRSRCs1");
    if (cache)
      getSession().setProperty("NoCacheR_DRSRCs1", "false");
    else
      getSession().setProperty("NoCacheR_DRSRCs1", "true");

    try {
      return getOldR_DRSRCs1();
    } finally {
        getSession().setProperty("NoCacheR_DRSRCs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DRSRC objects for this R_DEPT
      * old R_DRSRC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DRSRC objects.
      */
      public Enumeration   getOldR_DRSRCs1()
      {
         
         if (!getSession().getProperty("NoCacheR_DRSRCs1").equals("true"))
         
         {
            if ( R_DRSRCs1Cache != null ) return R_DRSRCs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DRSRC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DRSRCs1").equals("true"))
         {
            R_DRSRCs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DRSRCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DRSRCs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DRSRCs1Cache.elements());
         }
         else
         {
         
            return (R_DRSRCBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DOCLS objects for this R_DEPT
      * old R_DOCLS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DOCLS objects.
      */
  public Enumeration getOldR_DOCLSs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_DOCLSs1");
    if (cache)
      getSession().setProperty("NoCacheR_DOCLSs1", "false");
    else
      getSession().setProperty("NoCacheR_DOCLSs1", "true");

    try {
      return getOldR_DOCLSs1();
    } finally {
        getSession().setProperty("NoCacheR_DOCLSs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DOCLS objects for this R_DEPT
      * old R_DOCLS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DOCLS objects.
      */
      public Enumeration   getOldR_DOCLSs1()
      {
         
         if (!getSession().getProperty("NoCacheR_DOCLSs1").equals("true"))
         
         {
            if ( R_DOCLSs1Cache != null ) return R_DOCLSs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DOCLS";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DOCLSs1").equals("true"))
         {
            R_DOCLSs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DOCLSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DOCLSs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DOCLSs1Cache.elements());
         }
         else
         {
         
            return (R_DOCLSBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_CSAL_CTRL_SETP objects for this R_DEPT
      * old R_CSAL_CTRL_SETP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_CSAL_CTRL_SETP objects.
      */
  public Enumeration getOldRdeptToRcsalCtrlSetp(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRdeptToRcsalCtrlSetp");
    if (cache)
      getSession().setProperty("NoCacheRdeptToRcsalCtrlSetp", "false");
    else
      getSession().setProperty("NoCacheRdeptToRcsalCtrlSetp", "true");

    try {
      return getOldRdeptToRcsalCtrlSetp();
    } finally {
        getSession().setProperty("NoCacheRdeptToRcsalCtrlSetp", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_CSAL_CTRL_SETP objects for this R_DEPT
      * old R_CSAL_CTRL_SETP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_CSAL_CTRL_SETP objects.
      */
      public Enumeration   getOldRdeptToRcsalCtrlSetp()
      {
         
         if (!getSession().getProperty("NoCacheRdeptToRcsalCtrlSetp").equals("true"))
         
         {
            if ( RdeptToRcsalCtrlSetpCache != null ) return RdeptToRcsalCtrlSetpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CSAL_CTRL_SETP";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToRcsalCtrlSetp").equals("true"))
         {
            RdeptToRcsalCtrlSetpCache = new ObjectHashtable();
            for (Enumeration e = (R_CSAL_CTRL_SETPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToRcsalCtrlSetpCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToRcsalCtrlSetpCache.elements());
         }
         else
         {
         
            return (R_CSAL_CTRL_SETPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_BUYR_FLINE objects for this R_DEPT
      * old R_BUYR_FLINE objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_BUYR_FLINE objects.
      */
  public Enumeration getOldR_BUYR_FLINEs2(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_BUYR_FLINEs2");
    if (cache)
      getSession().setProperty("NoCacheR_BUYR_FLINEs2", "false");
    else
      getSession().setProperty("NoCacheR_BUYR_FLINEs2", "true");

    try {
      return getOldR_BUYR_FLINEs2();
    } finally {
        getSession().setProperty("NoCacheR_BUYR_FLINEs2", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_BUYR_FLINE objects for this R_DEPT
      * old R_BUYR_FLINE objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_BUYR_FLINE objects.
      */
      public Enumeration   getOldR_BUYR_FLINEs2()
      {
         
         if (!getSession().getProperty("NoCacheR_BUYR_FLINEs2").equals("true"))
         
         {
            if ( R_BUYR_FLINEs2Cache != null ) return R_BUYR_FLINEs2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_BUYR_FLINE";
            param.fieldName = "BUYR_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_BUYR_FLINEs2").equals("true"))
         {
            R_BUYR_FLINEs2Cache = new ObjectHashtable();
            for (Enumeration e = (R_BUYR_FLINEBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_BUYR_FLINEs2Cache.put(pkey,cacheBO);                        
            }
         
            return (R_BUYR_FLINEs2Cache.elements());
         }
         else
         {
         
            return (R_BUYR_FLINEBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_ALW_PYMT_DBTYP objects for this R_DEPT
      * old R_ALW_PYMT_DBTYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_ALW_PYMT_DBTYP objects.
      */
  public Enumeration getOldDeptToAlwPymntByDebt(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToAlwPymntByDebt");
    if (cache)
      getSession().setProperty("NoCacheDeptToAlwPymntByDebt", "false");
    else
      getSession().setProperty("NoCacheDeptToAlwPymntByDebt", "true");

    try {
      return getOldDeptToAlwPymntByDebt();
    } finally {
        getSession().setProperty("NoCacheDeptToAlwPymntByDebt", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_ALW_PYMT_DBTYP objects for this R_DEPT
      * old R_ALW_PYMT_DBTYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_ALW_PYMT_DBTYP objects.
      */
      public Enumeration   getOldDeptToAlwPymntByDebt()
      {
         
         if (!getSession().getProperty("NoCacheDeptToAlwPymntByDebt").equals("true"))
         
         {
            if ( DeptToAlwPymntByDebtCache != null ) return DeptToAlwPymntByDebtCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ALW_PYMT_DBTYP";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToAlwPymntByDebt").equals("true"))
         {
            DeptToAlwPymntByDebtCache = new ObjectHashtable();
            for (Enumeration e = (R_ALW_PYMT_DBTYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToAlwPymntByDebtCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToAlwPymntByDebtCache.elements());
         }
         else
         {
         
            return (R_ALW_PYMT_DBTYPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old GN_BUD_RULE objects for this R_DEPT
      * old GN_BUD_RULE objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old GN_BUD_RULE objects.
      */
  public Enumeration getOldGnBudRuleToDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheGnBudRuleToDept");
    if (cache)
      getSession().setProperty("NoCacheGnBudRuleToDept", "false");
    else
      getSession().setProperty("NoCacheGnBudRuleToDept", "true");

    try {
      return getOldGnBudRuleToDept();
    } finally {
        getSession().setProperty("NoCacheGnBudRuleToDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old GN_BUD_RULE objects for this R_DEPT
      * old GN_BUD_RULE objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old GN_BUD_RULE objects.
      */
      public Enumeration   getOldGnBudRuleToDept()
      {
         
         if (!getSession().getProperty("NoCacheGnBudRuleToDept").equals("true"))
         
         {
            if ( GnBudRuleToDeptCache != null ) return GnBudRuleToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GN_BUD_RULE";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheGnBudRuleToDept").equals("true"))
         {
            GnBudRuleToDeptCache = new ObjectHashtable();
            for (Enumeration e = (GN_BUD_RULEBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               GnBudRuleToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (GnBudRuleToDeptCache.elements());
         }
         else
         {
         
            return (GN_BUD_RULEBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_RSTR_USE objects for this R_DEPT
      * old R_RSTR_USE objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_RSTR_USE objects.
      */
  public Enumeration getOldR_RSTR_USEs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_RSTR_USEs");
    if (cache)
      getSession().setProperty("NoCacheR_RSTR_USEs", "false");
    else
      getSession().setProperty("NoCacheR_RSTR_USEs", "true");

    try {
      return getOldR_RSTR_USEs();
    } finally {
        getSession().setProperty("NoCacheR_RSTR_USEs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_RSTR_USE objects for this R_DEPT
      * old R_RSTR_USE objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_RSTR_USE objects.
      */
      public Enumeration   getOldR_RSTR_USEs()
      {
         
         if (!getSession().getProperty("NoCacheR_RSTR_USEs").equals("true"))
         
         {
            if ( R_RSTR_USEsCache != null ) return R_RSTR_USEsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_RSTR_USE";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_RSTR_USEs").equals("true"))
         {
            R_RSTR_USEsCache = new ObjectHashtable();
            for (Enumeration e = (R_RSTR_USEBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_RSTR_USEsCache.put(pkey,cacheBO);                        
            }
         
            return (R_RSTR_USEsCache.elements());
         }
         else
         {
         
            return (R_RSTR_USEBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FACC objects for this R_DEPT
      * old R_FACC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FACC objects.
      */
  public Enumeration getOldR_FACCs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_FACCs");
    if (cache)
      getSession().setProperty("NoCacheR_FACCs", "false");
    else
      getSession().setProperty("NoCacheR_FACCs", "true");

    try {
      return getOldR_FACCs();
    } finally {
        getSession().setProperty("NoCacheR_FACCs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FACC objects for this R_DEPT
      * old R_FACC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FACC objects.
      */
      public Enumeration   getOldR_FACCs()
      {
         
         if (!getSession().getProperty("NoCacheR_FACCs").equals("true"))
         
         {
            if ( R_FACCsCache != null ) return R_FACCsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FACC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_FACCs").equals("true"))
         {
            R_FACCsCache = new ObjectHashtable();
            for (Enumeration e = (R_FACCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_FACCsCache.put(pkey,cacheBO);                        
            }
         
            return (R_FACCsCache.elements());
         }
         else
         {
         
            return (R_FACCBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_EXTR_CASH_RECT objects for this R_DEPT
      * old R_EXTR_CASH_RECT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_EXTR_CASH_RECT objects.
      */
  public Enumeration getOldECRTToDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheECRTToDept");
    if (cache)
      getSession().setProperty("NoCacheECRTToDept", "false");
    else
      getSession().setProperty("NoCacheECRTToDept", "true");

    try {
      return getOldECRTToDept();
    } finally {
        getSession().setProperty("NoCacheECRTToDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_EXTR_CASH_RECT objects for this R_DEPT
      * old R_EXTR_CASH_RECT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_EXTR_CASH_RECT objects.
      */
      public Enumeration   getOldECRTToDept()
      {
         
         if (!getSession().getProperty("NoCacheECRTToDept").equals("true"))
         
         {
            if ( ECRTToDeptCache != null ) return ECRTToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_EXTR_CASH_RECT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheECRTToDept").equals("true"))
         {
            ECRTToDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_EXTR_CASH_RECTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ECRTToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (ECRTToDeptCache.elements());
         }
         else
         {
         
            return (R_EXTR_CASH_RECTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DOGRP objects for this R_DEPT
      * old R_DOGRP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DOGRP objects.
      */
  public Enumeration getOldR_DOGRPs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_DOGRPs1");
    if (cache)
      getSession().setProperty("NoCacheR_DOGRPs1", "false");
    else
      getSession().setProperty("NoCacheR_DOGRPs1", "true");

    try {
      return getOldR_DOGRPs1();
    } finally {
        getSession().setProperty("NoCacheR_DOGRPs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DOGRP objects for this R_DEPT
      * old R_DOGRP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DOGRP objects.
      */
      public Enumeration   getOldR_DOGRPs1()
      {
         
         if (!getSession().getProperty("NoCacheR_DOGRPs1").equals("true"))
         
         {
            if ( R_DOGRPs1Cache != null ) return R_DOGRPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DOGRP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DOGRPs1").equals("true"))
         {
            R_DOGRPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DOGRPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DOGRPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DOGRPs1Cache.elements());
         }
         else
         {
         
            return (R_DOGRPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_CLMTRK objects for this R_DEPT
      * old R_CLMTRK objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_CLMTRK objects.
      */
  public Enumeration getOldDeptToClmtrk(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToClmtrk");
    if (cache)
      getSession().setProperty("NoCacheDeptToClmtrk", "false");
    else
      getSession().setProperty("NoCacheDeptToClmtrk", "true");

    try {
      return getOldDeptToClmtrk();
    } finally {
        getSession().setProperty("NoCacheDeptToClmtrk", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_CLMTRK objects for this R_DEPT
      * old R_CLMTRK objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_CLMTRK objects.
      */
      public Enumeration   getOldDeptToClmtrk()
      {
         
         if (!getSession().getProperty("NoCacheDeptToClmtrk").equals("true"))
         
         {
            if ( DeptToClmtrkCache != null ) return DeptToClmtrkCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CLMTRK";
            param.fieldName = "RC_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToClmtrk").equals("true"))
         {
            DeptToClmtrkCache = new ObjectHashtable();
            for (Enumeration e = (R_CLMTRKBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToClmtrkCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToClmtrkCache.elements());
         }
         else
         {
         
            return (R_CLMTRKBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_CA_DOC_HIST objects for this R_DEPT
      * old R_CA_DOC_HIST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_CA_DOC_HIST objects.
      */
  public Enumeration getOldDeptToCADocHist(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToCADocHist");
    if (cache)
      getSession().setProperty("NoCacheDeptToCADocHist", "false");
    else
      getSession().setProperty("NoCacheDeptToCADocHist", "true");

    try {
      return getOldDeptToCADocHist();
    } finally {
        getSession().setProperty("NoCacheDeptToCADocHist", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_CA_DOC_HIST objects for this R_DEPT
      * old R_CA_DOC_HIST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_CA_DOC_HIST objects.
      */
      public Enumeration   getOldDeptToCADocHist()
      {
         
         if (!getSession().getProperty("NoCacheDeptToCADocHist").equals("true"))
         
         {
            if ( DeptToCADocHistCache != null ) return DeptToCADocHistCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CA_DOC_HIST";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToCADocHist").equals("true"))
         {
            DeptToCADocHistCache = new ObjectHashtable();
            for (Enumeration e = (R_CA_DOC_HISTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToCADocHistCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToCADocHistCache.elements());
         }
         else
         {
         
            return (R_CA_DOC_HISTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_AP_DISB_EXCP objects for this R_DEPT
      * old R_AP_DISB_EXCP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_AP_DISB_EXCP objects.
      */
  public Enumeration getOldDeptToDisbExcp(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToDisbExcp");
    if (cache)
      getSession().setProperty("NoCacheDeptToDisbExcp", "false");
    else
      getSession().setProperty("NoCacheDeptToDisbExcp", "true");

    try {
      return getOldDeptToDisbExcp();
    } finally {
        getSession().setProperty("NoCacheDeptToDisbExcp", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_AP_DISB_EXCP objects for this R_DEPT
      * old R_AP_DISB_EXCP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_AP_DISB_EXCP objects.
      */
      public Enumeration   getOldDeptToDisbExcp()
      {
         
         if (!getSession().getProperty("NoCacheDeptToDisbExcp").equals("true"))
         
         {
            if ( DeptToDisbExcpCache != null ) return DeptToDisbExcpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_AP_DISB_EXCP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDisbExcp").equals("true"))
         {
            DeptToDisbExcpCache = new ObjectHashtable();
            for (Enumeration e = (R_AP_DISB_EXCPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDisbExcpCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDisbExcpCache.elements());
         }
         else
         {
         
            return (R_AP_DISB_EXCPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_ACLS objects for this R_DEPT
      * old R_ACLS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_ACLS objects.
      */
  public Enumeration getOldR_ACLSs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_ACLSs1");
    if (cache)
      getSession().setProperty("NoCacheR_ACLSs1", "false");
    else
      getSession().setProperty("NoCacheR_ACLSs1", "true");

    try {
      return getOldR_ACLSs1();
    } finally {
        getSession().setProperty("NoCacheR_ACLSs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_ACLS objects for this R_DEPT
      * old R_ACLS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_ACLS objects.
      */
      public Enumeration   getOldR_ACLSs1()
      {
         
         if (!getSession().getProperty("NoCacheR_ACLSs1").equals("true"))
         
         {
            if ( R_ACLSs1Cache != null ) return R_ACLSs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ACLS";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_ACLSs1").equals("true"))
         {
            R_ACLSs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_ACLSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_ACLSs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_ACLSs1Cache.elements());
         }
         else
         {
         
            return (R_ACLSBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old ELEC_FED_TAXP_SYS objects for this R_DEPT
      * old ELEC_FED_TAXP_SYS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old ELEC_FED_TAXP_SYS objects.
      */
  public Enumeration getOldDepartmentToElectronicFederalTaxPaymentSystem(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDepartmentToElectronicFederalTaxPaymentSystem");
    if (cache)
      getSession().setProperty("NoCacheDepartmentToElectronicFederalTaxPaymentSystem", "false");
    else
      getSession().setProperty("NoCacheDepartmentToElectronicFederalTaxPaymentSystem", "true");

    try {
      return getOldDepartmentToElectronicFederalTaxPaymentSystem();
    } finally {
        getSession().setProperty("NoCacheDepartmentToElectronicFederalTaxPaymentSystem", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old ELEC_FED_TAXP_SYS objects for this R_DEPT
      * old ELEC_FED_TAXP_SYS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old ELEC_FED_TAXP_SYS objects.
      */
      public Enumeration   getOldDepartmentToElectronicFederalTaxPaymentSystem()
      {
         
         if (!getSession().getProperty("NoCacheDepartmentToElectronicFederalTaxPaymentSystem").equals("true"))
         
         {
            if ( DepartmentToElectronicFederalTaxPaymentSystemCache != null ) return DepartmentToElectronicFederalTaxPaymentSystemCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ELEC_FED_TAXP_SYS";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDepartmentToElectronicFederalTaxPaymentSystem").equals("true"))
         {
            DepartmentToElectronicFederalTaxPaymentSystemCache = new ObjectHashtable();
            for (Enumeration e = (ELEC_FED_TAXP_SYSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DepartmentToElectronicFederalTaxPaymentSystemCache.put(pkey,cacheBO);                        
            }
         
            return (DepartmentToElectronicFederalTaxPaymentSystemCache.elements());
         }
         else
         {
         
            return (ELEC_FED_TAXP_SYSBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old ACRL_CLR_MGMT objects for this R_DEPT
      * old ACRL_CLR_MGMT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old ACRL_CLR_MGMT objects.
      */
  public Enumeration getOldACRL_CLR_MGMT_1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheACRL_CLR_MGMT_1");
    if (cache)
      getSession().setProperty("NoCacheACRL_CLR_MGMT_1", "false");
    else
      getSession().setProperty("NoCacheACRL_CLR_MGMT_1", "true");

    try {
      return getOldACRL_CLR_MGMT_1();
    } finally {
        getSession().setProperty("NoCacheACRL_CLR_MGMT_1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old ACRL_CLR_MGMT objects for this R_DEPT
      * old ACRL_CLR_MGMT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old ACRL_CLR_MGMT objects.
      */
      public Enumeration   getOldACRL_CLR_MGMT_1()
      {
         
         if (!getSession().getProperty("NoCacheACRL_CLR_MGMT_1").equals("true"))
         
         {
            if ( ACRL_CLR_MGMT_1Cache != null ) return ACRL_CLR_MGMT_1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ACRL_CLR_MGMT";
            param.fieldName = "DOC_ACTG_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheACRL_CLR_MGMT_1").equals("true"))
         {
            ACRL_CLR_MGMT_1Cache = new ObjectHashtable();
            for (Enumeration e = (ACRL_CLR_MGMTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ACRL_CLR_MGMT_1Cache.put(pkey,cacheBO);                        
            }
         
            return (ACRL_CLR_MGMT_1Cache.elements());
         }
         else
         {
         
            return (ACRL_CLR_MGMTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_SECT objects for this R_DEPT
      * old R_SECT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_SECT objects.
      */
  public Enumeration getOldR_SECTs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_SECTs1");
    if (cache)
      getSession().setProperty("NoCacheR_SECTs1", "false");
    else
      getSession().setProperty("NoCacheR_SECTs1", "true");

    try {
      return getOldR_SECTs1();
    } finally {
        getSession().setProperty("NoCacheR_SECTs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_SECT objects for this R_DEPT
      * old R_SECT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_SECT objects.
      */
      public Enumeration   getOldR_SECTs1()
      {
         
         if (!getSession().getProperty("NoCacheR_SECTs1").equals("true"))
         
         {
            if ( R_SECTs1Cache != null ) return R_SECTs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_SECT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_SECTs1").equals("true"))
         {
            R_SECTs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_SECTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_SECTs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_SECTs1Cache.elements());
         }
         else
         {
         
            return (R_SECTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PROG_DOC_CRSREF objects for this R_DEPT
      * old R_PROG_DOC_CRSREF objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PROG_DOC_CRSREF objects.
      */
  public Enumeration getOldPrgDocCrsRef1ToDept_1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCachePrgDocCrsRef1ToDept_1");
    if (cache)
      getSession().setProperty("NoCachePrgDocCrsRef1ToDept_1", "false");
    else
      getSession().setProperty("NoCachePrgDocCrsRef1ToDept_1", "true");

    try {
      return getOldPrgDocCrsRef1ToDept_1();
    } finally {
        getSession().setProperty("NoCachePrgDocCrsRef1ToDept_1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PROG_DOC_CRSREF objects for this R_DEPT
      * old R_PROG_DOC_CRSREF objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PROG_DOC_CRSREF objects.
      */
      public Enumeration   getOldPrgDocCrsRef1ToDept_1()
      {
         
         if (!getSession().getProperty("NoCachePrgDocCrsRef1ToDept_1").equals("true"))
         
         {
            if ( PrgDocCrsRef1ToDept_1Cache != null ) return PrgDocCrsRef1ToDept_1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PROG_DOC_CRSREF";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCachePrgDocCrsRef1ToDept_1").equals("true"))
         {
            PrgDocCrsRef1ToDept_1Cache = new ObjectHashtable();
            for (Enumeration e = (R_PROG_DOC_CRSREFBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               PrgDocCrsRef1ToDept_1Cache.put(pkey,cacheBO);                        
            }
         
            return (PrgDocCrsRef1ToDept_1Cache.elements());
         }
         else
         {
         
            return (R_PROG_DOC_CRSREFBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_INTR_ACTG_CRSWLK objects for this R_DEPT
      * old R_INTR_ACTG_CRSWLK objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_INTR_ACTG_CRSWLK objects.
      */
  public Enumeration getOldIntrActgToDept(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheIntrActgToDept");
    if (cache)
      getSession().setProperty("NoCacheIntrActgToDept", "false");
    else
      getSession().setProperty("NoCacheIntrActgToDept", "true");

    try {
      return getOldIntrActgToDept();
    } finally {
        getSession().setProperty("NoCacheIntrActgToDept", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_INTR_ACTG_CRSWLK objects for this R_DEPT
      * old R_INTR_ACTG_CRSWLK objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_INTR_ACTG_CRSWLK objects.
      */
      public Enumeration   getOldIntrActgToDept()
      {
         
         if (!getSession().getProperty("NoCacheIntrActgToDept").equals("true"))
         
         {
            if ( IntrActgToDeptCache != null ) return IntrActgToDeptCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_INTR_ACTG_CRSWLK";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheIntrActgToDept").equals("true"))
         {
            IntrActgToDeptCache = new ObjectHashtable();
            for (Enumeration e = (R_INTR_ACTG_CRSWLKBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               IntrActgToDeptCache.put(pkey,cacheBO);                        
            }
         
            return (IntrActgToDeptCache.elements());
         }
         else
         {
         
            return (R_INTR_ACTG_CRSWLKBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DOTYP objects for this R_DEPT
      * old R_DOTYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DOTYP objects.
      */
  public Enumeration getOldR_DOTYPs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_DOTYPs1");
    if (cache)
      getSession().setProperty("NoCacheR_DOTYPs1", "false");
    else
      getSession().setProperty("NoCacheR_DOTYPs1", "true");

    try {
      return getOldR_DOTYPs1();
    } finally {
        getSession().setProperty("NoCacheR_DOTYPs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DOTYP objects for this R_DEPT
      * old R_DOTYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DOTYP objects.
      */
      public Enumeration   getOldR_DOTYPs1()
      {
         
         if (!getSession().getProperty("NoCacheR_DOTYPs1").equals("true"))
         
         {
            if ( R_DOTYPs1Cache != null ) return R_DOTYPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DOTYP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DOTYPs1").equals("true"))
         {
            R_DOTYPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DOTYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DOTYPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DOTYPs1Cache.elements());
         }
         else
         {
         
            return (R_DOTYPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old MA_DOC_HDR objects for this R_DEPT
      * old MA_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old MA_DOC_HDR objects.
      */
  public Enumeration getOldRqstDeptToMaDocHdr(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRqstDeptToMaDocHdr");
    if (cache)
      getSession().setProperty("NoCacheRqstDeptToMaDocHdr", "false");
    else
      getSession().setProperty("NoCacheRqstDeptToMaDocHdr", "true");

    try {
      return getOldRqstDeptToMaDocHdr();
    } finally {
        getSession().setProperty("NoCacheRqstDeptToMaDocHdr", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old MA_DOC_HDR objects for this R_DEPT
      * old MA_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old MA_DOC_HDR objects.
      */
      public Enumeration   getOldRqstDeptToMaDocHdr()
      {
         
         if (!getSession().getProperty("NoCacheRqstDeptToMaDocHdr").equals("true"))
         
         {
            if ( RqstDeptToMaDocHdrCache != null ) return RqstDeptToMaDocHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "MA_DOC_HDR";
            param.fieldName = "RQSTR_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRqstDeptToMaDocHdr").equals("true"))
         {
            RqstDeptToMaDocHdrCache = new ObjectHashtable();
            for (Enumeration e = (MA_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RqstDeptToMaDocHdrCache.put(pkey,cacheBO);                        
            }
         
            return (RqstDeptToMaDocHdrCache.elements());
         }
         else
         {
         
            return (MA_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_APPR2 objects for this R_DEPT
      * old INF_APPR2 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_APPR2 objects.
      */
  public Enumeration getOldDeptToInfAppr2(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToInfAppr2");
    if (cache)
      getSession().setProperty("NoCacheDeptToInfAppr2", "false");
    else
      getSession().setProperty("NoCacheDeptToInfAppr2", "true");

    try {
      return getOldDeptToInfAppr2();
    } finally {
        getSession().setProperty("NoCacheDeptToInfAppr2", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_APPR2 objects for this R_DEPT
      * old INF_APPR2 objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_APPR2 objects.
      */
      public Enumeration   getOldDeptToInfAppr2()
      {
         
         if (!getSession().getProperty("NoCacheDeptToInfAppr2").equals("true"))
         
         {
            if ( DeptToInfAppr2Cache != null ) return DeptToInfAppr2Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_APPR2";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfAppr2").equals("true"))
         {
            DeptToInfAppr2Cache = new ObjectHashtable();
            for (Enumeration e = (INF_APPR2BaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfAppr2Cache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfAppr2Cache.elements());
         }
         else
         {
         
            return (INF_APPR2BaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old GR_DOC_HDR objects for this R_DEPT
      * old GR_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old GR_DOC_HDR objects.
      */
  public Enumeration getOldDeptToGRDocHdr(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToGRDocHdr");
    if (cache)
      getSession().setProperty("NoCacheDeptToGRDocHdr", "false");
    else
      getSession().setProperty("NoCacheDeptToGRDocHdr", "true");

    try {
      return getOldDeptToGRDocHdr();
    } finally {
        getSession().setProperty("NoCacheDeptToGRDocHdr", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old GR_DOC_HDR objects for this R_DEPT
      * old GR_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old GR_DOC_HDR objects.
      */
      public Enumeration   getOldDeptToGRDocHdr()
      {
         
         if (!getSession().getProperty("NoCacheDeptToGRDocHdr").equals("true"))
         
         {
            if ( DeptToGRDocHdrCache != null ) return DeptToGRDocHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GR_DOC_HDR";
            param.fieldName = "RQSTR_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToGRDocHdr").equals("true"))
         {
            DeptToGRDocHdrCache = new ObjectHashtable();
            for (Enumeration e = (GR_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToGRDocHdrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToGRDocHdrCache.elements());
         }
         else
         {
         
            return (GR_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old DEBT_DOC_AUTH objects for this R_DEPT
      * old DEBT_DOC_AUTH objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old DEBT_DOC_AUTH objects.
      */
  public Enumeration getOldDeptToDebtDocAuth(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToDebtDocAuth");
    if (cache)
      getSession().setProperty("NoCacheDeptToDebtDocAuth", "false");
    else
      getSession().setProperty("NoCacheDeptToDebtDocAuth", "true");

    try {
      return getOldDeptToDebtDocAuth();
    } finally {
        getSession().setProperty("NoCacheDeptToDebtDocAuth", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old DEBT_DOC_AUTH objects for this R_DEPT
      * old DEBT_DOC_AUTH objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old DEBT_DOC_AUTH objects.
      */
      public Enumeration   getOldDeptToDebtDocAuth()
      {
         
         if (!getSession().getProperty("NoCacheDeptToDebtDocAuth").equals("true"))
         
         {
            if ( DeptToDebtDocAuthCache != null ) return DeptToDebtDocAuthCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "DEBT_DOC_AUTH";
            param.fieldName = "RESP_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDebtDocAuth").equals("true"))
         {
            DeptToDebtDocAuthCache = new ObjectHashtable();
            for (Enumeration e = (DEBT_DOC_AUTHBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDebtDocAuthCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDebtDocAuthCache.elements());
         }
         else
         {
         
            return (DEBT_DOC_AUTHBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old AUTO_PART_NO objects for this R_DEPT
      * old AUTO_PART_NO objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old AUTO_PART_NO objects.
      */
  public Enumeration getOldDeptToAutoPartNo(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToAutoPartNo");
    if (cache)
      getSession().setProperty("NoCacheDeptToAutoPartNo", "false");
    else
      getSession().setProperty("NoCacheDeptToAutoPartNo", "true");

    try {
      return getOldDeptToAutoPartNo();
    } finally {
        getSession().setProperty("NoCacheDeptToAutoPartNo", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old AUTO_PART_NO objects for this R_DEPT
      * old AUTO_PART_NO objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old AUTO_PART_NO objects.
      */
      public Enumeration   getOldDeptToAutoPartNo()
      {
         
         if (!getSession().getProperty("NoCacheDeptToAutoPartNo").equals("true"))
         
         {
            if ( DeptToAutoPartNoCache != null ) return DeptToAutoPartNoCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "AUTO_PART_NO";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToAutoPartNo").equals("true"))
         {
            DeptToAutoPartNoCache = new ObjectHashtable();
            for (Enumeration e = (AUTO_PART_NOBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToAutoPartNoCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToAutoPartNoCache.elements());
         }
         else
         {
         
            return (AUTO_PART_NOBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old AD_DOC_HDR objects for this R_DEPT
      * old AD_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old AD_DOC_HDR objects.
      */
  public Enumeration getOldDeptToADHdr(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToADHdr");
    if (cache)
      getSession().setProperty("NoCacheDeptToADHdr", "false");
    else
      getSession().setProperty("NoCacheDeptToADHdr", "true");

    try {
      return getOldDeptToADHdr();
    } finally {
        getSession().setProperty("NoCacheDeptToADHdr", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old AD_DOC_HDR objects for this R_DEPT
      * old AD_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old AD_DOC_HDR objects.
      */
      public Enumeration   getOldDeptToADHdr()
      {
         
         if (!getSession().getProperty("NoCacheDeptToADHdr").equals("true"))
         
         {
            if ( DeptToADHdrCache != null ) return DeptToADHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "AD_DOC_HDR";
            param.fieldName = "PY_HLD_TYP_DEPT_DC";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToADHdr").equals("true"))
         {
            DeptToADHdrCache = new ObjectHashtable();
            for (Enumeration e = (AD_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToADHdrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToADHdrCache.elements());
         }
         else
         {
         
            return (AD_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old RCLS_PARM_DTL objects for this R_DEPT
      * old RCLS_PARM_DTL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old RCLS_PARM_DTL objects.
      */
  public Enumeration getOldRCLS_PARM_DTL1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRCLS_PARM_DTL1");
    if (cache)
      getSession().setProperty("NoCacheRCLS_PARM_DTL1", "false");
    else
      getSession().setProperty("NoCacheRCLS_PARM_DTL1", "true");

    try {
      return getOldRCLS_PARM_DTL1();
    } finally {
        getSession().setProperty("NoCacheRCLS_PARM_DTL1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old RCLS_PARM_DTL objects for this R_DEPT
      * old RCLS_PARM_DTL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old RCLS_PARM_DTL objects.
      */
      public Enumeration   getOldRCLS_PARM_DTL1()
      {
         
         if (!getSession().getProperty("NoCacheRCLS_PARM_DTL1").equals("true"))
         
         {
            if ( RCLS_PARM_DTL1Cache != null ) return RCLS_PARM_DTL1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "RCLS_PARM_DTL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRCLS_PARM_DTL1").equals("true"))
         {
            RCLS_PARM_DTL1Cache = new ObjectHashtable();
            for (Enumeration e = (RCLS_PARM_DTLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RCLS_PARM_DTL1Cache.put(pkey,cacheBO);                        
            }
         
            return (RCLS_PARM_DTL1Cache.elements());
         }
         else
         {
         
            return (RCLS_PARM_DTLBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_VEND_CUST objects for this R_DEPT
      * old R_VEND_CUST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_VEND_CUST objects.
      */
  public Enumeration getOldDeptToVcust(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToVcust");
    if (cache)
      getSession().setProperty("NoCacheDeptToVcust", "false");
    else
      getSession().setProperty("NoCacheDeptToVcust", "true");

    try {
      return getOldDeptToVcust();
    } finally {
        getSession().setProperty("NoCacheDeptToVcust", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_VEND_CUST objects for this R_DEPT
      * old R_VEND_CUST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_VEND_CUST objects.
      */
      public Enumeration   getOldDeptToVcust()
      {
         
         if (!getSession().getProperty("NoCacheDeptToVcust").equals("true"))
         
         {
            if ( DeptToVcustCache != null ) return DeptToVcustCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_VEND_CUST";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToVcust").equals("true"))
         {
            DeptToVcustCache = new ObjectHashtable();
            for (Enumeration e = (R_VEND_CUSTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToVcustCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToVcustCache.elements());
         }
         else
         {
         
            return (R_VEND_CUSTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_MSMALS objects for this R_DEPT
      * old R_MSMALS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_MSMALS objects.
      */
  public Enumeration getOldDeptToMsmals(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToMsmals");
    if (cache)
      getSession().setProperty("NoCacheDeptToMsmals", "false");
    else
      getSession().setProperty("NoCacheDeptToMsmals", "true");

    try {
      return getOldDeptToMsmals();
    } finally {
        getSession().setProperty("NoCacheDeptToMsmals", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_MSMALS objects for this R_DEPT
      * old R_MSMALS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_MSMALS objects.
      */
      public Enumeration   getOldDeptToMsmals()
      {
         
         if (!getSession().getProperty("NoCacheDeptToMsmals").equals("true"))
         
         {
            if ( DeptToMsmalsCache != null ) return DeptToMsmalsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_MSMALS";
            param.fieldName = "AUTH_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToMsmals").equals("true"))
         {
            DeptToMsmalsCache = new ObjectHashtable();
            for (Enumeration e = (R_MSMALSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToMsmalsCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToMsmalsCache.elements());
         }
         else
         {
         
            return (R_MSMALSBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_INT_CST_PARM objects for this R_DEPT
      * old R_INT_CST_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_INT_CST_PARM objects.
      */
  public Enumeration getOldRDeptToRIntCst(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRIntCst");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRIntCst", "false");
    else
      getSession().setProperty("NoCacheRDeptToRIntCst", "true");

    try {
      return getOldRDeptToRIntCst();
    } finally {
        getSession().setProperty("NoCacheRDeptToRIntCst", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_INT_CST_PARM objects for this R_DEPT
      * old R_INT_CST_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_INT_CST_PARM objects.
      */
      public Enumeration   getOldRDeptToRIntCst()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRIntCst").equals("true"))
         
         {
            if ( RDeptToRIntCstCache != null ) return RDeptToRIntCstCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_INT_CST_PARM";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRIntCst").equals("true"))
         {
            RDeptToRIntCstCache = new ObjectHashtable();
            for (Enumeration e = (R_INT_CST_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRIntCstCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRIntCstCache.elements());
         }
         else
         {
         
            return (R_INT_CST_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FUNC objects for this R_DEPT
      * old R_FUNC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FUNC objects.
      */
  public Enumeration getOldR_FUNCs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_FUNCs1");
    if (cache)
      getSession().setProperty("NoCacheR_FUNCs1", "false");
    else
      getSession().setProperty("NoCacheR_FUNCs1", "true");

    try {
      return getOldR_FUNCs1();
    } finally {
        getSession().setProperty("NoCacheR_FUNCs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FUNC objects for this R_DEPT
      * old R_FUNC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FUNC objects.
      */
      public Enumeration   getOldR_FUNCs1()
      {
         
         if (!getSession().getProperty("NoCacheR_FUNCs1").equals("true"))
         
         {
            if ( R_FUNCs1Cache != null ) return R_FUNCs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FUNC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_FUNCs1").equals("true"))
         {
            R_FUNCs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_FUNCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_FUNCs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_FUNCs1Cache.elements());
         }
         else
         {
         
            return (R_FUNCBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FAC objects for this R_DEPT
      * old R_FAC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FAC objects.
      */
  public Enumeration getOldRDeptToRFac(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRFac");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRFac", "false");
    else
      getSession().setProperty("NoCacheRDeptToRFac", "true");

    try {
      return getOldRDeptToRFac();
    } finally {
        getSession().setProperty("NoCacheRDeptToRFac", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FAC objects for this R_DEPT
      * old R_FAC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FAC objects.
      */
      public Enumeration   getOldRDeptToRFac()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRFac").equals("true"))
         
         {
            if ( RDeptToRFacCache != null ) return RDeptToRFacCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FAC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRFac").equals("true"))
         {
            RDeptToRFacCache = new ObjectHashtable();
            for (Enumeration e = (R_FACBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRFacCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRFacCache.elements());
         }
         else
         {
         
            return (R_FACBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_EMP_INFO objects for this R_DEPT
      * old R_EMP_INFO objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_EMP_INFO objects.
      */
  public Enumeration getOldRDeptToREmpInfo(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToREmpInfo");
    if (cache)
      getSession().setProperty("NoCacheRDeptToREmpInfo", "false");
    else
      getSession().setProperty("NoCacheRDeptToREmpInfo", "true");

    try {
      return getOldRDeptToREmpInfo();
    } finally {
        getSession().setProperty("NoCacheRDeptToREmpInfo", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_EMP_INFO objects for this R_DEPT
      * old R_EMP_INFO objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_EMP_INFO objects.
      */
      public Enumeration   getOldRDeptToREmpInfo()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToREmpInfo").equals("true"))
         
         {
            if ( RDeptToREmpInfoCache != null ) return RDeptToREmpInfoCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_EMP_INFO";
            param.fieldName = "EMP_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToREmpInfo").equals("true"))
         {
            RDeptToREmpInfoCache = new ObjectHashtable();
            for (Enumeration e = (R_EMP_INFOBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToREmpInfoCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToREmpInfoCache.elements());
         }
         else
         {
         
            return (R_EMP_INFOBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DEPT_TRVLXP_POL objects for this R_DEPT
      * old R_DEPT_TRVLXP_POL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DEPT_TRVLXP_POL objects.
      */
  public Enumeration getOldDeptToDeptTrvlxpPol(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToDeptTrvlxpPol");
    if (cache)
      getSession().setProperty("NoCacheDeptToDeptTrvlxpPol", "false");
    else
      getSession().setProperty("NoCacheDeptToDeptTrvlxpPol", "true");

    try {
      return getOldDeptToDeptTrvlxpPol();
    } finally {
        getSession().setProperty("NoCacheDeptToDeptTrvlxpPol", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DEPT_TRVLXP_POL objects for this R_DEPT
      * old R_DEPT_TRVLXP_POL objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DEPT_TRVLXP_POL objects.
      */
      public Enumeration   getOldDeptToDeptTrvlxpPol()
      {
         
         if (!getSession().getProperty("NoCacheDeptToDeptTrvlxpPol").equals("true"))
         
         {
            if ( DeptToDeptTrvlxpPolCache != null ) return DeptToDeptTrvlxpPolCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DEPT_TRVLXP_POL";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDeptTrvlxpPol").equals("true"))
         {
            DeptToDeptTrvlxpPolCache = new ObjectHashtable();
            for (Enumeration e = (R_DEPT_TRVLXP_POLBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDeptTrvlxpPolCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDeptTrvlxpPolCache.elements());
         }
         else
         {
         
            return (R_DEPT_TRVLXP_POLBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DEBT_DEBTINST objects for this R_DEPT
      * old R_DEBT_DEBTINST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DEBT_DEBTINST objects.
      */
  public Enumeration getOldDeptToDebtDebtInst(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToDebtDebtInst");
    if (cache)
      getSession().setProperty("NoCacheDeptToDebtDebtInst", "false");
    else
      getSession().setProperty("NoCacheDeptToDebtDebtInst", "true");

    try {
      return getOldDeptToDebtDebtInst();
    } finally {
        getSession().setProperty("NoCacheDeptToDebtDebtInst", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DEBT_DEBTINST objects for this R_DEPT
      * old R_DEBT_DEBTINST objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DEBT_DEBTINST objects.
      */
      public Enumeration   getOldDeptToDebtDebtInst()
      {
         
         if (!getSession().getProperty("NoCacheDeptToDebtDebtInst").equals("true"))
         
         {
            if ( DeptToDebtDebtInstCache != null ) return DeptToDebtDebtInstCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DEBT_DEBTINST";
            param.fieldName = "RESP_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToDebtDebtInst").equals("true"))
         {
            DeptToDebtDebtInstCache = new ObjectHashtable();
            for (Enumeration e = (R_DEBT_DEBTINSTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToDebtDebtInstCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToDebtDebtInstCache.elements());
         }
         else
         {
         
            return (R_DEBT_DEBTINSTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_CNTRC_GOAL_HDR objects for this R_DEPT
      * old R_CNTRC_GOAL_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_CNTRC_GOAL_HDR objects.
      */
  public Enumeration getOldRDeptToRCntrcGlhd(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRCntrcGlhd");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRCntrcGlhd", "false");
    else
      getSession().setProperty("NoCacheRDeptToRCntrcGlhd", "true");

    try {
      return getOldRDeptToRCntrcGlhd();
    } finally {
        getSession().setProperty("NoCacheRDeptToRCntrcGlhd", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_CNTRC_GOAL_HDR objects for this R_DEPT
      * old R_CNTRC_GOAL_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_CNTRC_GOAL_HDR objects.
      */
      public Enumeration   getOldRDeptToRCntrcGlhd()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRCntrcGlhd").equals("true"))
         
         {
            if ( RDeptToRCntrcGlhdCache != null ) return RDeptToRCntrcGlhdCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CNTRC_GOAL_HDR";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRCntrcGlhd").equals("true"))
         {
            RDeptToRCntrcGlhdCache = new ObjectHashtable();
            for (Enumeration e = (R_CNTRC_GOAL_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRCntrcGlhdCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRCntrcGlhdCache.elements());
         }
         else
         {
         
            return (R_CNTRC_GOAL_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old ACRL_CLR_MGMT objects for this R_DEPT
      * old ACRL_CLR_MGMT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old ACRL_CLR_MGMT objects.
      */
  public Enumeration getOldACRL_CLR_MGMT(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheACRL_CLR_MGMT");
    if (cache)
      getSession().setProperty("NoCacheACRL_CLR_MGMT", "false");
    else
      getSession().setProperty("NoCacheACRL_CLR_MGMT", "true");

    try {
      return getOldACRL_CLR_MGMT();
    } finally {
        getSession().setProperty("NoCacheACRL_CLR_MGMT", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old ACRL_CLR_MGMT objects for this R_DEPT
      * old ACRL_CLR_MGMT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old ACRL_CLR_MGMT objects.
      */
      public Enumeration   getOldACRL_CLR_MGMT()
      {
         
         if (!getSession().getProperty("NoCacheACRL_CLR_MGMT").equals("true"))
         
         {
            if ( ACRL_CLR_MGMTCache != null ) return ACRL_CLR_MGMTCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ACRL_CLR_MGMT";
            param.fieldName = "DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheACRL_CLR_MGMT").equals("true"))
         {
            ACRL_CLR_MGMTCache = new ObjectHashtable();
            for (Enumeration e = (ACRL_CLR_MGMTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               ACRL_CLR_MGMTCache.put(pkey,cacheBO);                        
            }
         
            return (ACRL_CLR_MGMTCache.elements());
         }
         else
         {
         
            return (ACRL_CLR_MGMTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old ABS_DOC_HDR objects for this R_DEPT
      * old ABS_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old ABS_DOC_HDR objects.
      */
  public Enumeration getOldDeptToABSHdr(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToABSHdr");
    if (cache)
      getSession().setProperty("NoCacheDeptToABSHdr", "false");
    else
      getSession().setProperty("NoCacheDeptToABSHdr", "true");

    try {
      return getOldDeptToABSHdr();
    } finally {
        getSession().setProperty("NoCacheDeptToABSHdr", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old ABS_DOC_HDR objects for this R_DEPT
      * old ABS_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old ABS_DOC_HDR objects.
      */
      public Enumeration   getOldDeptToABSHdr()
      {
         
         if (!getSession().getProperty("NoCacheDeptToABSHdr").equals("true"))
         
         {
            if ( DeptToABSHdrCache != null ) return DeptToABSHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ABS_DOC_HDR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToABSHdr").equals("true"))
         {
            DeptToABSHdrCache = new ObjectHashtable();
            for (Enumeration e = (ABS_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToABSHdrCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToABSHdrCache.elements());
         }
         else
         {
         
            return (ABS_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old TRVL_DOC_VEND objects for this R_DEPT
      * old TRVL_DOC_VEND objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old TRVL_DOC_VEND objects.
      */
  public Enumeration getOldDeptToTrvlDocVend(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToTrvlDocVend");
    if (cache)
      getSession().setProperty("NoCacheDeptToTrvlDocVend", "false");
    else
      getSession().setProperty("NoCacheDeptToTrvlDocVend", "true");

    try {
      return getOldDeptToTrvlDocVend();
    } finally {
        getSession().setProperty("NoCacheDeptToTrvlDocVend", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old TRVL_DOC_VEND objects for this R_DEPT
      * old TRVL_DOC_VEND objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old TRVL_DOC_VEND objects.
      */
      public Enumeration   getOldDeptToTrvlDocVend()
      {
         
         if (!getSession().getProperty("NoCacheDeptToTrvlDocVend").equals("true"))
         
         {
            if ( DeptToTrvlDocVendCache != null ) return DeptToTrvlDocVendCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "TRVL_DOC_VEND";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToTrvlDocVend").equals("true"))
         {
            DeptToTrvlDocVendCache = new ObjectHashtable();
            for (Enumeration e = (TRVL_DOC_VENDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToTrvlDocVendCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToTrvlDocVendCache.elements());
         }
         else
         {
         
            return (TRVL_DOC_VENDBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_REIM_FREQ_DT objects for this R_DEPT
      * old R_REIM_FREQ_DT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_REIM_FREQ_DT objects.
      */
  public Enumeration getOldR_REIM_FREQ_DTs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_REIM_FREQ_DTs1");
    if (cache)
      getSession().setProperty("NoCacheR_REIM_FREQ_DTs1", "false");
    else
      getSession().setProperty("NoCacheR_REIM_FREQ_DTs1", "true");

    try {
      return getOldR_REIM_FREQ_DTs1();
    } finally {
        getSession().setProperty("NoCacheR_REIM_FREQ_DTs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_REIM_FREQ_DT objects for this R_DEPT
      * old R_REIM_FREQ_DT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_REIM_FREQ_DT objects.
      */
      public Enumeration   getOldR_REIM_FREQ_DTs1()
      {
         
         if (!getSession().getProperty("NoCacheR_REIM_FREQ_DTs1").equals("true"))
         
         {
            if ( R_REIM_FREQ_DTs1Cache != null ) return R_REIM_FREQ_DTs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_REIM_FREQ_DT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_REIM_FREQ_DTs1").equals("true"))
         {
            R_REIM_FREQ_DTs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_REIM_FREQ_DTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_REIM_FREQ_DTs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_REIM_FREQ_DTs1Cache.elements());
         }
         else
         {
         
            return (R_REIM_FREQ_DTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_OTPT_PARM_DET objects for this R_DEPT
      * old R_OTPT_PARM_DET objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_OTPT_PARM_DET objects.
      */
  public Enumeration getOldR_OTPT_PARM_DETs5(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_OTPT_PARM_DETs5");
    if (cache)
      getSession().setProperty("NoCacheR_OTPT_PARM_DETs5", "false");
    else
      getSession().setProperty("NoCacheR_OTPT_PARM_DETs5", "true");

    try {
      return getOldR_OTPT_PARM_DETs5();
    } finally {
        getSession().setProperty("NoCacheR_OTPT_PARM_DETs5", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_OTPT_PARM_DET objects for this R_DEPT
      * old R_OTPT_PARM_DET objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_OTPT_PARM_DET objects.
      */
      public Enumeration   getOldR_OTPT_PARM_DETs5()
      {
         
         if (!getSession().getProperty("NoCacheR_OTPT_PARM_DETs5").equals("true"))
         
         {
            if ( R_OTPT_PARM_DETs5Cache != null ) return R_OTPT_PARM_DETs5Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_OTPT_PARM_DET";
            param.fieldName = "IET_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_OTPT_PARM_DETs5").equals("true"))
         {
            R_OTPT_PARM_DETs5Cache = new ObjectHashtable();
            for (Enumeration e = (R_OTPT_PARM_DETBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_OTPT_PARM_DETs5Cache.put(pkey,cacheBO);                        
            }
         
            return (R_OTPT_PARM_DETs5Cache.elements());
         }
         else
         {
         
            return (R_OTPT_PARM_DETBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_MGR objects for this R_DEPT
      * old R_MGR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_MGR objects.
      */
  public Enumeration getOldR_MGR(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_MGR");
    if (cache)
      getSession().setProperty("NoCacheR_MGR", "false");
    else
      getSession().setProperty("NoCacheR_MGR", "true");

    try {
      return getOldR_MGR();
    } finally {
        getSession().setProperty("NoCacheR_MGR", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_MGR objects for this R_DEPT
      * old R_MGR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_MGR objects.
      */
      public Enumeration   getOldR_MGR()
      {
         
         if (!getSession().getProperty("NoCacheR_MGR").equals("true"))
         
         {
            if ( R_MGRCache != null ) return R_MGRCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_MGR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_MGR").equals("true"))
         {
            R_MGRCache = new ObjectHashtable();
            for (Enumeration e = (R_MGRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_MGRCache.put(pkey,cacheBO);                        
            }
         
            return (R_MGRCache.elements());
         }
         else
         {
         
            return (R_MGRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_GP objects for this R_DEPT
      * old R_GP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_GP objects.
      */
  public Enumeration getOldR_GPs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_GPs1");
    if (cache)
      getSession().setProperty("NoCacheR_GPs1", "false");
    else
      getSession().setProperty("NoCacheR_GPs1", "true");

    try {
      return getOldR_GPs1();
    } finally {
        getSession().setProperty("NoCacheR_GPs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_GP objects for this R_DEPT
      * old R_GP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_GP objects.
      */
      public Enumeration   getOldR_GPs1()
      {
         
         if (!getSession().getProperty("NoCacheR_GPs1").equals("true"))
         
         {
            if ( R_GPs1Cache != null ) return R_GPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_GPs1").equals("true"))
         {
            R_GPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_GPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_GPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_GPs1Cache.elements());
         }
         else
         {
         
            return (R_GPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_EMPL_BEN_MULTI objects for this R_DEPT
      * old R_EMPL_BEN_MULTI objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_EMPL_BEN_MULTI objects.
      */
  public Enumeration getOldRDeptToREmplBenMulti(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToREmplBenMulti");
    if (cache)
      getSession().setProperty("NoCacheRDeptToREmplBenMulti", "false");
    else
      getSession().setProperty("NoCacheRDeptToREmplBenMulti", "true");

    try {
      return getOldRDeptToREmplBenMulti();
    } finally {
        getSession().setProperty("NoCacheRDeptToREmplBenMulti", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_EMPL_BEN_MULTI objects for this R_DEPT
      * old R_EMPL_BEN_MULTI objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_EMPL_BEN_MULTI objects.
      */
      public Enumeration   getOldRDeptToREmplBenMulti()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToREmplBenMulti").equals("true"))
         
         {
            if ( RDeptToREmplBenMultiCache != null ) return RDeptToREmplBenMultiCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_EMPL_BEN_MULTI";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToREmplBenMulti").equals("true"))
         {
            RDeptToREmplBenMultiCache = new ObjectHashtable();
            for (Enumeration e = (R_EMPL_BEN_MULTIBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToREmplBenMultiCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToREmplBenMultiCache.elements());
         }
         else
         {
         
            return (R_EMPL_BEN_MULTIBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DRSGRP objects for this R_DEPT
      * old R_DRSGRP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DRSGRP objects.
      */
  public Enumeration getOldR_DRSGRPs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_DRSGRPs1");
    if (cache)
      getSession().setProperty("NoCacheR_DRSGRPs1", "false");
    else
      getSession().setProperty("NoCacheR_DRSGRPs1", "true");

    try {
      return getOldR_DRSGRPs1();
    } finally {
        getSession().setProperty("NoCacheR_DRSGRPs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DRSGRP objects for this R_DEPT
      * old R_DRSGRP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DRSGRP objects.
      */
      public Enumeration   getOldR_DRSGRPs1()
      {
         
         if (!getSession().getProperty("NoCacheR_DRSGRPs1").equals("true"))
         
         {
            if ( R_DRSGRPs1Cache != null ) return R_DRSGRPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DRSGRP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DRSGRPs1").equals("true"))
         {
            R_DRSGRPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DRSGRPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DRSGRPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DRSGRPs1Cache.elements());
         }
         else
         {
         
            return (R_DRSGRPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DOBJ objects for this R_DEPT
      * old R_DOBJ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DOBJ objects.
      */
  public Enumeration getOldR_DOBJs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_DOBJs1");
    if (cache)
      getSession().setProperty("NoCacheR_DOBJs1", "false");
    else
      getSession().setProperty("NoCacheR_DOBJs1", "true");

    try {
      return getOldR_DOBJs1();
    } finally {
        getSession().setProperty("NoCacheR_DOBJs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DOBJ objects for this R_DEPT
      * old R_DOBJ objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DOBJ objects.
      */
      public Enumeration   getOldR_DOBJs1()
      {
         
         if (!getSession().getProperty("NoCacheR_DOBJs1").equals("true"))
         
         {
            if ( R_DOBJs1Cache != null ) return R_DOBJs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DOBJ";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DOBJs1").equals("true"))
         {
            R_DOBJs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DOBJBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DOBJs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DOBJs1Cache.elements());
         }
         else
         {
         
            return (R_DOBJBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old PO_DOC_HDR objects for this R_DEPT
      * old PO_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old PO_DOC_HDR objects.
      */
  public Enumeration getOldPO_DOC_HDR(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCachePO_DOC_HDR");
    if (cache)
      getSession().setProperty("NoCachePO_DOC_HDR", "false");
    else
      getSession().setProperty("NoCachePO_DOC_HDR", "true");

    try {
      return getOldPO_DOC_HDR();
    } finally {
        getSession().setProperty("NoCachePO_DOC_HDR", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old PO_DOC_HDR objects for this R_DEPT
      * old PO_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old PO_DOC_HDR objects.
      */
      public Enumeration   getOldPO_DOC_HDR()
      {
         
         if (!getSession().getProperty("NoCachePO_DOC_HDR").equals("true"))
         
         {
            if ( PO_DOC_HDRCache != null ) return PO_DOC_HDRCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "PO_DOC_HDR";
            param.fieldName = "RQSTR_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCachePO_DOC_HDR").equals("true"))
         {
            PO_DOC_HDRCache = new ObjectHashtable();
            for (Enumeration e = (PO_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               PO_DOC_HDRCache.put(pkey,cacheBO);                        
            }
         
            return (PO_DOC_HDRCache.elements());
         }
         else
         {
         
            return (PO_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old VCC_DOC_PRVNT objects for this R_DEPT
      * old VCC_DOC_PRVNT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old VCC_DOC_PRVNT objects.
      */
  public Enumeration getOldRDeptVcPrvnt(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptVcPrvnt");
    if (cache)
      getSession().setProperty("NoCacheRDeptVcPrvnt", "false");
    else
      getSession().setProperty("NoCacheRDeptVcPrvnt", "true");

    try {
      return getOldRDeptVcPrvnt();
    } finally {
        getSession().setProperty("NoCacheRDeptVcPrvnt", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old VCC_DOC_PRVNT objects for this R_DEPT
      * old VCC_DOC_PRVNT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old VCC_DOC_PRVNT objects.
      */
      public Enumeration   getOldRDeptVcPrvnt()
      {
         
         if (!getSession().getProperty("NoCacheRDeptVcPrvnt").equals("true"))
         
         {
            if ( RDeptVcPrvntCache != null ) return RDeptVcPrvntCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "VCC_DOC_PRVNT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptVcPrvnt").equals("true"))
         {
            RDeptVcPrvntCache = new ObjectHashtable();
            for (Enumeration e = (VCC_DOC_PRVNTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptVcPrvntCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptVcPrvntCache.elements());
         }
         else
         {
         
            return (VCC_DOC_PRVNTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PROG_GIS_LOC objects for this R_DEPT
      * old R_PROG_GIS_LOC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PROG_GIS_LOC objects.
      */
  public Enumeration getOldR_PROG_GIS_LOC(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_PROG_GIS_LOC");
    if (cache)
      getSession().setProperty("NoCacheR_PROG_GIS_LOC", "false");
    else
      getSession().setProperty("NoCacheR_PROG_GIS_LOC", "true");

    try {
      return getOldR_PROG_GIS_LOC();
    } finally {
        getSession().setProperty("NoCacheR_PROG_GIS_LOC", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PROG_GIS_LOC objects for this R_DEPT
      * old R_PROG_GIS_LOC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PROG_GIS_LOC objects.
      */
      public Enumeration   getOldR_PROG_GIS_LOC()
      {
         
         if (!getSession().getProperty("NoCacheR_PROG_GIS_LOC").equals("true"))
         
         {
            if ( R_PROG_GIS_LOCCache != null ) return R_PROG_GIS_LOCCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PROG_GIS_LOC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_PROG_GIS_LOC").equals("true"))
         {
            R_PROG_GIS_LOCCache = new ObjectHashtable();
            for (Enumeration e = (R_PROG_GIS_LOCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_PROG_GIS_LOCCache.put(pkey,cacheBO);                        
            }
         
            return (R_PROG_GIS_LOCCache.elements());
         }
         else
         {
         
            return (R_PROG_GIS_LOCBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PART_TYP objects for this R_DEPT
      * old R_PART_TYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PART_TYP objects.
      */
  public Enumeration getOldDeptToPartTyp(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToPartTyp");
    if (cache)
      getSession().setProperty("NoCacheDeptToPartTyp", "false");
    else
      getSession().setProperty("NoCacheDeptToPartTyp", "true");

    try {
      return getOldDeptToPartTyp();
    } finally {
        getSession().setProperty("NoCacheDeptToPartTyp", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PART_TYP objects for this R_DEPT
      * old R_PART_TYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PART_TYP objects.
      */
      public Enumeration   getOldDeptToPartTyp()
      {
         
         if (!getSession().getProperty("NoCacheDeptToPartTyp").equals("true"))
         
         {
            if ( DeptToPartTypCache != null ) return DeptToPartTypCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PART_TYP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToPartTyp").equals("true"))
         {
            DeptToPartTypCache = new ObjectHashtable();
            for (Enumeration e = (R_PART_TYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToPartTypCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToPartTypCache.elements());
         }
         else
         {
         
            return (R_PART_TYPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_LCAT objects for this R_DEPT
      * old R_LCAT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_LCAT objects.
      */
  public Enumeration getOldR_LCATs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_LCATs1");
    if (cache)
      getSession().setProperty("NoCacheR_LCATs1", "false");
    else
      getSession().setProperty("NoCacheR_LCATs1", "true");

    try {
      return getOldR_LCATs1();
    } finally {
        getSession().setProperty("NoCacheR_LCATs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_LCAT objects for this R_DEPT
      * old R_LCAT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_LCAT objects.
      */
      public Enumeration   getOldR_LCATs1()
      {
         
         if (!getSession().getProperty("NoCacheR_LCATs1").equals("true"))
         
         {
            if ( R_LCATs1Cache != null ) return R_LCATs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_LCAT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_LCATs1").equals("true"))
         {
            R_LCATs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_LCATBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_LCATs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_LCATs1Cache.elements());
         }
         else
         {
         
            return (R_LCATBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_GRNT_ALRT_USER objects for this R_DEPT
      * old R_GRNT_ALRT_USER objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_GRNT_ALRT_USER objects.
      */
  public Enumeration getOldRDeptToRGrntAlrtUser(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRGrntAlrtUser");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRGrntAlrtUser", "false");
    else
      getSession().setProperty("NoCacheRDeptToRGrntAlrtUser", "true");

    try {
      return getOldRDeptToRGrntAlrtUser();
    } finally {
        getSession().setProperty("NoCacheRDeptToRGrntAlrtUser", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_GRNT_ALRT_USER objects for this R_DEPT
      * old R_GRNT_ALRT_USER objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_GRNT_ALRT_USER objects.
      */
      public Enumeration   getOldRDeptToRGrntAlrtUser()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntAlrtUser").equals("true"))
         
         {
            if ( RDeptToRGrntAlrtUserCache != null ) return RDeptToRGrntAlrtUserCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_GRNT_ALRT_USER";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRGrntAlrtUser").equals("true"))
         {
            RDeptToRGrntAlrtUserCache = new ObjectHashtable();
            for (Enumeration e = (R_GRNT_ALRT_USERBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRGrntAlrtUserCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRGrntAlrtUserCache.elements());
         }
         else
         {
         
            return (R_GRNT_ALRT_USERBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FNDG_GRP objects for this R_DEPT
      * old R_FNDG_GRP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FNDG_GRP objects.
      */
  public Enumeration getOldRDeptToRFndgGrp(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRFndgGrp");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRFndgGrp", "false");
    else
      getSession().setProperty("NoCacheRDeptToRFndgGrp", "true");

    try {
      return getOldRDeptToRFndgGrp();
    } finally {
        getSession().setProperty("NoCacheRDeptToRFndgGrp", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FNDG_GRP objects for this R_DEPT
      * old R_FNDG_GRP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FNDG_GRP objects.
      */
      public Enumeration   getOldRDeptToRFndgGrp()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRFndgGrp").equals("true"))
         
         {
            if ( RDeptToRFndgGrpCache != null ) return RDeptToRFndgGrpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FNDG_GRP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRFndgGrp").equals("true"))
         {
            RDeptToRFndgGrpCache = new ObjectHashtable();
            for (Enumeration e = (R_FNDG_GRPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRFndgGrpCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRFndgGrpCache.elements());
         }
         else
         {
         
            return (R_FNDG_GRPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FGC objects for this R_DEPT
      * old R_FGC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FGC objects.
      */
  public Enumeration getOldRDeptToRFgc(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToRFgc");
    if (cache)
      getSession().setProperty("NoCacheRDeptToRFgc", "false");
    else
      getSession().setProperty("NoCacheRDeptToRFgc", "true");

    try {
      return getOldRDeptToRFgc();
    } finally {
        getSession().setProperty("NoCacheRDeptToRFgc", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FGC objects for this R_DEPT
      * old R_FGC objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FGC objects.
      */
      public Enumeration   getOldRDeptToRFgc()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToRFgc").equals("true"))
         
         {
            if ( RDeptToRFgcCache != null ) return RDeptToRFgcCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FGC";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToRFgc").equals("true"))
         {
            RDeptToRFgcCache = new ObjectHashtable();
            for (Enumeration e = (R_FGCBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToRFgcCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToRFgcCache.elements());
         }
         else
         {
         
            return (R_FGCBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FAR_HDR objects for this R_DEPT
      * old R_FAR_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FAR_HDR objects.
      */
  public Enumeration getOldRDeptToFarHdr(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToFarHdr");
    if (cache)
      getSession().setProperty("NoCacheRDeptToFarHdr", "false");
    else
      getSession().setProperty("NoCacheRDeptToFarHdr", "true");

    try {
      return getOldRDeptToFarHdr();
    } finally {
        getSession().setProperty("NoCacheRDeptToFarHdr", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FAR_HDR objects for this R_DEPT
      * old R_FAR_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FAR_HDR objects.
      */
      public Enumeration   getOldRDeptToFarHdr()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToFarHdr").equals("true"))
         
         {
            if ( RDeptToFarHdrCache != null ) return RDeptToFarHdrCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FAR_HDR";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToFarHdr").equals("true"))
         {
            RDeptToFarHdrCache = new ObjectHashtable();
            for (Enumeration e = (R_FAR_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToFarHdrCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToFarHdrCache.elements());
         }
         else
         {
         
            return (R_FAR_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DRSTYP objects for this R_DEPT
      * old R_DRSTYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DRSTYP objects.
      */
  public Enumeration getOldR_DRSTYPs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_DRSTYPs1");
    if (cache)
      getSession().setProperty("NoCacheR_DRSTYPs1", "false");
    else
      getSession().setProperty("NoCacheR_DRSTYPs1", "true");

    try {
      return getOldR_DRSTYPs1();
    } finally {
        getSession().setProperty("NoCacheR_DRSTYPs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DRSTYP objects for this R_DEPT
      * old R_DRSTYP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DRSTYP objects.
      */
      public Enumeration   getOldR_DRSTYPs1()
      {
         
         if (!getSession().getProperty("NoCacheR_DRSTYPs1").equals("true"))
         
         {
            if ( R_DRSTYPs1Cache != null ) return R_DRSTYPs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DRSTYP";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DRSTYPs1").equals("true"))
         {
            R_DRSTYPs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DRSTYPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DRSTYPs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DRSTYPs1Cache.elements());
         }
         else
         {
         
            return (R_DRSTYPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DRSCAT objects for this R_DEPT
      * old R_DRSCAT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DRSCAT objects.
      */
  public Enumeration getOldR_DRSCATs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_DRSCATs1");
    if (cache)
      getSession().setProperty("NoCacheR_DRSCATs1", "false");
    else
      getSession().setProperty("NoCacheR_DRSCATs1", "true");

    try {
      return getOldR_DRSCATs1();
    } finally {
        getSession().setProperty("NoCacheR_DRSCATs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DRSCAT objects for this R_DEPT
      * old R_DRSCAT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DRSCAT objects.
      */
      public Enumeration   getOldR_DRSCATs1()
      {
         
         if (!getSession().getProperty("NoCacheR_DRSCATs1").equals("true"))
         
         {
            if ( R_DRSCATs1Cache != null ) return R_DRSCATs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DRSCAT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DRSCATs1").equals("true"))
         {
            R_DRSCATs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DRSCATBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DRSCATs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DRSCATs1Cache.elements());
         }
         else
         {
         
            return (R_DRSCATBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_ACTV objects for this R_DEPT
      * old R_ACTV objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_ACTV objects.
      */
  public Enumeration getOldR_ACTVs6(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_ACTVs6");
    if (cache)
      getSession().setProperty("NoCacheR_ACTVs6", "false");
    else
      getSession().setProperty("NoCacheR_ACTVs6", "true");

    try {
      return getOldR_ACTVs6();
    } finally {
        getSession().setProperty("NoCacheR_ACTVs6", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_ACTV objects for this R_DEPT
      * old R_ACTV objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_ACTV objects.
      */
      public Enumeration   getOldR_ACTVs6()
      {
         
         if (!getSession().getProperty("NoCacheR_ACTVs6").equals("true"))
         
         {
            if ( R_ACTVs6Cache != null ) return R_ACTVs6Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_ACTV";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_ACTVs6").equals("true"))
         {
            R_ACTVs6Cache = new ObjectHashtable();
            for (Enumeration e = (R_ACTVBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_ACTVs6Cache.put(pkey,cacheBO);                        
            }
         
            return (R_ACTVs6Cache.elements());
         }
         else
         {
         
            return (R_ACTVBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old PO_DOC_SRTYINS objects for this R_DEPT
      * old PO_DOC_SRTYINS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old PO_DOC_SRTYINS objects.
      */
  public Enumeration getOldDeptToPoSrtyIns(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToPoSrtyIns");
    if (cache)
      getSession().setProperty("NoCacheDeptToPoSrtyIns", "false");
    else
      getSession().setProperty("NoCacheDeptToPoSrtyIns", "true");

    try {
      return getOldDeptToPoSrtyIns();
    } finally {
        getSession().setProperty("NoCacheDeptToPoSrtyIns", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old PO_DOC_SRTYINS objects for this R_DEPT
      * old PO_DOC_SRTYINS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old PO_DOC_SRTYINS objects.
      */
      public Enumeration   getOldDeptToPoSrtyIns()
      {
         
         if (!getSession().getProperty("NoCacheDeptToPoSrtyIns").equals("true"))
         
         {
            if ( DeptToPoSrtyInsCache != null ) return DeptToPoSrtyInsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "PO_DOC_SRTYINS";
            param.fieldName = "HLD_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToPoSrtyIns").equals("true"))
         {
            DeptToPoSrtyInsCache = new ObjectHashtable();
            for (Enumeration e = (PO_DOC_SRTYINSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToPoSrtyInsCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToPoSrtyInsCache.elements());
         }
         else
         {
         
            return (PO_DOC_SRTYINSBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old ONLN_PRN_PARM_DFLT objects for this R_DEPT
      * old ONLN_PRN_PARM_DFLT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old ONLN_PRN_PARM_DFLT objects.
      */
  public Enumeration getOldRDptToROnPrnParmDflt(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDptToROnPrnParmDflt");
    if (cache)
      getSession().setProperty("NoCacheRDptToROnPrnParmDflt", "false");
    else
      getSession().setProperty("NoCacheRDptToROnPrnParmDflt", "true");

    try {
      return getOldRDptToROnPrnParmDflt();
    } finally {
        getSession().setProperty("NoCacheRDptToROnPrnParmDflt", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old ONLN_PRN_PARM_DFLT objects for this R_DEPT
      * old ONLN_PRN_PARM_DFLT objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old ONLN_PRN_PARM_DFLT objects.
      */
      public Enumeration   getOldRDptToROnPrnParmDflt()
      {
         
         if (!getSession().getProperty("NoCacheRDptToROnPrnParmDflt").equals("true"))
         
         {
            if ( RDptToROnPrnParmDfltCache != null ) return RDptToROnPrnParmDfltCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ONLN_PRN_PARM_DFLT";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDptToROnPrnParmDflt").equals("true"))
         {
            RDptToROnPrnParmDfltCache = new ObjectHashtable();
            for (Enumeration e = (ONLN_PRN_PARM_DFLTBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDptToROnPrnParmDfltCache.put(pkey,cacheBO);                        
            }
         
            return (RDptToROnPrnParmDfltCache.elements());
         }
         else
         {
         
            return (ONLN_PRN_PARM_DFLTBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old INF_APBY objects for this R_DEPT
      * old INF_APBY objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old INF_APBY objects.
      */
  public Enumeration getOldDeptToInfApBY(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToInfApBY");
    if (cache)
      getSession().setProperty("NoCacheDeptToInfApBY", "false");
    else
      getSession().setProperty("NoCacheDeptToInfApBY", "true");

    try {
      return getOldDeptToInfApBY();
    } finally {
        getSession().setProperty("NoCacheDeptToInfApBY", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old INF_APBY objects for this R_DEPT
      * old INF_APBY objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old INF_APBY objects.
      */
      public Enumeration   getOldDeptToInfApBY()
      {
         
         if (!getSession().getProperty("NoCacheDeptToInfApBY").equals("true"))
         
         {
            if ( DeptToInfApBYCache != null ) return DeptToInfApBYCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "INF_APBY";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToInfApBY").equals("true"))
         {
            DeptToInfApBYCache = new ObjectHashtable();
            for (Enumeration e = (INF_APBYBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToInfApBYCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToInfApBYCache.elements());
         }
         else
         {
         
            return (INF_APBYBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old GT_DOC_ALRTUSER objects for this R_DEPT
      * old GT_DOC_ALRTUSER objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old GT_DOC_ALRTUSER objects.
      */
  public Enumeration getOldRDeptToGtDocAlrtuser(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDeptToGtDocAlrtuser");
    if (cache)
      getSession().setProperty("NoCacheRDeptToGtDocAlrtuser", "false");
    else
      getSession().setProperty("NoCacheRDeptToGtDocAlrtuser", "true");

    try {
      return getOldRDeptToGtDocAlrtuser();
    } finally {
        getSession().setProperty("NoCacheRDeptToGtDocAlrtuser", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old GT_DOC_ALRTUSER objects for this R_DEPT
      * old GT_DOC_ALRTUSER objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old GT_DOC_ALRTUSER objects.
      */
      public Enumeration   getOldRDeptToGtDocAlrtuser()
      {
         
         if (!getSession().getProperty("NoCacheRDeptToGtDocAlrtuser").equals("true"))
         
         {
            if ( RDeptToGtDocAlrtuserCache != null ) return RDeptToGtDocAlrtuserCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "GT_DOC_ALRTUSER";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDeptToGtDocAlrtuser").equals("true"))
         {
            RDeptToGtDocAlrtuserCache = new ObjectHashtable();
            for (Enumeration e = (GT_DOC_ALRTUSERBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDeptToGtDocAlrtuserCache.put(pkey,cacheBO);                        
            }
         
            return (RDeptToGtDocAlrtuserCache.elements());
         }
         else
         {
         
            return (GT_DOC_ALRTUSERBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old FA_DOC_HDR objects for this R_DEPT
      * old FA_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old FA_DOC_HDR objects.
      */
  public Enumeration getOldFA_DOC_HDRs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheFA_DOC_HDRs1");
    if (cache)
      getSession().setProperty("NoCacheFA_DOC_HDRs1", "false");
    else
      getSession().setProperty("NoCacheFA_DOC_HDRs1", "true");

    try {
      return getOldFA_DOC_HDRs1();
    } finally {
        getSession().setProperty("NoCacheFA_DOC_HDRs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old FA_DOC_HDR objects for this R_DEPT
      * old FA_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old FA_DOC_HDR objects.
      */
      public Enumeration   getOldFA_DOC_HDRs1()
      {
         
         if (!getSession().getProperty("NoCacheFA_DOC_HDRs1").equals("true"))
         
         {
            if ( FA_DOC_HDRs1Cache != null ) return FA_DOC_HDRs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "FA_DOC_HDR";
            param.fieldName = "NEW_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheFA_DOC_HDRs1").equals("true"))
         {
            FA_DOC_HDRs1Cache = new ObjectHashtable();
            for (Enumeration e = (FA_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               FA_DOC_HDRs1Cache.put(pkey,cacheBO);                        
            }
         
            return (FA_DOC_HDRs1Cache.elements());
         }
         else
         {
         
            return (FA_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old ARRA_DOC_ONGOING objects for this R_DEPT
      * old ARRA_DOC_ONGOING objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old ARRA_DOC_ONGOING objects.
      */
  public Enumeration getOldDeptToARRADocOngoing(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToARRADocOngoing");
    if (cache)
      getSession().setProperty("NoCacheDeptToARRADocOngoing", "false");
    else
      getSession().setProperty("NoCacheDeptToARRADocOngoing", "true");

    try {
      return getOldDeptToARRADocOngoing();
    } finally {
        getSession().setProperty("NoCacheDeptToARRADocOngoing", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old ARRA_DOC_ONGOING objects for this R_DEPT
      * old ARRA_DOC_ONGOING objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old ARRA_DOC_ONGOING objects.
      */
      public Enumeration   getOldDeptToARRADocOngoing()
      {
         
         if (!getSession().getProperty("NoCacheDeptToARRADocOngoing").equals("true"))
         
         {
            if ( DeptToARRADocOngoingCache != null ) return DeptToARRADocOngoingCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ARRA_DOC_ONGOING";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToARRADocOngoing").equals("true"))
         {
            DeptToARRADocOngoingCache = new ObjectHashtable();
            for (Enumeration e = (ARRA_DOC_ONGOINGBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToARRADocOngoingCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToARRADocOngoingCache.elements());
         }
         else
         {
         
            return (ARRA_DOC_ONGOINGBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_SRCPNT_QTRLY_AWD objects for this R_DEPT
      * old R_SRCPNT_QTRLY_AWD objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_SRCPNT_QTRLY_AWD objects.
      */
  public Enumeration getOldDepartmentToSubRcpntQtrlyAwd(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDepartmentToSubRcpntQtrlyAwd");
    if (cache)
      getSession().setProperty("NoCacheDepartmentToSubRcpntQtrlyAwd", "false");
    else
      getSession().setProperty("NoCacheDepartmentToSubRcpntQtrlyAwd", "true");

    try {
      return getOldDepartmentToSubRcpntQtrlyAwd();
    } finally {
        getSession().setProperty("NoCacheDepartmentToSubRcpntQtrlyAwd", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_SRCPNT_QTRLY_AWD objects for this R_DEPT
      * old R_SRCPNT_QTRLY_AWD objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_SRCPNT_QTRLY_AWD objects.
      */
      public Enumeration   getOldDepartmentToSubRcpntQtrlyAwd()
      {
         
         if (!getSession().getProperty("NoCacheDepartmentToSubRcpntQtrlyAwd").equals("true"))
         
         {
            if ( DepartmentToSubRcpntQtrlyAwdCache != null ) return DepartmentToSubRcpntQtrlyAwdCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_SRCPNT_QTRLY_AWD";
            param.fieldName = "AWD_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDepartmentToSubRcpntQtrlyAwd").equals("true"))
         {
            DepartmentToSubRcpntQtrlyAwdCache = new ObjectHashtable();
            for (Enumeration e = (R_SRCPNT_QTRLY_AWDBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DepartmentToSubRcpntQtrlyAwdCache.put(pkey,cacheBO);                        
            }
         
            return (DepartmentToSubRcpntQtrlyAwdCache.elements());
         }
         else
         {
         
            return (R_SRCPNT_QTRLY_AWDBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_PLBS_SETP objects for this R_DEPT
      * old R_PLBS_SETP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_PLBS_SETP objects.
      */
  public Enumeration getOldRdeptToRplbsSetp(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRdeptToRplbsSetp");
    if (cache)
      getSession().setProperty("NoCacheRdeptToRplbsSetp", "false");
    else
      getSession().setProperty("NoCacheRdeptToRplbsSetp", "true");

    try {
      return getOldRdeptToRplbsSetp();
    } finally {
        getSession().setProperty("NoCacheRdeptToRplbsSetp", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_PLBS_SETP objects for this R_DEPT
      * old R_PLBS_SETP objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_PLBS_SETP objects.
      */
      public Enumeration   getOldRdeptToRplbsSetp()
      {
         
         if (!getSession().getProperty("NoCacheRdeptToRplbsSetp").equals("true"))
         
         {
            if ( RdeptToRplbsSetpCache != null ) return RdeptToRplbsSetpCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_PLBS_SETP";
            param.fieldName = "SECU_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRdeptToRplbsSetp").equals("true"))
         {
            RdeptToRplbsSetpCache = new ObjectHashtable();
            for (Enumeration e = (R_PLBS_SETPBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RdeptToRplbsSetpCache.put(pkey,cacheBO);                        
            }
         
            return (RdeptToRplbsSetpCache.elements());
         }
         else
         {
         
            return (R_PLBS_SETPBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_OTPT_PARM_DET objects for this R_DEPT
      * old R_OTPT_PARM_DET objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_OTPT_PARM_DET objects.
      */
  public Enumeration getOldR_OTPT_PARM_DETs4(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_OTPT_PARM_DETs4");
    if (cache)
      getSession().setProperty("NoCacheR_OTPT_PARM_DETs4", "false");
    else
      getSession().setProperty("NoCacheR_OTPT_PARM_DETs4", "true");

    try {
      return getOldR_OTPT_PARM_DETs4();
    } finally {
        getSession().setProperty("NoCacheR_OTPT_PARM_DETs4", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_OTPT_PARM_DET objects for this R_DEPT
      * old R_OTPT_PARM_DET objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_OTPT_PARM_DET objects.
      */
      public Enumeration   getOldR_OTPT_PARM_DETs4()
      {
         
         if (!getSession().getProperty("NoCacheR_OTPT_PARM_DETs4").equals("true"))
         
         {
            if ( R_OTPT_PARM_DETs4Cache != null ) return R_OTPT_PARM_DETs4Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_OTPT_PARM_DET";
            param.fieldName = "RE_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_OTPT_PARM_DETs4").equals("true"))
         {
            R_OTPT_PARM_DETs4Cache = new ObjectHashtable();
            for (Enumeration e = (R_OTPT_PARM_DETBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_OTPT_PARM_DETs4Cache.put(pkey,cacheBO);                        
            }
         
            return (R_OTPT_PARM_DETs4Cache.elements());
         }
         else
         {
         
            return (R_OTPT_PARM_DETBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_INT_CST_OT_MULTI objects for this R_DEPT
      * old R_INT_CST_OT_MULTI objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_INT_CST_OT_MULTI objects.
      */
  public Enumeration getOldRIntCstOtMultiToRDept1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRIntCstOtMultiToRDept1");
    if (cache)
      getSession().setProperty("NoCacheRIntCstOtMultiToRDept1", "false");
    else
      getSession().setProperty("NoCacheRIntCstOtMultiToRDept1", "true");

    try {
      return getOldRIntCstOtMultiToRDept1();
    } finally {
        getSession().setProperty("NoCacheRIntCstOtMultiToRDept1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_INT_CST_OT_MULTI objects for this R_DEPT
      * old R_INT_CST_OT_MULTI objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_INT_CST_OT_MULTI objects.
      */
      public Enumeration   getOldRIntCstOtMultiToRDept1()
      {
         
         if (!getSession().getProperty("NoCacheRIntCstOtMultiToRDept1").equals("true"))
         
         {
            if ( RIntCstOtMultiToRDept1Cache != null ) return RIntCstOtMultiToRDept1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_INT_CST_OT_MULTI";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRIntCstOtMultiToRDept1").equals("true"))
         {
            RIntCstOtMultiToRDept1Cache = new ObjectHashtable();
            for (Enumeration e = (R_INT_CST_OT_MULTIBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RIntCstOtMultiToRDept1Cache.put(pkey,cacheBO);                        
            }
         
            return (RIntCstOtMultiToRDept1Cache.elements());
         }
         else
         {
         
            return (R_INT_CST_OT_MULTIBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_FNCLS objects for this R_DEPT
      * old R_FNCLS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_FNCLS objects.
      */
  public Enumeration getOldR_FNCLSs1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_FNCLSs1");
    if (cache)
      getSession().setProperty("NoCacheR_FNCLSs1", "false");
    else
      getSession().setProperty("NoCacheR_FNCLSs1", "true");

    try {
      return getOldR_FNCLSs1();
    } finally {
        getSession().setProperty("NoCacheR_FNCLSs1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_FNCLS objects for this R_DEPT
      * old R_FNCLS objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_FNCLS objects.
      */
      public Enumeration   getOldR_FNCLSs1()
      {
         
         if (!getSession().getProperty("NoCacheR_FNCLSs1").equals("true"))
         
         {
            if ( R_FNCLSs1Cache != null ) return R_FNCLSs1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_FNCLS";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_FNCLSs1").equals("true"))
         {
            R_FNCLSs1Cache = new ObjectHashtable();
            for (Enumeration e = (R_FNCLSBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_FNCLSs1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_FNCLSs1Cache.elements());
         }
         else
         {
         
            return (R_FNCLSBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DISB_MGMT_RSTR objects for this R_DEPT
      * old R_DISB_MGMT_RSTR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DISB_MGMT_RSTR objects.
      */
  public Enumeration getOldR_DISB_MGMT_RSTR_1(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_DISB_MGMT_RSTR_1");
    if (cache)
      getSession().setProperty("NoCacheR_DISB_MGMT_RSTR_1", "false");
    else
      getSession().setProperty("NoCacheR_DISB_MGMT_RSTR_1", "true");

    try {
      return getOldR_DISB_MGMT_RSTR_1();
    } finally {
        getSession().setProperty("NoCacheR_DISB_MGMT_RSTR_1", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DISB_MGMT_RSTR objects for this R_DEPT
      * old R_DISB_MGMT_RSTR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DISB_MGMT_RSTR objects.
      */
      public Enumeration   getOldR_DISB_MGMT_RSTR_1()
      {
         
         if (!getSession().getProperty("NoCacheR_DISB_MGMT_RSTR_1").equals("true"))
         
         {
            if ( R_DISB_MGMT_RSTR_1Cache != null ) return R_DISB_MGMT_RSTR_1Cache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DISB_MGMT_RSTR";
            param.fieldName = "AWD_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DISB_MGMT_RSTR_1").equals("true"))
         {
            R_DISB_MGMT_RSTR_1Cache = new ObjectHashtable();
            for (Enumeration e = (R_DISB_MGMT_RSTRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DISB_MGMT_RSTR_1Cache.put(pkey,cacheBO);                        
            }
         
            return (R_DISB_MGMT_RSTR_1Cache.elements());
         }
         else
         {
         
            return (R_DISB_MGMT_RSTRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_DISB_MGMT_RSTR objects for this R_DEPT
      * old R_DISB_MGMT_RSTR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_DISB_MGMT_RSTR objects.
      */
  public Enumeration getOldR_DISB_MGMT_RSTR(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_DISB_MGMT_RSTR");
    if (cache)
      getSession().setProperty("NoCacheR_DISB_MGMT_RSTR", "false");
    else
      getSession().setProperty("NoCacheR_DISB_MGMT_RSTR", "true");

    try {
      return getOldR_DISB_MGMT_RSTR();
    } finally {
        getSession().setProperty("NoCacheR_DISB_MGMT_RSTR", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_DISB_MGMT_RSTR objects for this R_DEPT
      * old R_DISB_MGMT_RSTR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_DISB_MGMT_RSTR objects.
      */
      public Enumeration   getOldR_DISB_MGMT_RSTR()
      {
         
         if (!getSession().getProperty("NoCacheR_DISB_MGMT_RSTR").equals("true"))
         
         {
            if ( R_DISB_MGMT_RSTRCache != null ) return R_DISB_MGMT_RSTRCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_DISB_MGMT_RSTR";
            param.fieldName = "PR_DOC_DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_DISB_MGMT_RSTR").equals("true"))
         {
            R_DISB_MGMT_RSTRCache = new ObjectHashtable();
            for (Enumeration e = (R_DISB_MGMT_RSTRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_DISB_MGMT_RSTRCache.put(pkey,cacheBO);                        
            }
         
            return (R_DISB_MGMT_RSTRCache.elements());
         }
         else
         {
         
            return (R_DISB_MGMT_RSTRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_CMIA_INTR_PARM objects for this R_DEPT
      * old R_CMIA_INTR_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_CMIA_INTR_PARM objects.
      */
  public Enumeration getOldR_CMIA_INTR_PARMs(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheR_CMIA_INTR_PARMs");
    if (cache)
      getSession().setProperty("NoCacheR_CMIA_INTR_PARMs", "false");
    else
      getSession().setProperty("NoCacheR_CMIA_INTR_PARMs", "true");

    try {
      return getOldR_CMIA_INTR_PARMs();
    } finally {
        getSession().setProperty("NoCacheR_CMIA_INTR_PARMs", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_CMIA_INTR_PARM objects for this R_DEPT
      * old R_CMIA_INTR_PARM objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_CMIA_INTR_PARM objects.
      */
      public Enumeration   getOldR_CMIA_INTR_PARMs()
      {
         
         if (!getSession().getProperty("NoCacheR_CMIA_INTR_PARMs").equals("true"))
         
         {
            if ( R_CMIA_INTR_PARMsCache != null ) return R_CMIA_INTR_PARMsCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_CMIA_INTR_PARM";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheR_CMIA_INTR_PARMs").equals("true"))
         {
            R_CMIA_INTR_PARMsCache = new ObjectHashtable();
            for (Enumeration e = (R_CMIA_INTR_PARMBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               R_CMIA_INTR_PARMsCache.put(pkey,cacheBO);                        
            }
         
            return (R_CMIA_INTR_PARMsCache.elements());
         }
         else
         {
         
            return (R_CMIA_INTR_PARMBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old R_BFY_STPF_REV objects for this R_DEPT
      * old R_BFY_STPF_REV objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old R_BFY_STPF_REV objects.
      */
  public Enumeration getOldRDept_RBfyStpfRev(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheRDept_RBfyStpfRev");
    if (cache)
      getSession().setProperty("NoCacheRDept_RBfyStpfRev", "false");
    else
      getSession().setProperty("NoCacheRDept_RBfyStpfRev", "true");

    try {
      return getOldRDept_RBfyStpfRev();
    } finally {
        getSession().setProperty("NoCacheRDept_RBfyStpfRev", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old R_BFY_STPF_REV objects for this R_DEPT
      * old R_BFY_STPF_REV objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old R_BFY_STPF_REV objects.
      */
      public Enumeration   getOldRDept_RBfyStpfRev()
      {
         
         if (!getSession().getProperty("NoCacheRDept_RBfyStpfRev").equals("true"))
         
         {
            if ( RDept_RBfyStpfRevCache != null ) return RDept_RBfyStpfRevCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "R_BFY_STPF_REV";
            param.fieldName = "DEPT_CD";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheRDept_RBfyStpfRev").equals("true"))
         {
            RDept_RBfyStpfRevCache = new ObjectHashtable();
            for (Enumeration e = (R_BFY_STPF_REVBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               RDept_RBfyStpfRevCache.put(pkey,cacheBO);                        
            }
         
            return (RDept_RBfyStpfRevCache.elements());
         }
         else
         {
         
            return (R_BFY_STPF_REVBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }
     /**     
      * <br>
      * method to retrieve the old ICT_DOC_HDR objects for this R_DEPT
      * old ICT_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * @param cache     : true if the relationship cache is to be used.
      *                    it will result in all objects being fetched into
      *                    memory (if they have not been cached yet).
      * @return Enumeration : the Enumeration of old ICT_DOC_HDR objects.
      */
  public Enumeration getOldDeptToIctDocActg(boolean cache)
  {
    String oldCacheProperty = getSession().getProperty("NoCacheDeptToIctDocActg");
    if (cache)
      getSession().setProperty("NoCacheDeptToIctDocActg", "false");
    else
      getSession().setProperty("NoCacheDeptToIctDocActg", "true");

    try {
      return getOldDeptToIctDocActg();
    } finally {
        getSession().setProperty("NoCacheDeptToIctDocActg", oldCacheProperty);
    }
  }


     /**
      * <br>
      * method to retrieve the old ICT_DOC_HDR objects for this R_DEPT
      * old ICT_DOC_HDR objects would be different from the new ones usualy if
      * the R_DEPT has a primary key change.
      * this method currently does not support additional conditional params.
      * @return Enumeration : the Enumeration of old ICT_DOC_HDR objects.
      */
      public Enumeration   getOldDeptToIctDocActg()
      {
         
         if (!getSession().getProperty("NoCacheDeptToIctDocActg").equals("true"))
         
         {
            if ( DeptToIctDocActgCache != null ) return DeptToIctDocActgCache.elements();
         }

         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            param = new Parameter();
            param.objName = "ICT_DOC_HDR";
            param.fieldName = "EMPL_HM_DEPT";
            param.value = getData(miDEPT_CD).getPreviousString();
            searchReq.add(param);
         
         if (!getSession().getProperty("NoCacheDeptToIctDocActg").equals("true"))
         {
            DeptToIctDocActgCache = new ObjectHashtable();
            for (Enumeration e = (ICT_DOC_HDRBaseImpl.getObjects(searchReq ,getSession())); e.hasMoreElements();)
            {
               DataObject cacheBO = (DataObject)e.nextElement();
               DataRow row = cacheBO.getRow();
               Vector pkey = row.getPkeyParams();
               DeptToIctDocActgCache.put(pkey,cacheBO);                        
            }
         
            return (DeptToIctDocActgCache.elements());
         }
         else
         {
         
            return (ICT_DOC_HDRBaseImpl.getObjects(searchReq ,getSession()));
         }
         
      }




      public void updateCacheForDeptCAToARRADocOngoing(ARRA_DOC_ONGOINGBaseImpl child, boolean remove)
      {
         if ( DeptCAToARRADocOngoingCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptCAToARRADocOngoingCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptCAToARRADocOngoingCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptCAToARRADocOngoingCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptCAToARRADocOngoingCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToCAMMjrProgDoc(CAM_DOC_MJRPROGBaseImpl child, boolean remove)
      {
         if ( DeptToCAMMjrProgDocCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToCAMMjrProgDocCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCAMMjrProgDocCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToCAMMjrProgDocCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCAMMjrProgDocCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToCASMjrProgDoc(CAS_DOC_MJRPROGBaseImpl child, boolean remove)
      {
         if ( DeptToCASMjrProgDocCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToCASMjrProgDocCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCASMjrProgDocCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToCASMjrProgDocCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCASMjrProgDocCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForCVEX_FUND_DEPTs(CVEX_FUND_DEPTBaseImpl child, boolean remove)
      {
         if ( CVEX_FUND_DEPTsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( CVEX_FUND_DEPTsCache.containsKey(child.getRow().getPkeyParams()) )
                  CVEX_FUND_DEPTsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! CVEX_FUND_DEPTsCache.containsKey(child.getRow().getPkeyParams()) )
                  CVEX_FUND_DEPTsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForCVIN_FUND_DEPTs(CVIN_FUND_DEPTBaseImpl child, boolean remove)
      {
         if ( CVIN_FUND_DEPTsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( CVIN_FUND_DEPTsCache.containsKey(child.getRow().getPkeyParams()) )
                  CVIN_FUND_DEPTsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! CVIN_FUND_DEPTsCache.containsKey(child.getRow().getPkeyParams()) )
                  CVIN_FUND_DEPTsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToCvinStru44L3Req(CVIN_STRU44L3_REQBaseImpl child, boolean remove)
      {
         if ( RDeptToCvinStru44L3ReqCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToCvinStru44L3ReqCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToCvinStru44L3ReqCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToCvinStru44L3ReqCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToCvinStru44L3ReqCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToCvinStru45L3Req(CVIN_STRU45L3_REQBaseImpl child, boolean remove)
      {
         if ( DeptToCvinStru45L3ReqCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToCvinStru45L3ReqCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCvinStru45L3ReqCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToCvinStru45L3ReqCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCvinStru45L3ReqCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToUnitProg(CVIN_UNIT_PROGBaseImpl child, boolean remove)
      {
         if ( DeptToUnitProgCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToUnitProgCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToUnitProgCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToUnitProgCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToUnitProgCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDOC_COAs28(DOC_COABaseImpl child, boolean remove)
      {
         if ( DOC_COAs28Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DOC_COAs28Cache.containsKey(child.getRow().getPkeyParams()) )
                  DOC_COAs28Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DOC_COAs28Cache.containsKey(child.getRow().getPkeyParams()) )
                  DOC_COAs28Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptDocIntCoa(DOC_INT_COABaseImpl child, boolean remove)
      {
         if ( DeptDocIntCoaCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptDocIntCoaCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptDocIntCoaCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptDocIntCoaCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptDocIntCoaCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToGtDocComn(GT_DOC_COMNBaseImpl child, boolean remove)
      {
         if ( RDeptToGtDocComnCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToGtDocComnCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToGtDocComnCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToGtDocComnCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToGtDocComnCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToGtDocNotifUsr(GT_DOC_NOTIFUSRBaseImpl child, boolean remove)
      {
         if ( DeptToGtDocNotifUsrCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToGtDocNotifUsrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGtDocNotifUsrCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToGtDocNotifUsrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGtDocNotifUsrCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToGtDocOpty(GT_DOC_OPTYBaseImpl child, boolean remove)
      {
         if ( DeptToGtDocOptyCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToGtDocOptyCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGtDocOptyCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToGtDocOptyCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGtDocOptyCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToGtDocResp(GT_DOC_RESPBaseImpl child, boolean remove)
      {
         if ( DeptToGtDocRespCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToGtDocRespCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGtDocRespCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToGtDocRespCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGtDocRespCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToInfApprFuncOtyp(INF_APPR_FUNC_OTYPBaseImpl child, boolean remove)
      {
         if ( DeptToInfApprFuncOtypCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToInfApprFuncOtypCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfApprFuncOtypCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToInfApprFuncOtypCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfApprFuncOtypCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRsrcApprInfRecs(INF_APPR_RSRCBaseImpl child, boolean remove)
      {
         if ( RsrcApprInfRecsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RsrcApprInfRecsCache.containsKey(child.getRow().getPkeyParams()) )
                  RsrcApprInfRecsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RsrcApprInfRecsCache.containsKey(child.getRow().getPkeyParams()) )
                  RsrcApprInfRecsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForINF_BFYs1(INF_BFYBaseImpl child, boolean remove)
      {
         if ( INF_BFYs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( INF_BFYs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  INF_BFYs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! INF_BFYs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  INF_BFYs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForInfDeptUnitToDept(INF_DEPT_UNITBaseImpl child, boolean remove)
      {
         if ( InfDeptUnitToDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( InfDeptUnitToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  InfDeptUnitToDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! InfDeptUnitToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  InfDeptUnitToDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToInfFpi6(INF_FPI_6BaseImpl child, boolean remove)
      {
         if ( DeptToInfFpi6Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToInfFpi6Cache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfFpi6Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToInfFpi6Cache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfFpi6Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForINF_FPRL_12(INF_FPRL_1BaseImpl child, boolean remove)
      {
         if ( INF_FPRL_12Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( INF_FPRL_12Cache.containsKey(child.getRow().getPkeyParams()) )
                  INF_FPRL_12Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! INF_FPRL_12Cache.containsKey(child.getRow().getPkeyParams()) )
                  INF_FPRL_12Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForINF_FPRL_21(INF_FPRL_2BaseImpl child, boolean remove)
      {
         if ( INF_FPRL_21Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( INF_FPRL_21Cache.containsKey(child.getRow().getPkeyParams()) )
                  INF_FPRL_21Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! INF_FPRL_21Cache.containsKey(child.getRow().getPkeyParams()) )
                  INF_FPRL_21Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForINF_FPRL_32(INF_FPRL_3BaseImpl child, boolean remove)
      {
         if ( INF_FPRL_32Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( INF_FPRL_32Cache.containsKey(child.getRow().getPkeyParams()) )
                  INF_FPRL_32Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! INF_FPRL_32Cache.containsKey(child.getRow().getPkeyParams()) )
                  INF_FPRL_32Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForInfFprfl4Recs(INF_FPRL_4BaseImpl child, boolean remove)
      {
         if ( InfFprfl4RecsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( InfFprfl4RecsCache.containsKey(child.getRow().getPkeyParams()) )
                  InfFprfl4RecsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! InfFprfl4RecsCache.containsKey(child.getRow().getPkeyParams()) )
                  InfFprfl4RecsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToInfFprl5(INF_FPRL_5BaseImpl child, boolean remove)
      {
         if ( DeptToInfFprl5Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToInfFprl5Cache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfFprl5Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToInfFprl5Cache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfFprl5Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToInfFprlO(INF_FPRL_OBaseImpl child, boolean remove)
      {
         if ( RDeptToInfFprlOCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToInfFprlOCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToInfFprlOCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToInfFprlOCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToInfFprlOCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToInfFprlActToLcn(INF_FPRL_ACTV_LOCBaseImpl child, boolean remove)
      {
         if ( DeptToInfFprlActToLcnCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToInfFprlActToLcnCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfFprlActToLcnCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToInfFprlActToLcnCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfFprlActToLcnCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToInfFuncFundProg(INF_FUNC_FUND_PROGBaseImpl child, boolean remove)
      {
         if ( DeptToInfFuncFundProgCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToInfFuncFundProgCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfFuncFundProgCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToInfFuncFundProgCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfFuncFundProgCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForINF_FUND_FUNC_ACTVs1(INF_FUND_FUNC_ACTVBaseImpl child, boolean remove)
      {
         if ( INF_FUND_FUNC_ACTVs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( INF_FUND_FUNC_ACTVs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  INF_FUND_FUNC_ACTVs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! INF_FUND_FUNC_ACTVs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  INF_FUND_FUNC_ACTVs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForGFPIToDept(INF_GRNT_FPBaseImpl child, boolean remove)
      {
         if ( GFPIToDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( GFPIToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  GFPIToDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! GFPIToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  GFPIToDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForInfObjOtypToDept(INF_OBJ_OTYPBaseImpl child, boolean remove)
      {
         if ( InfObjOtypToDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( InfObjOtypToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  InfObjOtypToDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! InfObjOtypToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  InfObjOtypToDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForINF_PHASE_PROGs(INF_PHASE_PROGBaseImpl child, boolean remove)
      {
         if ( INF_PHASE_PROGsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( INF_PHASE_PROGsCache.containsKey(child.getRow().getPkeyParams()) )
                  INF_PHASE_PROGsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! INF_PHASE_PROGsCache.containsKey(child.getRow().getPkeyParams()) )
                  INF_PHASE_PROGsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForPFPIToDept(INF_PROJ_FPBaseImpl child, boolean remove)
      {
         if ( PFPIToDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( PFPIToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  PFPIToDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! PFPIToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  PFPIToDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRevSrcInfToDept(INF_REV_SRCBaseImpl child, boolean remove)
      {
         if ( RevSrcInfToDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RevSrcInfToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  RevSrcInfToDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RevSrcInfToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  RevSrcInfToDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToInfUnit(INF_UNITBaseImpl child, boolean remove)
      {
         if ( DeptToInfUnitCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToInfUnitCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfUnitCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToInfUnitCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfUnitCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptMaAuthDept(MA_DOC_AUTHDEPTBaseImpl child, boolean remove)
      {
         if ( DeptMaAuthDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptMaAuthDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptMaAuthDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptMaAuthDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptMaAuthDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToActgPrfl(R_ACTG_PRFLBaseImpl child, boolean remove)
      {
         if ( DeptToActgPrflCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToActgPrflCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToActgPrflCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToActgPrflCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToActgPrflCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_ACTG_TMPLs(R_ACTG_TMPLBaseImpl child, boolean remove)
      {
         if ( R_ACTG_TMPLsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_ACTG_TMPLsCache.containsKey(child.getRow().getPkeyParams()) )
                  R_ACTG_TMPLsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_ACTG_TMPLsCache.containsKey(child.getRow().getPkeyParams()) )
                  R_ACTG_TMPLsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToStructDept(R_ALT_ORG_STRUCTBaseImpl child, boolean remove)
      {
         if ( DeptToStructDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToStructDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToStructDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToStructDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToStructDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToApCwHdr(R_AP_CW_HDRBaseImpl child, boolean remove)
      {
         if ( DeptToApCwHdrCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToApCwHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToApCwHdrCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToApCwHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToApCwHdrCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_AP_INCT_RQSTs2(R_AP_INCT_RQSTBaseImpl child, boolean remove)
      {
         if ( R_AP_INCT_RQSTs2Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_AP_INCT_RQSTs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_AP_INCT_RQSTs2Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_AP_INCT_RQSTs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_AP_INCT_RQSTs2Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRApdDept(R_APD_DEPTBaseImpl child, boolean remove)
      {
         if ( RDeptToRApdDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRApdDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRApdDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRApdDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRApdDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToCitedAuth(R_CITED_AUTHBaseImpl child, boolean remove)
      {
         if ( DeptToCitedAuthCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToCitedAuthCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCitedAuthCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToCitedAuthCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCitedAuthCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToCntac(R_CNTACBaseImpl child, boolean remove)
      {
         if ( DeptToCntacCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToCntacCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCntacCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToCntacCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCntacCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_COMM_FA_THLDs1(R_COMM_FA_THLDBaseImpl child, boolean remove)
      {
         if ( R_COMM_FA_THLDs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_COMM_FA_THLDs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_COMM_FA_THLDs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_COMM_FA_THLDs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_COMM_FA_THLDs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_COMM_OBJs1(R_COMM_OBJBaseImpl child, boolean remove)
      {
         if ( R_COMM_OBJs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_COMM_OBJs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_COMM_OBJs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_COMM_OBJs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_COMM_OBJs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToDeptFY(R_DEPT_FYBaseImpl child, boolean remove)
      {
         if ( DeptToDeptFYCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToDeptFYCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDeptFYCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToDeptFYCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDeptFYCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRDeptObjPymtCtrl(R_DEPT_OBJ_PYCTRLBaseImpl child, boolean remove)
      {
         if ( RDeptToRDeptObjPymtCtrlCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRDeptObjPymtCtrlCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRDeptObjPymtCtrlCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRDeptObjPymtCtrlCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRDeptObjPymtCtrlCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToDISCIV(R_DISCIVBaseImpl child, boolean remove)
      {
         if ( DeptToDISCIVCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToDISCIVCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDISCIVCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToDISCIVCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDISCIVCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToDrwdwnGrp(R_DRWDWN_GRPBaseImpl child, boolean remove)
      {
         if ( DeptToDrwdwnGrpCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToDrwdwnGrpCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDrwdwnGrpCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToDrwdwnGrpCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDrwdwnGrpCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToEscrowDef(R_ESCROW_DEFBaseImpl child, boolean remove)
      {
         if ( DeptToEscrowDefCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToEscrowDefCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToEscrowDefCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToEscrowDefCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToEscrowDefCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRFesReq(R_FESREQBaseImpl child, boolean remove)
      {
         if ( RDeptToRFesReqCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRFesReqCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRFesReqCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRFesReqCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRFesReqCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRFndgAlloc(R_FNDG_ALLOCBaseImpl child, boolean remove)
      {
         if ( RDeptToRFndgAllocCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRFndgAllocCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRFndgAllocCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRFndgAllocCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRFndgAllocCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRFyDept(R_FY_DEPTBaseImpl child, boolean remove)
      {
         if ( RDeptToRFyDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRFyDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRFyDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRFyDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRFyDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRGrntAppl(R_GRNT_APPLBaseImpl child, boolean remove)
      {
         if ( RDeptToRGrntApplCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRGrntApplCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntApplCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRGrntApplCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntApplCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRGrntDtTmpl(R_GRNT_DT_TMPLBaseImpl child, boolean remove)
      {
         if ( RDeptToRGrntDtTmplCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRGrntDtTmplCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntDtTmplCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRGrntDtTmplCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntDtTmplCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToGrntOpty(R_GRNT_OPTYBaseImpl child, boolean remove)
      {
         if ( DeptToGrntOptyCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToGrntOptyCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGrntOptyCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToGrntOptyCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGrntOptyCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToGrntResp(R_GRNT_RESPBaseImpl child, boolean remove)
      {
         if ( DeptToGrntRespCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToGrntRespCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGrntRespCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToGrntRespCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGrntRespCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToGrntUser(R_GRNT_USERBaseImpl child, boolean remove)
      {
         if ( DeptToGrntUserCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToGrntUserCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGrntUserCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToGrntUserCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGrntUserCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_INTG_CTRL(R_INTG_CTRLBaseImpl child, boolean remove)
      {
         if ( R_INTG_CTRLCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_INTG_CTRLCache.containsKey(child.getRow().getPkeyParams()) )
                  R_INTG_CTRLCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_INTG_CTRLCache.containsKey(child.getRow().getPkeyParams()) )
                  R_INTG_CTRLCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_MJR_PROGs3(R_MJR_PROGBaseImpl child, boolean remove)
      {
         if ( R_MJR_PROGs3Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_MJR_PROGs3Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_MJR_PROGs3Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_MJR_PROGs3Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_MJR_PROGs3Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDepartmentToOnGoingAwardInfo(R_ONGOING_AWD_INFOBaseImpl child, boolean remove)
      {
         if ( DepartmentToOnGoingAwardInfoCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DepartmentToOnGoingAwardInfoCache.containsKey(child.getRow().getPkeyParams()) )
                  DepartmentToOnGoingAwardInfoCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DepartmentToOnGoingAwardInfoCache.containsKey(child.getRow().getPkeyParams()) )
                  DepartmentToOnGoingAwardInfoCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForPerfEvalEvaluator(R_PE_EVALRBaseImpl child, boolean remove)
      {
         if ( PerfEvalEvaluatorCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( PerfEvalEvaluatorCache.containsKey(child.getRow().getPkeyParams()) )
                  PerfEvalEvaluatorCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! PerfEvalEvaluatorCache.containsKey(child.getRow().getPkeyParams()) )
                  PerfEvalEvaluatorCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForStateInstances(R_PRCU_STBaseImpl child, boolean remove)
      {
         if ( StateInstancesCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( StateInstancesCache.containsKey(child.getRow().getPkeyParams()) )
                  StateInstancesCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! StateInstancesCache.containsKey(child.getRow().getPkeyParams()) )
                  StateInstancesCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRPayHldByDept(R_PYMT_HLD_TYP_DPTBaseImpl child, boolean remove)
      {
         if ( RDeptToRPayHldByDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRPayHldByDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRPayHldByDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRPayHldByDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRPayHldByDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_STPF(R_STPFBaseImpl child, boolean remove)
      {
         if ( R_STPFCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_STPFCache.containsKey(child.getRow().getPkeyParams()) )
                  R_STPFCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_STPFCache.containsKey(child.getRow().getPkeyParams()) )
                  R_STPFCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForUniversalRequestorControls(R_UR_CTRLBaseImpl child, boolean remove)
      {
         if ( UniversalRequestorControlsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( UniversalRequestorControlsCache.containsKey(child.getRow().getPkeyParams()) )
                  UniversalRequestorControlsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! UniversalRequestorControlsCache.containsKey(child.getRow().getPkeyParams()) )
                  UniversalRequestorControlsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForUserGrpTmplToDept(R_USER_GRP_TMPLBaseImpl child, boolean remove)
      {
         if ( UserGrpTmplToDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( UserGrpTmplToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  UserGrpTmplToDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! UserGrpTmplToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  UserGrpTmplToDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_VEND_LSTs2(R_VEND_LSTBaseImpl child, boolean remove)
      {
         if ( R_VEND_LSTs2Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_VEND_LSTs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_VEND_LSTs2Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_VEND_LSTs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_VEND_LSTs2Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForREQ_ACTV_SACTVs(REQ_ACTV_SACTVBaseImpl child, boolean remove)
      {
         if ( REQ_ACTV_SACTVsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( REQ_ACTV_SACTVsCache.containsKey(child.getRow().getPkeyParams()) )
                  REQ_ACTV_SACTVsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! REQ_ACTV_SACTVsCache.containsKey(child.getRow().getPkeyParams()) )
                  REQ_ACTV_SACTVsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForREQ_DEPT_OBJ_REVs(REQ_DEPT_OBJ_REVBaseImpl child, boolean remove)
      {
         if ( REQ_DEPT_OBJ_REVsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( REQ_DEPT_OBJ_REVsCache.containsKey(child.getRow().getPkeyParams()) )
                  REQ_DEPT_OBJ_REVsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! REQ_DEPT_OBJ_REVsCache.containsKey(child.getRow().getPkeyParams()) )
                  REQ_DEPT_OBJ_REVsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForReqFundDeptToRDept(REQ_FUND_DEPTBaseImpl child, boolean remove)
      {
         if ( ReqFundDeptToRDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( ReqFundDeptToRDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  ReqFundDeptToRDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! ReqFundDeptToRDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  ReqFundDeptToRDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForREQ_FUND_UNIT_OBJs(REQ_FUND_UNIT_OBJBaseImpl child, boolean remove)
      {
         if ( REQ_FUND_UNIT_OBJsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( REQ_FUND_UNIT_OBJsCache.containsKey(child.getRow().getPkeyParams()) )
                  REQ_FUND_UNIT_OBJsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! REQ_FUND_UNIT_OBJsCache.containsKey(child.getRow().getPkeyParams()) )
                  REQ_FUND_UNIT_OBJsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForREQ_FUND_UNIT_RSRCs(REQ_FUND_UNIT_RSRCBaseImpl child, boolean remove)
      {
         if ( REQ_FUND_UNIT_RSRCsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( REQ_FUND_UNIT_RSRCsCache.containsKey(child.getRow().getPkeyParams()) )
                  REQ_FUND_UNIT_RSRCsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! REQ_FUND_UNIT_RSRCsCache.containsKey(child.getRow().getPkeyParams()) )
                  REQ_FUND_UNIT_RSRCsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForREQ_UNITs(REQ_UNITBaseImpl child, boolean remove)
      {
         if ( REQ_UNITsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( REQ_UNITsCache.containsKey(child.getRow().getPkeyParams()) )
                  REQ_UNITsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! REQ_UNITsCache.containsKey(child.getRow().getPkeyParams()) )
                  REQ_UNITsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToReqUnitProg(REQ_UNIT_PROGBaseImpl child, boolean remove)
      {
         if ( DeptToReqUnitProgCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToReqUnitProgCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToReqUnitProgCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToReqUnitProgCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToReqUnitProgCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForREQ_UNIT_SUNITs(REQ_UNIT_SUNITBaseImpl child, boolean remove)
      {
         if ( REQ_UNIT_SUNITsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( REQ_UNIT_SUNITsCache.containsKey(child.getRow().getPkeyParams()) )
                  REQ_UNIT_SUNITsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! REQ_UNIT_SUNITsCache.containsKey(child.getRow().getPkeyParams()) )
                  REQ_UNIT_SUNITsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_OTPT_PARM_DETs3(R_OTPT_PARM_DETBaseImpl child, boolean remove)
      {
         if ( R_OTPT_PARM_DETs3Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_OTPT_PARM_DETs3Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_OTPT_PARM_DETs3Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_OTPT_PARM_DETs3Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_OTPT_PARM_DETs3Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRGrntrEvntSched2(R_GRNTR_EVNT_SCHEDBaseImpl child, boolean remove)
      {
         if ( RDeptToRGrntrEvntSched2Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRGrntrEvntSched2Cache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntrEvntSched2Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRGrntrEvntSched2Cache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntrEvntSched2Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_FARO_PARMs3(R_FARO_PARMBaseImpl child, boolean remove)
      {
         if ( R_FARO_PARMs3Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_FARO_PARMs3Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_FARO_PARMs3Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_FARO_PARMs3Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_FARO_PARMs3Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToClmtrk1(R_CLMTRKBaseImpl child, boolean remove)
      {
         if ( DeptToClmtrk1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToClmtrk1Cache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToClmtrk1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToClmtrk1Cache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToClmtrk1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToGtDocProgMgmtUsr(GT_DOC_PMGMTUSRBaseImpl child, boolean remove)
      {
         if ( RDeptToGtDocProgMgmtUsrCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToGtDocProgMgmtUsrCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToGtDocProgMgmtUsrCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToGtDocProgMgmtUsrCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToGtDocProgMgmtUsrCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForACRL_CLR_EXCL(ACRL_CLR_EXCLBaseImpl child, boolean remove)
      {
         if ( ACRL_CLR_EXCLCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( ACRL_CLR_EXCLCache.containsKey(child.getRow().getPkeyParams()) )
                  ACRL_CLR_EXCLCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! ACRL_CLR_EXCLCache.containsKey(child.getRow().getPkeyParams()) )
                  ACRL_CLR_EXCLCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRQ_DOC_CMPSHT(RQ_DOC_CMPSHTBaseImpl child, boolean remove)
      {
         if ( RQ_DOC_CMPSHTCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RQ_DOC_CMPSHTCache.containsKey(child.getRow().getPkeyParams()) )
                  RQ_DOC_CMPSHTCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RQ_DOC_CMPSHTCache.containsKey(child.getRow().getPkeyParams()) )
                  RQ_DOC_CMPSHTCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_MJR_PGRPs1(R_MJR_PGRPBaseImpl child, boolean remove)
      {
         if ( R_MJR_PGRPs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_MJR_PGRPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_MJR_PGRPs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_MJR_PGRPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_MJR_PGRPs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForIntrActgToDocDept(R_INTR_ACTG_CRSWLKBaseImpl child, boolean remove)
      {
         if ( IntrActgToDocDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( IntrActgToDocDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  IntrActgToDocDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! IntrActgToDocDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  IntrActgToDocDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForFacpatToDept(R_FACPATBaseImpl child, boolean remove)
      {
         if ( FacpatToDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( FacpatToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  FacpatToDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! FacpatToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  FacpatToDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForFacpadToDept(R_FACPADBaseImpl child, boolean remove)
      {
         if ( FacpadToDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( FacpadToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  FacpadToDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! FacpadToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  FacpadToDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_DOCATs1(R_DOCATBaseImpl child, boolean remove)
      {
         if ( R_DOCATs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_DOCATs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DOCATs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_DOCATs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DOCATs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDept_RBfyStpfSpnd(R_BFY_STPF_SPNDBaseImpl child, boolean remove)
      {
         if ( RDept_RBfyStpfSpndCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDept_RBfyStpfSpndCache.containsKey(child.getRow().getPkeyParams()) )
                  RDept_RBfyStpfSpndCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDept_RBfyStpfSpndCache.containsKey(child.getRow().getPkeyParams()) )
                  RDept_RBfyStpfSpndCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_AP_DISB_PARMs3(R_AP_DISB_PARMBaseImpl child, boolean remove)
      {
         if ( R_AP_DISB_PARMs3Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_AP_DISB_PARMs3Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_AP_DISB_PARMs3Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_AP_DISB_PARMs3Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_AP_DISB_PARMs3Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForMMRDocHdrDept(MMR_DOC_HDRBaseImpl child, boolean remove)
      {
         if ( MMRDocHdrDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( MMRDocHdrDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  MMRDocHdrDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! MMRDocHdrDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  MMRDocHdrDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToMaSrtyIns(MA_DOC_SRTYINSBaseImpl child, boolean remove)
      {
         if ( DeptToMaSrtyInsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToMaSrtyInsCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToMaSrtyInsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToMaSrtyInsCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToMaSrtyInsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToFndCDocFndC(FNDC_DOC_FNDCBaseImpl child, boolean remove)
      {
         if ( DeptToFndCDocFndCCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToFndCDocFndCCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToFndCDocFndCCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToFndCDocFndCCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToFndCDocFndCCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRqstDeptToCMRDocHdr(CMR_DOC_HDRBaseImpl child, boolean remove)
      {
         if ( RqstDeptToCMRDocHdrCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RqstDeptToCMRDocHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  RqstDeptToCMRDocHdrCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RqstDeptToCMRDocHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  RqstDeptToCMRDocHdrCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_TASKs1(R_TASKBaseImpl child, boolean remove)
      {
         if ( R_TASKs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_TASKs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_TASKs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_TASKs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_TASKs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRPayHldTin(R_PYMT_HLD_TINBaseImpl child, boolean remove)
      {
         if ( RDeptToRPayHldTinCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRPayHldTinCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRPayHldTinCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRPayHldTinCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRPayHldTinCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRFsc(R_FSCBaseImpl child, boolean remove)
      {
         if ( RDeptToRFscCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRFscCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRFscCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRFscCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRFscCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_FIN_CHRG_SETP(R_FIN_CHRG_SETPBaseImpl child, boolean remove)
      {
         if ( R_FIN_CHRG_SETPCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_FIN_CHRG_SETPCache.containsKey(child.getRow().getPkeyParams()) )
                  R_FIN_CHRG_SETPCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_FIN_CHRG_SETPCache.containsKey(child.getRow().getPkeyParams()) )
                  R_FIN_CHRG_SETPCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_FARO_PARMs2(R_FARO_PARMBaseImpl child, boolean remove)
      {
         if ( R_FARO_PARMs2Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_FARO_PARMs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_FARO_PARMs2Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_FARO_PARMs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_FARO_PARMs2Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRCntrcGlln1(R_CNTRC_GOAL_LNBaseImpl child, boolean remove)
      {
         if ( RDeptToRCntrcGlln1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRCntrcGlln1Cache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRCntrcGlln1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRCntrcGlln1Cache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRCntrcGlln1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDept_RBfyStpfBsa(R_BFY_STPF_BSABaseImpl child, boolean remove)
      {
         if ( RDept_RBfyStpfBsaCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDept_RBfyStpfBsaCache.containsKey(child.getRow().getPkeyParams()) )
                  RDept_RBfyStpfBsaCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDept_RBfyStpfBsaCache.containsKey(child.getRow().getPkeyParams()) )
                  RDept_RBfyStpfBsaCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRAdcParm(R_ADC_PARMBaseImpl child, boolean remove)
      {
         if ( RDeptToRAdcParmCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRAdcParmCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRAdcParmCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRAdcParmCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRAdcParmCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToGtDocPrtnrUsr(GT_DOC_PRTNRUSRBaseImpl child, boolean remove)
      {
         if ( RDeptToGtDocPrtnrUsrCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToGtDocPrtnrUsrCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToGtDocPrtnrUsrCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToGtDocPrtnrUsrCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToGtDocPrtnrUsrCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRdeptToCsalProcParm(CSAL_PROC_PARMBaseImpl child, boolean remove)
      {
         if ( RdeptToCsalProcParmCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RdeptToCsalProcParmCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToCsalProcParmCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RdeptToCsalProcParmCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToCsalProcParmCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForVmPrvntDept(VCM_DOC_PRVNTBaseImpl child, boolean remove)
      {
         if ( VmPrvntDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( VmPrvntDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  VmPrvntDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! VmPrvntDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  VmPrvntDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRUtlyActgPrfl(R_UTLY_ACTG_PRFLBaseImpl child, boolean remove)
      {
         if ( RDeptToRUtlyActgPrflCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRUtlyActgPrflCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRUtlyActgPrflCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRUtlyActgPrflCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRUtlyActgPrflCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_UNITs2(R_UNITBaseImpl child, boolean remove)
      {
         if ( R_UNITs2Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_UNITs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_UNITs2Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_UNITs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_UNITs2Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_TASK_ORDs1(R_TASK_ORDBaseImpl child, boolean remove)
      {
         if ( R_TASK_ORDs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_TASK_ORDs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_TASK_ORDs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_TASK_ORDs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_TASK_ORDs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRRgn(R_RGNBaseImpl child, boolean remove)
      {
         if ( RDeptToRRgnCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRRgnCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRRgnCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRRgnCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRRgnCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_PGRPs1(R_PGRPBaseImpl child, boolean remove)
      {
         if ( R_PGRPs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_PGRPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_PGRPs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_PGRPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_PGRPs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToPartUsg(R_PART_USGBaseImpl child, boolean remove)
      {
         if ( DeptToPartUsgCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToPartUsgCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToPartUsgCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToPartUsgCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToPartUsgCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_MJR_PTYPs1(R_MJR_PTYPBaseImpl child, boolean remove)
      {
         if ( R_MJR_PTYPs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_MJR_PTYPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_MJR_PTYPs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_MJR_PTYPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_MJR_PTYPs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_DSTCs1(R_DSTCBaseImpl child, boolean remove)
      {
         if ( R_DSTCs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_DSTCs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DSTCs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_DSTCs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DSTCs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRCntrcGlln(R_CNTRC_GOAL_LNBaseImpl child, boolean remove)
      {
         if ( RDeptToRCntrcGllnCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRCntrcGllnCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRCntrcGllnCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRCntrcGllnCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRCntrcGllnCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRCashSweepToRDept(R_CASH_SW_SETPBaseImpl child, boolean remove)
      {
         if ( RCashSweepToRDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RCashSweepToRDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  RCashSweepToRDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RCashSweepToRDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  RCashSweepToRDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_AP_CLM_ACCTs1(R_AP_CLM_ACCTBaseImpl child, boolean remove)
      {
         if ( R_AP_CLM_ACCTs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_AP_CLM_ACCTs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_AP_CLM_ACCTs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_AP_CLM_ACCTs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_AP_CLM_ACCTs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToAltDept(R_ALT_ORG_STRUCTBaseImpl child, boolean remove)
      {
         if ( DeptToAltDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToAltDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToAltDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToAltDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToAltDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForONLN_PRN_BAT_PARM1(ONLN_PRN_BAT_PARMBaseImpl child, boolean remove)
      {
         if ( ONLN_PRN_BAT_PARM1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( ONLN_PRN_BAT_PARM1Cache.containsKey(child.getRow().getPkeyParams()) )
                  ONLN_PRN_BAT_PARM1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! ONLN_PRN_BAT_PARM1Cache.containsKey(child.getRow().getPkeyParams()) )
                  ONLN_PRN_BAT_PARM1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForINF_APPRs1(INF_APPRBaseImpl child, boolean remove)
      {
         if ( INF_APPRs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( INF_APPRs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  INF_APPRs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! INF_APPRs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  INF_APPRs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToGtDocRptuser(GT_DOC_RPTUSERBaseImpl child, boolean remove)
      {
         if ( RDeptToGtDocRptuserCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToGtDocRptuserCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToGtDocRptuserCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToGtDocRptuserCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToGtDocRptuserCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDOC_HDRs(DOC_HDRBaseImpl child, boolean remove)
      {
         if ( DOC_HDRsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DOC_HDRsCache.containsKey(child.getRow().getPkeyParams()) )
                  DOC_HDRsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DOC_HDRsCache.containsKey(child.getRow().getPkeyParams()) )
                  DOC_HDRsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForVmAuthDeptDept(VCM_DOC_AUTHDEPTBaseImpl child, boolean remove)
      {
         if ( VmAuthDeptDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( VmAuthDeptDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  VmAuthDeptDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! VmAuthDeptDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  VmAuthDeptDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_PRVNT_SPNDs(R_PRVNT_SPNDBaseImpl child, boolean remove)
      {
         if ( R_PRVNT_SPNDsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_PRVNT_SPNDsCache.containsKey(child.getRow().getPkeyParams()) )
                  R_PRVNT_SPNDsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_PRVNT_SPNDsCache.containsKey(child.getRow().getPkeyParams()) )
                  R_PRVNT_SPNDsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToPartRf(R_PART_RFBaseImpl child, boolean remove)
      {
         if ( DeptToPartRfCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToPartRfCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToPartRfCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToPartRfCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToPartRfCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRGrntrRpt(R_GRNTR_RPTBaseImpl child, boolean remove)
      {
         if ( RDeptToRGrntrRptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRGrntrRptCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntrRptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRGrntrRptCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntrRptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToDebtAuth(R_DEBT_AUTHBaseImpl child, boolean remove)
      {
         if ( DeptToDebtAuthCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToDebtAuthCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDebtAuthCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToDebtAuthCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDebtAuthCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRdeptToRcsalSrctrSetp(R_CSAL_SRCTR_SETPBaseImpl child, boolean remove)
      {
         if ( RdeptToRcsalSrctrSetpCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RdeptToRcsalSrctrSetpCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToRcsalSrctrSetpCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RdeptToRcsalSrctrSetpCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToRcsalSrctrSetpCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRApUprocPrcuAl(R_AP_UPROC_PRCU_ALBaseImpl child, boolean remove)
      {
         if ( RDeptToRApUprocPrcuAlCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRApUprocPrcuAlCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRApUprocPrcuAlCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRApUprocPrcuAlCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRApUprocPrcuAlCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToApCwChk(R_AP_CW_CHK_NOBaseImpl child, boolean remove)
      {
         if ( DeptToApCwChkCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToApCwChkCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToApCwChkCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToApCwChkCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToApCwChkCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDept1ToRAdcParm1(R_ADC_PARMBaseImpl child, boolean remove)
      {
         if ( RDept1ToRAdcParm1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDept1ToRAdcParm1Cache.containsKey(child.getRow().getPkeyParams()) )
                  RDept1ToRAdcParm1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDept1ToRAdcParm1Cache.containsKey(child.getRow().getPkeyParams()) )
                  RDept1ToRAdcParm1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToMDHdr(MD_DOC_HDRBaseImpl child, boolean remove)
      {
         if ( DeptToMDHdrCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToMDHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToMDHdrCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToMDHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToMDHdrCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToCamProcParm(CAM_PROC_PARMBaseImpl child, boolean remove)
      {
         if ( DeptToCamProcParmCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToCamProcParmCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCamProcParmCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToCamProcParmCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCamProcParmCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRdeptToRstatUnitSetp(R_STAT_UNIT_SETPBaseImpl child, boolean remove)
      {
         if ( RdeptToRstatUnitSetpCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RdeptToRstatUnitSetpCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToRstatUnitSetpCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RdeptToRstatUnitSetpCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToRstatUnitSetpCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToProgSta(R_PROG_STABaseImpl child, boolean remove)
      {
         if ( DeptToProgStaCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToProgStaCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToProgStaCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToProgStaCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToProgStaCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_PROGs2(R_PROGBaseImpl child, boolean remove)
      {
         if ( R_PROGs2Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_PROGs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_PROGs2Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_PROGs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_PROGs2Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToOnGoingAwardInfo(R_ONGOING_AWD_INFOBaseImpl child, boolean remove)
      {
         if ( DeptToOnGoingAwardInfoCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToOnGoingAwardInfoCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToOnGoingAwardInfoCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToOnGoingAwardInfoCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToOnGoingAwardInfoCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForNegDrawExcpDtlRecs(R_NEG_DRW_EXCP_DTLBaseImpl child, boolean remove)
      {
         if ( NegDrawExcpDtlRecsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( NegDrawExcpDtlRecsCache.containsKey(child.getRow().getPkeyParams()) )
                  NegDrawExcpDtlRecsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! NegDrawExcpDtlRecsCache.containsKey(child.getRow().getPkeyParams()) )
                  NegDrawExcpDtlRecsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_LCLSs1(R_LCLSBaseImpl child, boolean remove)
      {
         if ( R_LCLSs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_LCLSs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_LCLSs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_LCLSs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_LCLSs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToGrntNotifUsr(R_GRNT_NOTIFUSRBaseImpl child, boolean remove)
      {
         if ( DeptToGrntNotifUsrCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToGrntNotifUsrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGrntNotifUsrCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToGrntNotifUsrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGrntNotifUsrCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDept2ToRAdcParm2(R_ADC_PARMBaseImpl child, boolean remove)
      {
         if ( RDept2ToRAdcParm2Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDept2ToRAdcParm2Cache.containsKey(child.getRow().getPkeyParams()) )
                  RDept2ToRAdcParm2Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDept2ToRAdcParm2Cache.containsKey(child.getRow().getPkeyParams()) )
                  RDept2ToRAdcParm2Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_ACATs1(R_ACATBaseImpl child, boolean remove)
      {
         if ( R_ACATs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_ACATs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_ACATs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_ACATs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_ACATs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForLrdsToDept1(LIC_RNEW_DT_STRGBaseImpl child, boolean remove)
      {
         if ( LrdsToDept1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( LrdsToDept1Cache.containsKey(child.getRow().getPkeyParams()) )
                  LrdsToDept1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! LrdsToDept1Cache.containsKey(child.getRow().getPkeyParams()) )
                  LrdsToDept1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForLrdsToDept(LIC_RNEW_DT_STRGBaseImpl child, boolean remove)
      {
         if ( LrdsToDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( LrdsToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  LrdsToDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! LrdsToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  LrdsToDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToARRADocSRcpQtr(ARRA_DOC_SRCPQTRBaseImpl child, boolean remove)
      {
         if ( DeptToARRADocSRcpQtrCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToARRADocSRcpQtrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToARRADocSRcpQtrCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToARRADocSRcpQtrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToARRADocSRcpQtrCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForACRL_CLR_MGMT_2(ACRL_CLR_MGMTBaseImpl child, boolean remove)
      {
         if ( ACRL_CLR_MGMT_2Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( ACRL_CLR_MGMT_2Cache.containsKey(child.getRow().getPkeyParams()) )
                  ACRL_CLR_MGMT_2Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! ACRL_CLR_MGMT_2Cache.containsKey(child.getRow().getPkeyParams()) )
                  ACRL_CLR_MGMT_2Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForTRVLCoaOVrdToRDept(TRVL_COA_OVRDBaseImpl child, boolean remove)
      {
         if ( TRVLCoaOVrdToRDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( TRVLCoaOVrdToRDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  TRVLCoaOVrdToRDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! TRVLCoaOVrdToRDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  TRVLCoaOVrdToRDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToSrcOfFund(R_SRC_OF_FUNDBaseImpl child, boolean remove)
      {
         if ( DeptToSrcOfFundCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToSrcOfFundCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToSrcOfFundCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToSrcOfFundCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToSrcOfFundCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_REIM_GEN_PARAM(R_REIM_GEN_PARAMBaseImpl child, boolean remove)
      {
         if ( R_REIM_GEN_PARAMCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_REIM_GEN_PARAMCache.containsKey(child.getRow().getPkeyParams()) )
                  R_REIM_GEN_PARAMCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_REIM_GEN_PARAMCache.containsKey(child.getRow().getPkeyParams()) )
                  R_REIM_GEN_PARAMCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDocDeptToReimExpAdj(R_REIM_EXP_ADJBaseImpl child, boolean remove)
      {
         if ( DocDeptToReimExpAdjCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DocDeptToReimExpAdjCache.containsKey(child.getRow().getPkeyParams()) )
                  DocDeptToReimExpAdjCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DocDeptToReimExpAdjCache.containsKey(child.getRow().getPkeyParams()) )
                  DocDeptToReimExpAdjCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRFAIntnExcepToRDept(R_FA_INTN_EXCEPTBaseImpl child, boolean remove)
      {
         if ( RFAIntnExcepToRDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RFAIntnExcepToRDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  RFAIntnExcepToRDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RFAIntnExcepToRDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  RFAIntnExcepToRDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToDebtHist1(R_DEBT_HISTBaseImpl child, boolean remove)
      {
         if ( DeptToDebtHist1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToDebtHist1Cache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDebtHist1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToDebtHist1Cache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDebtHist1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_CORSPDs1(R_CORSPDBaseImpl child, boolean remove)
      {
         if ( R_CORSPDs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_CORSPDs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_CORSPDs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_CORSPDs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_CORSPDs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToCWCanParm(R_AP_CWCAN_PARMBaseImpl child, boolean remove)
      {
         if ( DeptToCWCanParmCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToCWCanParmCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCWCanParmCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToCWCanParmCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCWCanParmCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToAutoCano(AUTO_CA_NOBaseImpl child, boolean remove)
      {
         if ( DeptToAutoCanoCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToAutoCanoCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToAutoCanoCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToAutoCanoCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToAutoCanoCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForTRVLCoaOvrdToDept(TRVL_COA_OVRDBaseImpl child, boolean remove)
      {
         if ( TRVLCoaOvrdToDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( TRVLCoaOvrdToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  TRVLCoaOvrdToDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! TRVLCoaOvrdToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  TRVLCoaOvrdToDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDept1ToTaskOrdBuyrLn1(R_TASK_ORD_BUYR_LNBaseImpl child, boolean remove)
      {
         if ( Dept1ToTaskOrdBuyrLn1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( Dept1ToTaskOrdBuyrLn1Cache.containsKey(child.getRow().getPkeyParams()) )
                  Dept1ToTaskOrdBuyrLn1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! Dept1ToTaskOrdBuyrLn1Cache.containsKey(child.getRow().getPkeyParams()) )
                  Dept1ToTaskOrdBuyrLn1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToTaskOrdBuyrLn(R_TASK_ORD_BUYR_LNBaseImpl child, boolean remove)
      {
         if ( DeptToTaskOrdBuyrLnCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToTaskOrdBuyrLnCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToTaskOrdBuyrLnCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToTaskOrdBuyrLnCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToTaskOrdBuyrLnCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_SYS_CROSWALKs(R_SYS_CROSWALKBaseImpl child, boolean remove)
      {
         if ( R_SYS_CROSWALKsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_SYS_CROSWALKsCache.containsKey(child.getRow().getPkeyParams()) )
                  R_SYS_CROSWALKsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_SYS_CROSWALKsCache.containsKey(child.getRow().getPkeyParams()) )
                  R_SYS_CROSWALKsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_PTYPs1(R_PTYPBaseImpl child, boolean remove)
      {
         if ( R_PTYPs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_PTYPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_PTYPs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_PTYPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_PTYPs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRdeptToRplbsOfstReq(R_PLBS_OFST_REQBaseImpl child, boolean remove)
      {
         if ( RdeptToRplbsOfstReqCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RdeptToRplbsOfstReqCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToRplbsOfstReqCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RdeptToRplbsOfstReqCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToRplbsOfstReqCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRdeptToRplbsDist(R_PLBS_DISTBaseImpl child, boolean remove)
      {
         if ( RdeptToRplbsDistCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RdeptToRplbsDistCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToRplbsDistCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RdeptToRplbsDistCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToRplbsDistCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRGrntrRpt1(R_GRNTR_RPTBaseImpl child, boolean remove)
      {
         if ( RDeptToRGrntrRpt1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRGrntrRpt1Cache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntrRpt1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRGrntrRpt1Cache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntrRpt1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_FNCATs1(R_FNCATBaseImpl child, boolean remove)
      {
         if ( R_FNCATs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_FNCATs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_FNCATs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_FNCATs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_FNCATs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRdeptToRcsalStpctrSetp(R_CSAL_STPCTR_SETPBaseImpl child, boolean remove)
      {
         if ( RdeptToRcsalStpctrSetpCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RdeptToRcsalStpctrSetpCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToRcsalStpctrSetpCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RdeptToRcsalStpctrSetpCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToRcsalStpctrSetpCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_BURs1(R_BURBaseImpl child, boolean remove)
      {
         if ( R_BURs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_BURs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_BURs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_BURs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_BURs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDept_RBfyStpfNactg(R_BFY_STPF_NACTGBaseImpl child, boolean remove)
      {
         if ( RDept_RBfyStpfNactgCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDept_RBfyStpfNactgCache.containsKey(child.getRow().getPkeyParams()) )
                  RDept_RBfyStpfNactgCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDept_RBfyStpfNactgCache.containsKey(child.getRow().getPkeyParams()) )
                  RDept_RBfyStpfNactgCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForAUTO_DOC_NOs(AUTO_DOC_NOBaseImpl child, boolean remove)
      {
         if ( AUTO_DOC_NOsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( AUTO_DOC_NOsCache.containsKey(child.getRow().getPkeyParams()) )
                  AUTO_DOC_NOsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! AUTO_DOC_NOsCache.containsKey(child.getRow().getPkeyParams()) )
                  AUTO_DOC_NOsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptVcVcust(VCC_DOC_VCUSTBaseImpl child, boolean remove)
      {
         if ( RDeptVcVcustCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptVcVcustCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptVcVcustCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptVcVcustCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptVcVcustCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptVcAuthDept(VCC_DOC_AUTHDEPTBaseImpl child, boolean remove)
      {
         if ( RDeptVcAuthDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptVcAuthDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptVcAuthDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptVcAuthDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptVcAuthDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRQ_DOC_HDR(RQ_DOC_HDRBaseImpl child, boolean remove)
      {
         if ( RQ_DOC_HDRCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RQ_DOC_HDRCache.containsKey(child.getRow().getPkeyParams()) )
                  RQ_DOC_HDRCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RQ_DOC_HDRCache.containsKey(child.getRow().getPkeyParams()) )
                  RQ_DOC_HDRCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForReimReqRcycSelToDept(R_REIMRQD_RCYCSELBaseImpl child, boolean remove)
      {
         if ( ReimReqRcycSelToDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( ReimReqRcycSelToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  ReimReqRcycSelToDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! ReimReqRcycSelToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  ReimReqRcycSelToDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRPrtst(R_PRTSTBaseImpl child, boolean remove)
      {
         if ( RDeptToRPrtstCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRPrtstCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRPrtstCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRPrtstCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRPrtstCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_LOC_TBLs1(R_LOC_TBLBaseImpl child, boolean remove)
      {
         if ( R_LOC_TBLs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_LOC_TBLs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_LOC_TBLs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_LOC_TBLs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_LOC_TBLs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDept1ToRIntCst(R_INT_CST_PARMBaseImpl child, boolean remove)
      {
         if ( RDept1ToRIntCstCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDept1ToRIntCstCache.containsKey(child.getRow().getPkeyParams()) )
                  RDept1ToRIntCstCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDept1ToRIntCstCache.containsKey(child.getRow().getPkeyParams()) )
                  RDept1ToRIntCstCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRGrntrEvntSched(R_GRNTR_EVNT_SCHEDBaseImpl child, boolean remove)
      {
         if ( RDeptToRGrntrEvntSchedCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRGrntrEvntSchedCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntrEvntSchedCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRGrntrEvntSchedCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntrEvntSchedCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToEscrowHist(R_ESCROW_HISTBaseImpl child, boolean remove)
      {
         if ( DeptToEscrowHistCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToEscrowHistCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToEscrowHistCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToEscrowHistCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToEscrowHistCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_DISB_MGMT_RSTRs2(R_DISB_MGMT_RSTRBaseImpl child, boolean remove)
      {
         if ( R_DISB_MGMT_RSTRs2Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_DISB_MGMT_RSTRs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DISB_MGMT_RSTRs2Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_DISB_MGMT_RSTRs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DISB_MGMT_RSTRs2Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToDebtDocDebtInst(DEBT_DOC_DEBTINSTBaseImpl child, boolean remove)
      {
         if ( DeptToDebtDocDebtInstCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToDebtDocDebtInstCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDebtDocDebtInstCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToDebtDocDebtInstCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDebtDocDebtInstCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForSO_DOC_HDRs2(SO_DOC_HDRBaseImpl child, boolean remove)
      {
         if ( SO_DOC_HDRs2Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( SO_DOC_HDRs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  SO_DOC_HDRs2Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! SO_DOC_HDRs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  SO_DOC_HDRs2Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToREquip(R_EQUIPBaseImpl child, boolean remove)
      {
         if ( RDeptToREquipCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToREquipCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToREquipCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToREquipCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToREquipCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_DRSCLSs1(R_DRSCLSBaseImpl child, boolean remove)
      {
         if ( R_DRSCLSs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_DRSCLSs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DRSCLSs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_DRSCLSs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DRSCLSs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_DIVs1(R_DIVBaseImpl child, boolean remove)
      {
         if ( R_DIVs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_DIVs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DIVs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_DIVs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DIVs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToPHMDocLn(PHM_DOC_LINEBaseImpl child, boolean remove)
      {
         if ( RDeptToPHMDocLnCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToPHMDocLnCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToPHMDocLnCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToPHMDocLnCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToPHMDocLnCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToInfApBY2(INF_APBY2BaseImpl child, boolean remove)
      {
         if ( DeptToInfApBY2Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToInfApBY2Cache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfApBY2Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToInfApBY2Cache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfApBY2Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToApEdiHdr(AP_EDI_HDRBaseImpl child, boolean remove)
      {
         if ( DeptToApEdiHdrCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToApEdiHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToApEdiHdrCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToApEdiHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToApEdiHdrCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToReimExpAdj(R_REIM_EXP_ADJBaseImpl child, boolean remove)
      {
         if ( DeptToReimExpAdjCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToReimExpAdjCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToReimExpAdjCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToReimExpAdjCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToReimExpAdjCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForPrgDocCrsRefToDept(R_PROG_DOC_CRSREFBaseImpl child, boolean remove)
      {
         if ( PrgDocCrsRefToDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( PrgDocCrsRefToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  PrgDocCrsRefToDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! PrgDocCrsRefToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  PrgDocCrsRefToDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_PHASEs(R_PHASEBaseImpl child, boolean remove)
      {
         if ( R_PHASEsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_PHASEsCache.containsKey(child.getRow().getPkeyParams()) )
                  R_PHASEsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_PHASEsCache.containsKey(child.getRow().getPkeyParams()) )
                  R_PHASEsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_LOCs2(R_LOCBaseImpl child, boolean remove)
      {
         if ( R_LOCs2Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_LOCs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_LOCs2Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_LOCs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_LOCs2Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRGrntDtDet(R_GRNT_DT_DETBaseImpl child, boolean remove)
      {
         if ( RDeptToRGrntDtDetCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRGrntDtDetCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntDtDetCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRGrntDtDetCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntDtDetCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRGrntrEvntSched1(R_GRNTR_EVNT_SCHEDBaseImpl child, boolean remove)
      {
         if ( RDeptToRGrntrEvntSched1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRGrntrEvntSched1Cache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntrEvntSched1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRGrntrEvntSched1Cache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntrEvntSched1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToFDTOpt(R_FDT_OPTBaseImpl child, boolean remove)
      {
         if ( DeptToFDTOptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToFDTOptCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToFDTOptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToFDTOptCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToFDTOptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_DRSRCs1(R_DRSRCBaseImpl child, boolean remove)
      {
         if ( R_DRSRCs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_DRSRCs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DRSRCs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_DRSRCs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DRSRCs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_DOCLSs1(R_DOCLSBaseImpl child, boolean remove)
      {
         if ( R_DOCLSs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_DOCLSs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DOCLSs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_DOCLSs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DOCLSs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRdeptToRcsalCtrlSetp(R_CSAL_CTRL_SETPBaseImpl child, boolean remove)
      {
         if ( RdeptToRcsalCtrlSetpCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RdeptToRcsalCtrlSetpCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToRcsalCtrlSetpCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RdeptToRcsalCtrlSetpCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToRcsalCtrlSetpCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_BUYR_FLINEs2(R_BUYR_FLINEBaseImpl child, boolean remove)
      {
         if ( R_BUYR_FLINEs2Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_BUYR_FLINEs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_BUYR_FLINEs2Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_BUYR_FLINEs2Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_BUYR_FLINEs2Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToAlwPymntByDebt(R_ALW_PYMT_DBTYPBaseImpl child, boolean remove)
      {
         if ( DeptToAlwPymntByDebtCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToAlwPymntByDebtCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToAlwPymntByDebtCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToAlwPymntByDebtCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToAlwPymntByDebtCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForGnBudRuleToDept(GN_BUD_RULEBaseImpl child, boolean remove)
      {
         if ( GnBudRuleToDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( GnBudRuleToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  GnBudRuleToDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! GnBudRuleToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  GnBudRuleToDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_RSTR_USEs(R_RSTR_USEBaseImpl child, boolean remove)
      {
         if ( R_RSTR_USEsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_RSTR_USEsCache.containsKey(child.getRow().getPkeyParams()) )
                  R_RSTR_USEsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_RSTR_USEsCache.containsKey(child.getRow().getPkeyParams()) )
                  R_RSTR_USEsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_FACCs(R_FACCBaseImpl child, boolean remove)
      {
         if ( R_FACCsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_FACCsCache.containsKey(child.getRow().getPkeyParams()) )
                  R_FACCsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_FACCsCache.containsKey(child.getRow().getPkeyParams()) )
                  R_FACCsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForECRTToDept(R_EXTR_CASH_RECTBaseImpl child, boolean remove)
      {
         if ( ECRTToDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( ECRTToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  ECRTToDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! ECRTToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  ECRTToDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_DOGRPs1(R_DOGRPBaseImpl child, boolean remove)
      {
         if ( R_DOGRPs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_DOGRPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DOGRPs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_DOGRPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DOGRPs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToClmtrk(R_CLMTRKBaseImpl child, boolean remove)
      {
         if ( DeptToClmtrkCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToClmtrkCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToClmtrkCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToClmtrkCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToClmtrkCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToCADocHist(R_CA_DOC_HISTBaseImpl child, boolean remove)
      {
         if ( DeptToCADocHistCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToCADocHistCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCADocHistCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToCADocHistCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToCADocHistCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToDisbExcp(R_AP_DISB_EXCPBaseImpl child, boolean remove)
      {
         if ( DeptToDisbExcpCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToDisbExcpCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDisbExcpCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToDisbExcpCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDisbExcpCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_ACLSs1(R_ACLSBaseImpl child, boolean remove)
      {
         if ( R_ACLSs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_ACLSs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_ACLSs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_ACLSs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_ACLSs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDepartmentToElectronicFederalTaxPaymentSystem(ELEC_FED_TAXP_SYSBaseImpl child, boolean remove)
      {
         if ( DepartmentToElectronicFederalTaxPaymentSystemCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DepartmentToElectronicFederalTaxPaymentSystemCache.containsKey(child.getRow().getPkeyParams()) )
                  DepartmentToElectronicFederalTaxPaymentSystemCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DepartmentToElectronicFederalTaxPaymentSystemCache.containsKey(child.getRow().getPkeyParams()) )
                  DepartmentToElectronicFederalTaxPaymentSystemCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForACRL_CLR_MGMT_1(ACRL_CLR_MGMTBaseImpl child, boolean remove)
      {
         if ( ACRL_CLR_MGMT_1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( ACRL_CLR_MGMT_1Cache.containsKey(child.getRow().getPkeyParams()) )
                  ACRL_CLR_MGMT_1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! ACRL_CLR_MGMT_1Cache.containsKey(child.getRow().getPkeyParams()) )
                  ACRL_CLR_MGMT_1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_SECTs1(R_SECTBaseImpl child, boolean remove)
      {
         if ( R_SECTs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_SECTs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_SECTs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_SECTs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_SECTs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForPrgDocCrsRef1ToDept_1(R_PROG_DOC_CRSREFBaseImpl child, boolean remove)
      {
         if ( PrgDocCrsRef1ToDept_1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( PrgDocCrsRef1ToDept_1Cache.containsKey(child.getRow().getPkeyParams()) )
                  PrgDocCrsRef1ToDept_1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! PrgDocCrsRef1ToDept_1Cache.containsKey(child.getRow().getPkeyParams()) )
                  PrgDocCrsRef1ToDept_1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForIntrActgToDept(R_INTR_ACTG_CRSWLKBaseImpl child, boolean remove)
      {
         if ( IntrActgToDeptCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( IntrActgToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  IntrActgToDeptCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! IntrActgToDeptCache.containsKey(child.getRow().getPkeyParams()) )
                  IntrActgToDeptCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_DOTYPs1(R_DOTYPBaseImpl child, boolean remove)
      {
         if ( R_DOTYPs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_DOTYPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DOTYPs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_DOTYPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DOTYPs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRqstDeptToMaDocHdr(MA_DOC_HDRBaseImpl child, boolean remove)
      {
         if ( RqstDeptToMaDocHdrCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RqstDeptToMaDocHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  RqstDeptToMaDocHdrCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RqstDeptToMaDocHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  RqstDeptToMaDocHdrCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToInfAppr2(INF_APPR2BaseImpl child, boolean remove)
      {
         if ( DeptToInfAppr2Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToInfAppr2Cache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfAppr2Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToInfAppr2Cache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfAppr2Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToGRDocHdr(GR_DOC_HDRBaseImpl child, boolean remove)
      {
         if ( DeptToGRDocHdrCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToGRDocHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGRDocHdrCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToGRDocHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToGRDocHdrCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToDebtDocAuth(DEBT_DOC_AUTHBaseImpl child, boolean remove)
      {
         if ( DeptToDebtDocAuthCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToDebtDocAuthCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDebtDocAuthCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToDebtDocAuthCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDebtDocAuthCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToAutoPartNo(AUTO_PART_NOBaseImpl child, boolean remove)
      {
         if ( DeptToAutoPartNoCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToAutoPartNoCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToAutoPartNoCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToAutoPartNoCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToAutoPartNoCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToADHdr(AD_DOC_HDRBaseImpl child, boolean remove)
      {
         if ( DeptToADHdrCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToADHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToADHdrCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToADHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToADHdrCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRCLS_PARM_DTL1(RCLS_PARM_DTLBaseImpl child, boolean remove)
      {
         if ( RCLS_PARM_DTL1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RCLS_PARM_DTL1Cache.containsKey(child.getRow().getPkeyParams()) )
                  RCLS_PARM_DTL1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RCLS_PARM_DTL1Cache.containsKey(child.getRow().getPkeyParams()) )
                  RCLS_PARM_DTL1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToVcust(R_VEND_CUSTBaseImpl child, boolean remove)
      {
         if ( DeptToVcustCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToVcustCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToVcustCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToVcustCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToVcustCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToMsmals(R_MSMALSBaseImpl child, boolean remove)
      {
         if ( DeptToMsmalsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToMsmalsCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToMsmalsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToMsmalsCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToMsmalsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRIntCst(R_INT_CST_PARMBaseImpl child, boolean remove)
      {
         if ( RDeptToRIntCstCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRIntCstCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRIntCstCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRIntCstCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRIntCstCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_FUNCs1(R_FUNCBaseImpl child, boolean remove)
      {
         if ( R_FUNCs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_FUNCs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_FUNCs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_FUNCs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_FUNCs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRFac(R_FACBaseImpl child, boolean remove)
      {
         if ( RDeptToRFacCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRFacCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRFacCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRFacCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRFacCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToREmpInfo(R_EMP_INFOBaseImpl child, boolean remove)
      {
         if ( RDeptToREmpInfoCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToREmpInfoCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToREmpInfoCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToREmpInfoCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToREmpInfoCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToDeptTrvlxpPol(R_DEPT_TRVLXP_POLBaseImpl child, boolean remove)
      {
         if ( DeptToDeptTrvlxpPolCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToDeptTrvlxpPolCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDeptTrvlxpPolCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToDeptTrvlxpPolCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDeptTrvlxpPolCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToDebtDebtInst(R_DEBT_DEBTINSTBaseImpl child, boolean remove)
      {
         if ( DeptToDebtDebtInstCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToDebtDebtInstCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDebtDebtInstCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToDebtDebtInstCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToDebtDebtInstCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRCntrcGlhd(R_CNTRC_GOAL_HDRBaseImpl child, boolean remove)
      {
         if ( RDeptToRCntrcGlhdCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRCntrcGlhdCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRCntrcGlhdCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRCntrcGlhdCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRCntrcGlhdCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForACRL_CLR_MGMT(ACRL_CLR_MGMTBaseImpl child, boolean remove)
      {
         if ( ACRL_CLR_MGMTCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( ACRL_CLR_MGMTCache.containsKey(child.getRow().getPkeyParams()) )
                  ACRL_CLR_MGMTCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! ACRL_CLR_MGMTCache.containsKey(child.getRow().getPkeyParams()) )
                  ACRL_CLR_MGMTCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToABSHdr(ABS_DOC_HDRBaseImpl child, boolean remove)
      {
         if ( DeptToABSHdrCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToABSHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToABSHdrCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToABSHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToABSHdrCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToTrvlDocVend(TRVL_DOC_VENDBaseImpl child, boolean remove)
      {
         if ( DeptToTrvlDocVendCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToTrvlDocVendCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToTrvlDocVendCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToTrvlDocVendCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToTrvlDocVendCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_REIM_FREQ_DTs1(R_REIM_FREQ_DTBaseImpl child, boolean remove)
      {
         if ( R_REIM_FREQ_DTs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_REIM_FREQ_DTs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_REIM_FREQ_DTs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_REIM_FREQ_DTs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_REIM_FREQ_DTs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_OTPT_PARM_DETs5(R_OTPT_PARM_DETBaseImpl child, boolean remove)
      {
         if ( R_OTPT_PARM_DETs5Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_OTPT_PARM_DETs5Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_OTPT_PARM_DETs5Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_OTPT_PARM_DETs5Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_OTPT_PARM_DETs5Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_MGR(R_MGRBaseImpl child, boolean remove)
      {
         if ( R_MGRCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_MGRCache.containsKey(child.getRow().getPkeyParams()) )
                  R_MGRCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_MGRCache.containsKey(child.getRow().getPkeyParams()) )
                  R_MGRCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_GPs1(R_GPBaseImpl child, boolean remove)
      {
         if ( R_GPs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_GPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_GPs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_GPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_GPs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToREmplBenMulti(R_EMPL_BEN_MULTIBaseImpl child, boolean remove)
      {
         if ( RDeptToREmplBenMultiCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToREmplBenMultiCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToREmplBenMultiCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToREmplBenMultiCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToREmplBenMultiCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_DRSGRPs1(R_DRSGRPBaseImpl child, boolean remove)
      {
         if ( R_DRSGRPs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_DRSGRPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DRSGRPs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_DRSGRPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DRSGRPs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_DOBJs1(R_DOBJBaseImpl child, boolean remove)
      {
         if ( R_DOBJs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_DOBJs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DOBJs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_DOBJs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DOBJs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForPO_DOC_HDR(PO_DOC_HDRBaseImpl child, boolean remove)
      {
         if ( PO_DOC_HDRCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( PO_DOC_HDRCache.containsKey(child.getRow().getPkeyParams()) )
                  PO_DOC_HDRCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! PO_DOC_HDRCache.containsKey(child.getRow().getPkeyParams()) )
                  PO_DOC_HDRCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptVcPrvnt(VCC_DOC_PRVNTBaseImpl child, boolean remove)
      {
         if ( RDeptVcPrvntCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptVcPrvntCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptVcPrvntCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptVcPrvntCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptVcPrvntCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_PROG_GIS_LOC(R_PROG_GIS_LOCBaseImpl child, boolean remove)
      {
         if ( R_PROG_GIS_LOCCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_PROG_GIS_LOCCache.containsKey(child.getRow().getPkeyParams()) )
                  R_PROG_GIS_LOCCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_PROG_GIS_LOCCache.containsKey(child.getRow().getPkeyParams()) )
                  R_PROG_GIS_LOCCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToPartTyp(R_PART_TYPBaseImpl child, boolean remove)
      {
         if ( DeptToPartTypCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToPartTypCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToPartTypCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToPartTypCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToPartTypCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_LCATs1(R_LCATBaseImpl child, boolean remove)
      {
         if ( R_LCATs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_LCATs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_LCATs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_LCATs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_LCATs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRGrntAlrtUser(R_GRNT_ALRT_USERBaseImpl child, boolean remove)
      {
         if ( RDeptToRGrntAlrtUserCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRGrntAlrtUserCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntAlrtUserCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRGrntAlrtUserCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRGrntAlrtUserCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRFndgGrp(R_FNDG_GRPBaseImpl child, boolean remove)
      {
         if ( RDeptToRFndgGrpCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRFndgGrpCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRFndgGrpCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRFndgGrpCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRFndgGrpCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToRFgc(R_FGCBaseImpl child, boolean remove)
      {
         if ( RDeptToRFgcCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToRFgcCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRFgcCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToRFgcCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToRFgcCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToFarHdr(R_FAR_HDRBaseImpl child, boolean remove)
      {
         if ( RDeptToFarHdrCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToFarHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToFarHdrCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToFarHdrCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToFarHdrCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_DRSTYPs1(R_DRSTYPBaseImpl child, boolean remove)
      {
         if ( R_DRSTYPs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_DRSTYPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DRSTYPs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_DRSTYPs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DRSTYPs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_DRSCATs1(R_DRSCATBaseImpl child, boolean remove)
      {
         if ( R_DRSCATs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_DRSCATs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DRSCATs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_DRSCATs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DRSCATs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_ACTVs6(R_ACTVBaseImpl child, boolean remove)
      {
         if ( R_ACTVs6Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_ACTVs6Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_ACTVs6Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_ACTVs6Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_ACTVs6Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToPoSrtyIns(PO_DOC_SRTYINSBaseImpl child, boolean remove)
      {
         if ( DeptToPoSrtyInsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToPoSrtyInsCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToPoSrtyInsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToPoSrtyInsCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToPoSrtyInsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDptToROnPrnParmDflt(ONLN_PRN_PARM_DFLTBaseImpl child, boolean remove)
      {
         if ( RDptToROnPrnParmDfltCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDptToROnPrnParmDfltCache.containsKey(child.getRow().getPkeyParams()) )
                  RDptToROnPrnParmDfltCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDptToROnPrnParmDfltCache.containsKey(child.getRow().getPkeyParams()) )
                  RDptToROnPrnParmDfltCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToInfApBY(INF_APBYBaseImpl child, boolean remove)
      {
         if ( DeptToInfApBYCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToInfApBYCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfApBYCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToInfApBYCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToInfApBYCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDeptToGtDocAlrtuser(GT_DOC_ALRTUSERBaseImpl child, boolean remove)
      {
         if ( RDeptToGtDocAlrtuserCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDeptToGtDocAlrtuserCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToGtDocAlrtuserCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDeptToGtDocAlrtuserCache.containsKey(child.getRow().getPkeyParams()) )
                  RDeptToGtDocAlrtuserCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForFA_DOC_HDRs1(FA_DOC_HDRBaseImpl child, boolean remove)
      {
         if ( FA_DOC_HDRs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( FA_DOC_HDRs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  FA_DOC_HDRs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! FA_DOC_HDRs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  FA_DOC_HDRs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToARRADocOngoing(ARRA_DOC_ONGOINGBaseImpl child, boolean remove)
      {
         if ( DeptToARRADocOngoingCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToARRADocOngoingCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToARRADocOngoingCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToARRADocOngoingCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToARRADocOngoingCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDepartmentToSubRcpntQtrlyAwd(R_SRCPNT_QTRLY_AWDBaseImpl child, boolean remove)
      {
         if ( DepartmentToSubRcpntQtrlyAwdCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DepartmentToSubRcpntQtrlyAwdCache.containsKey(child.getRow().getPkeyParams()) )
                  DepartmentToSubRcpntQtrlyAwdCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DepartmentToSubRcpntQtrlyAwdCache.containsKey(child.getRow().getPkeyParams()) )
                  DepartmentToSubRcpntQtrlyAwdCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRdeptToRplbsSetp(R_PLBS_SETPBaseImpl child, boolean remove)
      {
         if ( RdeptToRplbsSetpCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RdeptToRplbsSetpCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToRplbsSetpCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RdeptToRplbsSetpCache.containsKey(child.getRow().getPkeyParams()) )
                  RdeptToRplbsSetpCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_OTPT_PARM_DETs4(R_OTPT_PARM_DETBaseImpl child, boolean remove)
      {
         if ( R_OTPT_PARM_DETs4Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_OTPT_PARM_DETs4Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_OTPT_PARM_DETs4Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_OTPT_PARM_DETs4Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_OTPT_PARM_DETs4Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRIntCstOtMultiToRDept1(R_INT_CST_OT_MULTIBaseImpl child, boolean remove)
      {
         if ( RIntCstOtMultiToRDept1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RIntCstOtMultiToRDept1Cache.containsKey(child.getRow().getPkeyParams()) )
                  RIntCstOtMultiToRDept1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RIntCstOtMultiToRDept1Cache.containsKey(child.getRow().getPkeyParams()) )
                  RIntCstOtMultiToRDept1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_FNCLSs1(R_FNCLSBaseImpl child, boolean remove)
      {
         if ( R_FNCLSs1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_FNCLSs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_FNCLSs1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_FNCLSs1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_FNCLSs1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_DISB_MGMT_RSTR_1(R_DISB_MGMT_RSTRBaseImpl child, boolean remove)
      {
         if ( R_DISB_MGMT_RSTR_1Cache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_DISB_MGMT_RSTR_1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DISB_MGMT_RSTR_1Cache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_DISB_MGMT_RSTR_1Cache.containsKey(child.getRow().getPkeyParams()) )
                  R_DISB_MGMT_RSTR_1Cache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_DISB_MGMT_RSTR(R_DISB_MGMT_RSTRBaseImpl child, boolean remove)
      {
         if ( R_DISB_MGMT_RSTRCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_DISB_MGMT_RSTRCache.containsKey(child.getRow().getPkeyParams()) )
                  R_DISB_MGMT_RSTRCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_DISB_MGMT_RSTRCache.containsKey(child.getRow().getPkeyParams()) )
                  R_DISB_MGMT_RSTRCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForR_CMIA_INTR_PARMs(R_CMIA_INTR_PARMBaseImpl child, boolean remove)
      {
         if ( R_CMIA_INTR_PARMsCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( R_CMIA_INTR_PARMsCache.containsKey(child.getRow().getPkeyParams()) )
                  R_CMIA_INTR_PARMsCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! R_CMIA_INTR_PARMsCache.containsKey(child.getRow().getPkeyParams()) )
                  R_CMIA_INTR_PARMsCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForRDept_RBfyStpfRev(R_BFY_STPF_REVBaseImpl child, boolean remove)
      {
         if ( RDept_RBfyStpfRevCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( RDept_RBfyStpfRevCache.containsKey(child.getRow().getPkeyParams()) )
                  RDept_RBfyStpfRevCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! RDept_RBfyStpfRevCache.containsKey(child.getRow().getPkeyParams()) )
                  RDept_RBfyStpfRevCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }
      public void updateCacheForDeptToIctDocActg(ICT_DOC_HDRBaseImpl child, boolean remove)
      {
         if ( DeptToIctDocActgCache == null ) return;
         if ( child != null ) {
            if ( remove ) {
               if ( DeptToIctDocActgCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToIctDocActgCache.remove(child.getRow().getPkeyParams());
            }
            else {
               // Add only if it is not in the cache.
               if ( ! DeptToIctDocActgCache.containsKey(child.getRow().getPkeyParams()) )
                  DeptToIctDocActgCache.put(child.getRow().getPkeyParams(), child);
            }
         }
      }

/**
* Invalidates the relationship cache. Called by the system on transaction begin.
*/
public void invalidateNonTransactionCaches()
{
  DeptCAToARRADocOngoingCache = null;
  DeptToCAMMjrProgDocCache = null;
  DeptToCASMjrProgDocCache = null;
  CVEX_FUND_DEPTsCache = null;
  CVIN_FUND_DEPTsCache = null;
  RDeptToCvinStru44L3ReqCache = null;
  DeptToCvinStru45L3ReqCache = null;
  DeptToUnitProgCache = null;
  DOC_COAs28Cache = null;
  DeptDocIntCoaCache = null;
  RDeptToGtDocComnCache = null;
  DeptToGtDocNotifUsrCache = null;
  DeptToGtDocOptyCache = null;
  DeptToGtDocRespCache = null;
  DeptToInfApprFuncOtypCache = null;
  RsrcApprInfRecsCache = null;
  INF_BFYs1Cache = null;
  InfDeptUnitToDeptCache = null;
  DeptToInfFpi6Cache = null;
  INF_FPRL_12Cache = null;
  INF_FPRL_21Cache = null;
  INF_FPRL_32Cache = null;
  InfFprfl4RecsCache = null;
  DeptToInfFprl5Cache = null;
  RDeptToInfFprlOCache = null;
  DeptToInfFprlActToLcnCache = null;
  DeptToInfFuncFundProgCache = null;
  INF_FUND_FUNC_ACTVs1Cache = null;
  GFPIToDeptCache = null;
  InfObjOtypToDeptCache = null;
  INF_PHASE_PROGsCache = null;
  PFPIToDeptCache = null;
  RevSrcInfToDeptCache = null;
  DeptToInfUnitCache = null;
  DeptMaAuthDeptCache = null;
  DeptToActgPrflCache = null;
  R_ACTG_TMPLsCache = null;
  DeptToStructDeptCache = null;
  DeptToApCwHdrCache = null;
  R_AP_INCT_RQSTs2Cache = null;
  RDeptToRApdDeptCache = null;
  DeptToCitedAuthCache = null;
  DeptToCntacCache = null;
  R_COMM_FA_THLDs1Cache = null;
  R_COMM_OBJs1Cache = null;
  DeptToDeptFYCache = null;
  RDeptToRDeptObjPymtCtrlCache = null;
  DeptToDISCIVCache = null;
  DeptToDrwdwnGrpCache = null;
  DeptToEscrowDefCache = null;
  RDeptToRFesReqCache = null;
  RDeptToRFndgAllocCache = null;
  RDeptToRFyDeptCache = null;
  RDeptToRGrntApplCache = null;
  RDeptToRGrntDtTmplCache = null;
  DeptToGrntOptyCache = null;
  DeptToGrntRespCache = null;
  DeptToGrntUserCache = null;
  R_INTG_CTRLCache = null;
  R_MJR_PROGs3Cache = null;
  DepartmentToOnGoingAwardInfoCache = null;
  PerfEvalEvaluatorCache = null;
  StateInstancesCache = null;
  RDeptToRPayHldByDeptCache = null;
  R_STPFCache = null;
  UniversalRequestorControlsCache = null;
  UserGrpTmplToDeptCache = null;
  R_VEND_LSTs2Cache = null;
  REQ_ACTV_SACTVsCache = null;
  REQ_DEPT_OBJ_REVsCache = null;
  ReqFundDeptToRDeptCache = null;
  REQ_FUND_UNIT_OBJsCache = null;
  REQ_FUND_UNIT_RSRCsCache = null;
  REQ_UNITsCache = null;
  DeptToReqUnitProgCache = null;
  REQ_UNIT_SUNITsCache = null;
  R_OTPT_PARM_DETs3Cache = null;
  RDeptToRGrntrEvntSched2Cache = null;
  R_FARO_PARMs3Cache = null;
  DeptToClmtrk1Cache = null;
  RDeptToGtDocProgMgmtUsrCache = null;
  ACRL_CLR_EXCLCache = null;
  RQ_DOC_CMPSHTCache = null;
  R_MJR_PGRPs1Cache = null;
  IntrActgToDocDeptCache = null;
  FacpatToDeptCache = null;
  FacpadToDeptCache = null;
  R_DOCATs1Cache = null;
  RDept_RBfyStpfSpndCache = null;
  R_AP_DISB_PARMs3Cache = null;
  MMRDocHdrDeptCache = null;
  DeptToMaSrtyInsCache = null;
  DeptToFndCDocFndCCache = null;
  RqstDeptToCMRDocHdrCache = null;
  R_TASKs1Cache = null;
  RDeptToRPayHldTinCache = null;
  RDeptToRFscCache = null;
  R_FIN_CHRG_SETPCache = null;
  R_FARO_PARMs2Cache = null;
  RDeptToRCntrcGlln1Cache = null;
  RDept_RBfyStpfBsaCache = null;
  RDeptToRAdcParmCache = null;
  RDeptToGtDocPrtnrUsrCache = null;
  RdeptToCsalProcParmCache = null;
  VmPrvntDeptCache = null;
  RDeptToRUtlyActgPrflCache = null;
  R_UNITs2Cache = null;
  R_TASK_ORDs1Cache = null;
  RDeptToRRgnCache = null;
  R_PGRPs1Cache = null;
  DeptToPartUsgCache = null;
  R_MJR_PTYPs1Cache = null;
  R_DSTCs1Cache = null;
  RDeptToRCntrcGllnCache = null;
  RCashSweepToRDeptCache = null;
  R_AP_CLM_ACCTs1Cache = null;
  DeptToAltDeptCache = null;
  ONLN_PRN_BAT_PARM1Cache = null;
  INF_APPRs1Cache = null;
  RDeptToGtDocRptuserCache = null;
  DOC_HDRsCache = null;
  VmAuthDeptDeptCache = null;
  R_PRVNT_SPNDsCache = null;
  DeptToPartRfCache = null;
  RDeptToRGrntrRptCache = null;
  DeptToDebtAuthCache = null;
  RdeptToRcsalSrctrSetpCache = null;
  RDeptToRApUprocPrcuAlCache = null;
  DeptToApCwChkCache = null;
  RDept1ToRAdcParm1Cache = null;
  DeptToMDHdrCache = null;
  DeptToCamProcParmCache = null;
  RdeptToRstatUnitSetpCache = null;
  DeptToProgStaCache = null;
  R_PROGs2Cache = null;
  DeptToOnGoingAwardInfoCache = null;
  NegDrawExcpDtlRecsCache = null;
  R_LCLSs1Cache = null;
  DeptToGrntNotifUsrCache = null;
  RDept2ToRAdcParm2Cache = null;
  R_ACATs1Cache = null;
  LrdsToDept1Cache = null;
  LrdsToDeptCache = null;
  DeptToARRADocSRcpQtrCache = null;
  ACRL_CLR_MGMT_2Cache = null;
  TRVLCoaOVrdToRDeptCache = null;
  DeptToSrcOfFundCache = null;
  R_REIM_GEN_PARAMCache = null;
  DocDeptToReimExpAdjCache = null;
  RFAIntnExcepToRDeptCache = null;
  DeptToDebtHist1Cache = null;
  R_CORSPDs1Cache = null;
  DeptToCWCanParmCache = null;
  DeptToAutoCanoCache = null;
  TRVLCoaOvrdToDeptCache = null;
  Dept1ToTaskOrdBuyrLn1Cache = null;
  DeptToTaskOrdBuyrLnCache = null;
  R_SYS_CROSWALKsCache = null;
  R_PTYPs1Cache = null;
  RdeptToRplbsOfstReqCache = null;
  RdeptToRplbsDistCache = null;
  RDeptToRGrntrRpt1Cache = null;
  R_FNCATs1Cache = null;
  RdeptToRcsalStpctrSetpCache = null;
  R_BURs1Cache = null;
  RDept_RBfyStpfNactgCache = null;
  AUTO_DOC_NOsCache = null;
  RDeptVcVcustCache = null;
  RDeptVcAuthDeptCache = null;
  RQ_DOC_HDRCache = null;
  ReimReqRcycSelToDeptCache = null;
  RDeptToRPrtstCache = null;
  R_LOC_TBLs1Cache = null;
  RDept1ToRIntCstCache = null;
  RDeptToRGrntrEvntSchedCache = null;
  DeptToEscrowHistCache = null;
  R_DISB_MGMT_RSTRs2Cache = null;
  DeptToDebtDocDebtInstCache = null;
  SO_DOC_HDRs2Cache = null;
  RDeptToREquipCache = null;
  R_DRSCLSs1Cache = null;
  R_DIVs1Cache = null;
  RDeptToPHMDocLnCache = null;
  DeptToInfApBY2Cache = null;
  DeptToApEdiHdrCache = null;
  DeptToReimExpAdjCache = null;
  PrgDocCrsRefToDeptCache = null;
  R_PHASEsCache = null;
  R_LOCs2Cache = null;
  RDeptToRGrntDtDetCache = null;
  RDeptToRGrntrEvntSched1Cache = null;
  DeptToFDTOptCache = null;
  R_DRSRCs1Cache = null;
  R_DOCLSs1Cache = null;
  RdeptToRcsalCtrlSetpCache = null;
  R_BUYR_FLINEs2Cache = null;
  DeptToAlwPymntByDebtCache = null;
  GnBudRuleToDeptCache = null;
  R_RSTR_USEsCache = null;
  R_FACCsCache = null;
  ECRTToDeptCache = null;
  R_DOGRPs1Cache = null;
  DeptToClmtrkCache = null;
  DeptToCADocHistCache = null;
  DeptToDisbExcpCache = null;
  R_ACLSs1Cache = null;
  DepartmentToElectronicFederalTaxPaymentSystemCache = null;
  ACRL_CLR_MGMT_1Cache = null;
  R_SECTs1Cache = null;
  PrgDocCrsRef1ToDept_1Cache = null;
  IntrActgToDeptCache = null;
  R_DOTYPs1Cache = null;
  RqstDeptToMaDocHdrCache = null;
  DeptToInfAppr2Cache = null;
  DeptToGRDocHdrCache = null;
  DeptToDebtDocAuthCache = null;
  DeptToAutoPartNoCache = null;
  DeptToADHdrCache = null;
  RCLS_PARM_DTL1Cache = null;
  DeptToVcustCache = null;
  DeptToMsmalsCache = null;
  RDeptToRIntCstCache = null;
  R_FUNCs1Cache = null;
  RDeptToRFacCache = null;
  RDeptToREmpInfoCache = null;
  DeptToDeptTrvlxpPolCache = null;
  DeptToDebtDebtInstCache = null;
  RDeptToRCntrcGlhdCache = null;
  ACRL_CLR_MGMTCache = null;
  DeptToABSHdrCache = null;
  DeptToTrvlDocVendCache = null;
  R_REIM_FREQ_DTs1Cache = null;
  R_OTPT_PARM_DETs5Cache = null;
  R_MGRCache = null;
  R_GPs1Cache = null;
  RDeptToREmplBenMultiCache = null;
  R_DRSGRPs1Cache = null;
  R_DOBJs1Cache = null;
  PO_DOC_HDRCache = null;
  RDeptVcPrvntCache = null;
  R_PROG_GIS_LOCCache = null;
  DeptToPartTypCache = null;
  R_LCATs1Cache = null;
  RDeptToRGrntAlrtUserCache = null;
  RDeptToRFndgGrpCache = null;
  RDeptToRFgcCache = null;
  RDeptToFarHdrCache = null;
  R_DRSTYPs1Cache = null;
  R_DRSCATs1Cache = null;
  R_ACTVs6Cache = null;
  DeptToPoSrtyInsCache = null;
  RDptToROnPrnParmDfltCache = null;
  DeptToInfApBYCache = null;
  RDeptToGtDocAlrtuserCache = null;
  FA_DOC_HDRs1Cache = null;
  DeptToARRADocOngoingCache = null;
  DepartmentToSubRcpntQtrlyAwdCache = null;
  RdeptToRplbsSetpCache = null;
  R_OTPT_PARM_DETs4Cache = null;
  RIntCstOtMultiToRDept1Cache = null;
  R_FNCLSs1Cache = null;
  R_DISB_MGMT_RSTR_1Cache = null;
  R_DISB_MGMT_RSTRCache = null;
  R_CMIA_INTR_PARMsCache = null;
  RDept_RBfyStpfRevCache = null;
  DeptToIctDocActgCache = null;
}

   // Do the parent checks.
      public void removeMeFromDelegatedTeamCache()
      {
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;
            param = new Parameter();
            param.objName = "R_WRKLD_TEAMS";
            param.fieldName = "TEAM_ID";
            param.value = getData("DLGTD_TEAM_ID").getPreviousString();
            searchReq.add(param);
         if (getSession().getTransactionInfo().isInCache(R_WRKLD_TEAMSImpl.getMetaQuery(), searchReq))
         {
            R_WRKLD_TEAMSBaseImpl   parent = this.getOldDelegatedTeam();
            parent.updateCacheForDepartmentsWithDelegatedTeam(this, true);
         }
      }
      public void removeMeFromBuyerTeamCache()
      {
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;
            param = new Parameter();
            param.objName = "R_WRKLD_TEAMS";
            param.fieldName = "TEAM_ID";
            param.value = getData("TEAM_ID").getPreviousString();
            searchReq.add(param);
         if (getSession().getTransactionInfo().isInCache(R_WRKLD_TEAMSImpl.getMetaQuery(), searchReq))
         {
            R_WRKLD_TEAMSBaseImpl   parent = this.getOldBuyerTeam();
            parent.updateCacheForDepartments(this, true);
         }
      }
      public void removeMeFromR_CNTAC28Cache()
      {
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;
            param = new Parameter();
            param.objName = "R_CNTAC";
            param.fieldName = "CNTAC_CD";
            param.value = getData("CNTAC_CD").getPreviousString();
            searchReq.add(param);
         if (getSession().getTransactionInfo().isInCache(R_CNTACImpl.getMetaQuery(), searchReq))
         {
            R_CNTACBaseImpl   parent = this.getOldR_CNTAC28();
            parent.updateCacheForR_DEPTs(this, true);
         }
      }
      public void removeMeFromDelegatedBuyerCache()
      {
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;
            param = new Parameter();
            param.objName = "R_BUYR";
            param.fieldName = "BUYR_ID";
            param.value = getData("DLGTD_BUYR_ID").getPreviousString();
            searchReq.add(param);
         if (getSession().getTransactionInfo().isInCache(R_BUYRImpl.getMetaQuery(), searchReq))
         {
            R_BUYRBaseImpl   parent = this.getOldDelegatedBuyer();
            parent.updateCacheForDepartmentsWithDelegatedBuyer(this, true);
         }
      }
      public void removeMeFromBuyerCache()
      {
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;
            param = new Parameter();
            param.objName = "R_BUYR";
            param.fieldName = "BUYR_ID";
            param.value = getData("BUYR_ID").getPreviousString();
            searchReq.add(param);
         if (getSession().getTransactionInfo().isInCache(R_BUYRImpl.getMetaQuery(), searchReq))
         {
            R_BUYRBaseImpl   parent = this.getOldBuyer();
            parent.updateCacheForDepartments(this, true);
         }
      }
      public void removeMeFromRdeptToRtrvlPolCache()
      {
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;
            param = new Parameter();
            param.objName = "R_TRVL_POL";
            param.fieldName = "TRVL_POL";
            param.value = getData("TRVL_POL").getPreviousString();
            searchReq.add(param);
         if (getSession().getTransactionInfo().isInCache(R_TRVL_POLImpl.getMetaQuery(), searchReq))
         {
            R_TRVL_POLBaseImpl   parent = this.getOldRdeptToRtrvlPol();
            parent.updateCacheForRtrvlPolToRdept(this, true);
         }
      }
      public void removeMeFromContactToDepartmentCache()
      {
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;
            param = new Parameter();
            param.objName = "R_CNTAC";
            param.fieldName = "CNTAC_CD";
            param.value = getData("DISB_CNTAC_CD").getPreviousString();
            searchReq.add(param);
         if (getSession().getTransactionInfo().isInCache(R_CNTACImpl.getMetaQuery(), searchReq))
         {
            R_CNTACBaseImpl   parent = this.getOldContactToDepartment();
            parent.updateCacheForDepartmentToContact(this, true);
         }
      }



      /**     
      * <br>
      * method to get the R_WRKLD_TEAMS object for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Object : the  parent object R_WRKLD_TEAMS for this R_DEPT.
      */
      public   R_WRKLD_TEAMSImpl   getDelegatedTeam()
      {
         R_WRKLD_TEAMSImpl parent = null;
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            if(isNull("DLGTD_TEAM_ID"))
            {
               return null;
            }
            else
            {
               param = new Parameter();
               param.objName = "R_WRKLD_TEAMS";
               param.fieldName = "TEAM_ID";
               param.value   = getData(miDLGTD_TEAM_ID).getString();
               searchReq.add(param);
            }

         parent = (R_WRKLD_TEAMSImpl)(R_WRKLD_TEAMSBaseImpl.getObjectByKey(searchReq ,getSession()));
         return parent;
      }


      /**     
      * <br>
      * method to set the R_WRKLD_TEAMS object for this R_DEPT.
      * @param Object : the  parent object R_WRKLD_TEAMS for this R_DEPT.
      */
      public   void   setDelegatedTeam(R_WRKLD_TEAMSImpl parentObj)
      {
            this.setDLGTD_TEAM_ID(parentObj.getTEAM_ID());
      }

      /**     
      * <br>
      * method to get the R_WRKLD_TEAMS object for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Object : the  parent object R_WRKLD_TEAMS for this R_DEPT.
      */
      public   R_WRKLD_TEAMSImpl   getBuyerTeam()
      {
         R_WRKLD_TEAMSImpl parent = null;
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            if(isNull("TEAM_ID"))
            {
               return null;
            }
            else
            {
               param = new Parameter();
               param.objName = "R_WRKLD_TEAMS";
               param.fieldName = "TEAM_ID";
               param.value   = getData(miTEAM_ID).getString();
               searchReq.add(param);
            }

         parent = (R_WRKLD_TEAMSImpl)(R_WRKLD_TEAMSBaseImpl.getObjectByKey(searchReq ,getSession()));
         return parent;
      }


      /**     
      * <br>
      * method to set the R_WRKLD_TEAMS object for this R_DEPT.
      * @param Object : the  parent object R_WRKLD_TEAMS for this R_DEPT.
      */
      public   void   setBuyerTeam(R_WRKLD_TEAMSImpl parentObj)
      {
            this.setTEAM_ID(parentObj.getTEAM_ID());
      }

      /**     
      * <br>
      * method to get the R_CNTAC object for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Object : the  parent object R_CNTAC for this R_DEPT.
      */
      public   R_CNTACImpl   getR_CNTAC28()
      {
         R_CNTACImpl parent = null;
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            if(isNull("CNTAC_CD"))
            {
               return null;
            }
            else
            {
               param = new Parameter();
               param.objName = "R_CNTAC";
               param.fieldName = "CNTAC_CD";
               param.value   = getData(miCNTAC_CD).getString();
               searchReq.add(param);
            }

         parent = (R_CNTACImpl)(R_CNTACBaseImpl.getObjectByKey(searchReq ,getSession()));
         return parent;
      }


      /**     
      * <br>
      * method to set the R_CNTAC object for this R_DEPT.
      * @param Object : the  parent object R_CNTAC for this R_DEPT.
      */
      public   void   setR_CNTAC28(R_CNTACImpl parentObj)
      {
            this.setCNTAC_CD(parentObj.getCNTAC_CD());
      }

      /**     
      * <br>
      * method to get the R_BUYR object for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Object : the  parent object R_BUYR for this R_DEPT.
      */
      public   R_BUYRImpl   getDelegatedBuyer()
      {
         R_BUYRImpl parent = null;
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            if(isNull("DLGTD_BUYR_ID"))
            {
               return null;
            }
            else
            {
               param = new Parameter();
               param.objName = "R_BUYR";
               param.fieldName = "BUYR_ID";
               param.value   = getData(miDLGTD_BUYR_ID).getString();
               searchReq.add(param);
            }

         parent = (R_BUYRImpl)(R_BUYRBaseImpl.getObjectByKey(searchReq ,getSession()));
         return parent;
      }


      /**     
      * <br>
      * method to set the R_BUYR object for this R_DEPT.
      * @param Object : the  parent object R_BUYR for this R_DEPT.
      */
      public   void   setDelegatedBuyer(R_BUYRImpl parentObj)
      {
            this.setDLGTD_BUYR_ID(parentObj.getBUYR_ID());
      }

      /**     
      * <br>
      * method to get the R_BUYR object for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Object : the  parent object R_BUYR for this R_DEPT.
      */
      public   R_BUYRImpl   getBuyer()
      {
         R_BUYRImpl parent = null;
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            if(isNull("BUYR_ID"))
            {
               return null;
            }
            else
            {
               param = new Parameter();
               param.objName = "R_BUYR";
               param.fieldName = "BUYR_ID";
               param.value   = getData(miBUYR_ID).getString();
               searchReq.add(param);
            }

         parent = (R_BUYRImpl)(R_BUYRBaseImpl.getObjectByKey(searchReq ,getSession()));
         return parent;
      }


      /**     
      * <br>
      * method to set the R_BUYR object for this R_DEPT.
      * @param Object : the  parent object R_BUYR for this R_DEPT.
      */
      public   void   setBuyer(R_BUYRImpl parentObj)
      {
            this.setBUYR_ID(parentObj.getBUYR_ID());
      }

      /**     
      * <br>
      * method to get the R_TRVL_POL object for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Object : the  parent object R_TRVL_POL for this R_DEPT.
      */
      public   R_TRVL_POLImpl   getRdeptToRtrvlPol()
      {
         R_TRVL_POLImpl parent = null;
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            if(isNull("TRVL_POL"))
            {
               return null;
            }
            else
            {
               param = new Parameter();
               param.objName = "R_TRVL_POL";
               param.fieldName = "TRVL_POL";
               param.value   = getData(miTRVL_POL).getString();
               searchReq.add(param);
            }

         parent = (R_TRVL_POLImpl)(R_TRVL_POLBaseImpl.getObjectByKey(searchReq ,getSession()));
         return parent;
      }


      /**     
      * <br>
      * method to set the R_TRVL_POL object for this R_DEPT.
      * @param Object : the  parent object R_TRVL_POL for this R_DEPT.
      */
      public   void   setRdeptToRtrvlPol(R_TRVL_POLImpl parentObj)
      {
            this.setTRVL_POL(parentObj.getTRVL_POL());
      }

      /**     
      * <br>
      * method to get the R_CNTAC object for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Object : the  parent object R_CNTAC for this R_DEPT.
      */
      public   R_CNTACImpl   getContactToDepartment()
      {
         R_CNTACImpl parent = null;
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;

            if(isNull("DISB_CNTAC_CD"))
            {
               return null;
            }
            else
            {
               param = new Parameter();
               param.objName = "R_CNTAC";
               param.fieldName = "CNTAC_CD";
               param.value   = getData(miDISB_CNTAC_CD).getString();
               searchReq.add(param);
            }

         parent = (R_CNTACImpl)(R_CNTACBaseImpl.getObjectByKey(searchReq ,getSession()));
         return parent;
      }


      /**     
      * <br>
      * method to set the R_CNTAC object for this R_DEPT.
      * @param Object : the  parent object R_CNTAC for this R_DEPT.
      */
      public   void   setContactToDepartment(R_CNTACImpl parentObj)
      {
            this.setDISB_CNTAC_CD(parentObj.getCNTAC_CD());
      }


      /**     
      * <br>
      * method to get the old R_WRKLD_TEAMS object for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Object : the  old parent object R_WRKLD_TEAMS for this R_DEPT.
      */
      public   R_WRKLD_TEAMSImpl   getOldDelegatedTeam()
      {
         R_WRKLD_TEAMSImpl parent = null;
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;
            param = new Parameter();
            param.objName = "R_WRKLD_TEAMS";
            param.fieldName = "TEAM_ID";
            param.value = getData(miDLGTD_TEAM_ID).getPreviousString();
            searchReq.add(param);
         this.hideTransactionAsOfDate();
         parent = (R_WRKLD_TEAMSImpl)(R_WRKLD_TEAMSImpl.getObjectByKey(searchReq ,getSession()));
         this.restoreTransactionAsOfDate();         
         return parent;
      }
      /**     
      * <br>
      * method to get the old R_WRKLD_TEAMS object for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Object : the  old parent object R_WRKLD_TEAMS for this R_DEPT.
      */
      public   R_WRKLD_TEAMSImpl   getOldBuyerTeam()
      {
         R_WRKLD_TEAMSImpl parent = null;
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;
            param = new Parameter();
            param.objName = "R_WRKLD_TEAMS";
            param.fieldName = "TEAM_ID";
            param.value = getData(miTEAM_ID).getPreviousString();
            searchReq.add(param);
         this.hideTransactionAsOfDate();
         parent = (R_WRKLD_TEAMSImpl)(R_WRKLD_TEAMSImpl.getObjectByKey(searchReq ,getSession()));
         this.restoreTransactionAsOfDate();         
         return parent;
      }
      /**     
      * <br>
      * method to get the old R_CNTAC object for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Object : the  old parent object R_CNTAC for this R_DEPT.
      */
      public   R_CNTACImpl   getOldR_CNTAC28()
      {
         R_CNTACImpl parent = null;
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;
            param = new Parameter();
            param.objName = "R_CNTAC";
            param.fieldName = "CNTAC_CD";
            param.value = getData(miCNTAC_CD).getPreviousString();
            searchReq.add(param);
         this.hideTransactionAsOfDate();
         parent = (R_CNTACImpl)(R_CNTACImpl.getObjectByKey(searchReq ,getSession()));
         this.restoreTransactionAsOfDate();         
         return parent;
      }
      /**     
      * <br>
      * method to get the old R_BUYR object for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Object : the  old parent object R_BUYR for this R_DEPT.
      */
      public   R_BUYRImpl   getOldDelegatedBuyer()
      {
         R_BUYRImpl parent = null;
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;
            param = new Parameter();
            param.objName = "R_BUYR";
            param.fieldName = "BUYR_ID";
            param.value = getData(miDLGTD_BUYR_ID).getPreviousString();
            searchReq.add(param);
         this.hideTransactionAsOfDate();
         parent = (R_BUYRImpl)(R_BUYRImpl.getObjectByKey(searchReq ,getSession()));
         this.restoreTransactionAsOfDate();         
         return parent;
      }
      /**     
      * <br>
      * method to get the old R_BUYR object for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Object : the  old parent object R_BUYR for this R_DEPT.
      */
      public   R_BUYRImpl   getOldBuyer()
      {
         R_BUYRImpl parent = null;
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;
            param = new Parameter();
            param.objName = "R_BUYR";
            param.fieldName = "BUYR_ID";
            param.value = getData(miBUYR_ID).getPreviousString();
            searchReq.add(param);
         this.hideTransactionAsOfDate();
         parent = (R_BUYRImpl)(R_BUYRImpl.getObjectByKey(searchReq ,getSession()));
         this.restoreTransactionAsOfDate();         
         return parent;
      }
      /**     
      * <br>
      * method to get the old R_TRVL_POL object for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Object : the  old parent object R_TRVL_POL for this R_DEPT.
      */
      public   R_TRVL_POLImpl   getOldRdeptToRtrvlPol()
      {
         R_TRVL_POLImpl parent = null;
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;
            param = new Parameter();
            param.objName = "R_TRVL_POL";
            param.fieldName = "TRVL_POL";
            param.value = getData(miTRVL_POL).getPreviousString();
            searchReq.add(param);
         this.hideTransactionAsOfDate();
         parent = (R_TRVL_POLImpl)(R_TRVL_POLImpl.getObjectByKey(searchReq ,getSession()));
         this.restoreTransactionAsOfDate();         
         return parent;
      }
      /**     
      * <br>
      * method to get the old R_CNTAC object for this R_DEPT
      * this method currently does not support additional conditional params.
      * @return Object : the  old parent object R_CNTAC for this R_DEPT.
      */
      public   R_CNTACImpl   getOldContactToDepartment()
      {
         R_CNTACImpl parent = null;
         SearchRequest searchReq = new SearchRequest();
         Parameter param = null;
            param = new Parameter();
            param.objName = "R_CNTAC";
            param.fieldName = "CNTAC_CD";
            param.value = getData(miDISB_CNTAC_CD).getPreviousString();
            searchReq.add(param);
         this.hideTransactionAsOfDate();
         parent = (R_CNTACImpl)(R_CNTACImpl.getObjectByKey(searchReq ,getSession()));
         this.restoreTransactionAsOfDate();         
         return parent;
      }


   /**     
   * <br>
   * method to get the AMS_ROW_VERS_NO attribute for the R_DEPT
   * @return long : the  value of the attribute AMS_ROW_VERS_NO as long.
   */
   public long   getAMS_ROW_VERS_NO() 
   {
      return getData(miAMS_ROW_VERS_NO).getlong();
   }

   /**     
   * <br>
   * method to set the AMS_ROW_VERS_NO attribute for the R_DEPT
   * @param long : value of the attribute AMS_ROW_VERS_NO as long.
   * @return nothing
   */
   public void   setAMS_ROW_VERS_NO(long value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miAMS_ROW_VERS_NO);
      dataVal.setlong(value);
   }

   /**     
   * <br>
   * method to get the old AMS_ROW_VERS_NO attribute for the R_DEPT
   * @return long : the  value of the old attribute AMS_ROW_VERS_NO as long.
   */
   public long   getOldAMS_ROW_VERS_NO()
   {
      return getData(miAMS_ROW_VERS_NO).getPreviouslong();
   }

   /**     
   * <br>
   * method to get the TEAM_ID attribute for the R_DEPT
   * @return String : the  value of the attribute TEAM_ID as String.
   */
   public String   getTEAM_ID() 
   {
      return getData(miTEAM_ID).getString();
   }

   /**     
   * <br>
   * method to set the TEAM_ID attribute for the R_DEPT
   * @param String : value of the attribute TEAM_ID as String.
   * @return nothing
   */
   public void   setTEAM_ID(String value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miTEAM_ID);
      dataVal.setString(value);
   }

   /**     
   * <br>
   * method to get the old TEAM_ID attribute for the R_DEPT
   * @return String : the  value of the old attribute TEAM_ID as String.
   */
   public String   getOldTEAM_ID()
   {
      return getData(miTEAM_ID).getPreviousString();
   }

   /**     
   * <br>
   * method to get the DEPT_NM attribute for the R_DEPT
   * @return String : the  value of the attribute DEPT_NM as String.
   */
   public String   getDEPT_NM() 
   {
      return getData(miDEPT_NM).getString();
   }

   /**     
   * <br>
   * method to set the DEPT_NM attribute for the R_DEPT
   * @param String : value of the attribute DEPT_NM as String.
   * @return nothing
   */
   public void   setDEPT_NM(String value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miDEPT_NM);
      dataVal.setString(value);
   }

   /**     
   * <br>
   * method to get the old DEPT_NM attribute for the R_DEPT
   * @return String : the  value of the old attribute DEPT_NM as String.
   */
   public String   getOldDEPT_NM()
   {
      return getData(miDEPT_NM).getPreviousString();
   }

   /**     
   * <br>
   * method to get the ACT_FL attribute for the R_DEPT
   * @return boolean : the  value of the attribute ACT_FL as boolean.
   */
   public boolean   getACT_FL() 
   {
      return getData(miACT_FL).getboolean();
   }

   /**     
   * <br>
   * method to set the ACT_FL attribute for the R_DEPT
   * @param boolean : value of the attribute ACT_FL as boolean.
   * @return nothing
   */
   public void   setACT_FL(boolean value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miACT_FL);
      dataVal.setboolean(value);
   }

   /**     
   * <br>
   * method to get the old ACT_FL attribute for the R_DEPT
   * @return boolean : the  value of the old attribute ACT_FL as boolean.
   */
   public boolean   getOldACT_FL()
   {
      return getData(miACT_FL).getPreviousboolean();
   }

   /**     
   * <br>
   * method to get the DEPT_CD attribute for the R_DEPT
   * @return String : the  value of the attribute DEPT_CD as String.
   */
   public String   getDEPT_CD() 
   {
      return getData(miDEPT_CD).getString();
   }

   /**     
   * <br>
   * method to set the DEPT_CD attribute for the R_DEPT
   * @param String : value of the attribute DEPT_CD as String.
   * @return nothing
   */
   public void   setDEPT_CD(String value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miDEPT_CD);
      dataVal.setString(value);
   }

   /**     
   * <br>
   * method to get the old DEPT_CD attribute for the R_DEPT
   * @return String : the  value of the old attribute DEPT_CD as String.
   */
   public String   getOldDEPT_CD()
   {
      return getData(miDEPT_CD).getPreviousString();
   }

   /**     
   * <br>
   * method to get the DISB_CNTAC_CD attribute for the R_DEPT
   * @return long : the  value of the attribute DISB_CNTAC_CD as long.
   */
   public long   getDISB_CNTAC_CD() 
   {
      return getData(miDISB_CNTAC_CD).getlong();
   }

   /**     
   * <br>
   * method to set the DISB_CNTAC_CD attribute for the R_DEPT
   * @param long : value of the attribute DISB_CNTAC_CD as long.
   * @return nothing
   */
   public void   setDISB_CNTAC_CD(long value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miDISB_CNTAC_CD);
      dataVal.setlong(value);
   }

   /**     
   * <br>
   * method to get the old DISB_CNTAC_CD attribute for the R_DEPT
   * @return long : the  value of the old attribute DISB_CNTAC_CD as long.
   */
   public long   getOldDISB_CNTAC_CD()
   {
      return getData(miDISB_CNTAC_CD).getPreviouslong();
   }

   /**     
   * <br>
   * method to get the BASE_DEPT_FL attribute for the R_DEPT
   * @return boolean : the  value of the attribute BASE_DEPT_FL as boolean.
   */
   public boolean   getBASE_DEPT_FL() 
   {
      return getData(miBASE_DEPT_FL).getboolean();
   }

   /**     
   * <br>
   * method to set the BASE_DEPT_FL attribute for the R_DEPT
   * @param boolean : value of the attribute BASE_DEPT_FL as boolean.
   * @return nothing
   */
   public void   setBASE_DEPT_FL(boolean value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miBASE_DEPT_FL);
      dataVal.setboolean(value);
   }

   /**     
   * <br>
   * method to get the old BASE_DEPT_FL attribute for the R_DEPT
   * @return boolean : the  value of the old attribute BASE_DEPT_FL as boolean.
   */
   public boolean   getOldBASE_DEPT_FL()
   {
      return getData(miBASE_DEPT_FL).getPreviousboolean();
   }

   /**     
   * <br>
   * method to get the TBL_LAST_DT attribute for the R_DEPT
   * @return VSDate : the  value of the attribute TBL_LAST_DT as VSDate.
   */
   public VSDate   getTBL_LAST_DT() 
   {
      return getData(miTBL_LAST_DT).getVSDate();
   }

   /**     
   * <br>
   * method to set the TBL_LAST_DT attribute for the R_DEPT
   * @param VSDate : value of the attribute TBL_LAST_DT as VSDate.
   * @return nothing
   */
   public void   setTBL_LAST_DT(VSDate value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miTBL_LAST_DT);
      dataVal.setVSDate(value);
   }

   /**     
   * <br>
   * method to get the old TBL_LAST_DT attribute for the R_DEPT
   * @return VSDate : the  value of the old attribute TBL_LAST_DT as VSDate.
   */
   public VSDate   getOldTBL_LAST_DT()
   {
      return getData(miTBL_LAST_DT).getPreviousVSDate();
   }

   /**     
   * <br>
   * method to get the DLGTD_BUYR_ID attribute for the R_DEPT
   * @return String : the  value of the attribute DLGTD_BUYR_ID as String.
   */
   public String   getDLGTD_BUYR_ID() 
   {
      return getData(miDLGTD_BUYR_ID).getString();
   }

   /**     
   * <br>
   * method to set the DLGTD_BUYR_ID attribute for the R_DEPT
   * @param String : value of the attribute DLGTD_BUYR_ID as String.
   * @return nothing
   */
   public void   setDLGTD_BUYR_ID(String value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miDLGTD_BUYR_ID);
      dataVal.setString(value);
   }

   /**     
   * <br>
   * method to get the old DLGTD_BUYR_ID attribute for the R_DEPT
   * @return String : the  value of the old attribute DLGTD_BUYR_ID as String.
   */
   public String   getOldDLGTD_BUYR_ID()
   {
      return getData(miDLGTD_BUYR_ID).getPreviousString();
   }

   /**     
   * <br>
   * method to get the BUYR_ID attribute for the R_DEPT
   * @return String : the  value of the attribute BUYR_ID as String.
   */
   public String   getBUYR_ID() 
   {
      return getData(miBUYR_ID).getString();
   }

   /**     
   * <br>
   * method to set the BUYR_ID attribute for the R_DEPT
   * @param String : value of the attribute BUYR_ID as String.
   * @return nothing
   */
   public void   setBUYR_ID(String value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miBUYR_ID);
      dataVal.setString(value);
   }

   /**     
   * <br>
   * method to get the old BUYR_ID attribute for the R_DEPT
   * @return String : the  value of the old attribute BUYR_ID as String.
   */
   public String   getOldBUYR_ID()
   {
      return getData(miBUYR_ID).getPreviousString();
   }

   /**     
   * <br>
   * method to get the REST_BUYR_UNIT attribute for the R_DEPT
   * @return int : the  value of the attribute REST_BUYR_UNIT as int.
   */
   public int   getREST_BUYR_UNIT() 
   {
      return getData(miREST_BUYR_UNIT).getint();
   }

   /**     
   * <br>
   * method to set the REST_BUYR_UNIT attribute for the R_DEPT
   * @param int : value of the attribute REST_BUYR_UNIT as int.
   * @return nothing
   */
   public void   setREST_BUYR_UNIT(int value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miREST_BUYR_UNIT);
      dataVal.setint(value);
   }

   /**     
   * <br>
   * method to get the old REST_BUYR_UNIT attribute for the R_DEPT
   * @return int : the  value of the old attribute REST_BUYR_UNIT as int.
   */
   public int   getOldREST_BUYR_UNIT()
   {
      return getData(miREST_BUYR_UNIT).getPreviousint();
   }

   /**     
   * <br>
   * method to get the DEPT_DSCR attribute for the R_DEPT
   * @return String : the  value of the attribute DEPT_DSCR as String.
   */
   public String   getDEPT_DSCR() 
   {
      return getData(miDEPT_DSCR).getString();
   }

   /**     
   * <br>
   * method to set the DEPT_DSCR attribute for the R_DEPT
   * @param String : value of the attribute DEPT_DSCR as String.
   * @return nothing
   */
   public void   setDEPT_DSCR(String value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miDEPT_DSCR);
      dataVal.setString(value);
   }

   /**     
   * <br>
   * method to get the old DEPT_DSCR attribute for the R_DEPT
   * @return String : the  value of the old attribute DEPT_DSCR as String.
   */
   public String   getOldDEPT_DSCR()
   {
      return getData(miDEPT_DSCR).getPreviousString();
   }

   /**     
   * <br>
   * method to get the DEPT_SH_NM attribute for the R_DEPT
   * @return String : the  value of the attribute DEPT_SH_NM as String.
   */
   public String   getDEPT_SH_NM() 
   {
      return getData(miDEPT_SH_NM).getString();
   }

   /**     
   * <br>
   * method to set the DEPT_SH_NM attribute for the R_DEPT
   * @param String : value of the attribute DEPT_SH_NM as String.
   * @return nothing
   */
   public void   setDEPT_SH_NM(String value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miDEPT_SH_NM);
      dataVal.setString(value);
   }

   /**     
   * <br>
   * method to get the old DEPT_SH_NM attribute for the R_DEPT
   * @return String : the  value of the old attribute DEPT_SH_NM as String.
   */
   public String   getOldDEPT_SH_NM()
   {
      return getData(miDEPT_SH_NM).getPreviousString();
   }

   /**     
   * <br>
   * method to get the EFEND_DT attribute for the R_DEPT
   * @return VSDate : the  value of the attribute EFEND_DT as VSDate.
   */
   public VSDate   getEFEND_DT() 
   {
      return getData(miEFEND_DT).getVSDate();
   }

   /**     
   * <br>
   * method to set the EFEND_DT attribute for the R_DEPT
   * @param VSDate : value of the attribute EFEND_DT as VSDate.
   * @return nothing
   */
   public void   setEFEND_DT(VSDate value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miEFEND_DT);
      dataVal.setVSDate(value);
   }

   /**     
   * <br>
   * method to get the old EFEND_DT attribute for the R_DEPT
   * @return VSDate : the  value of the old attribute EFEND_DT as VSDate.
   */
   public VSDate   getOldEFEND_DT()
   {
      return getData(miEFEND_DT).getPreviousVSDate();
   }

   /**     
   * <br>
   * method to get the ALW_BUD_FL attribute for the R_DEPT
   * @return boolean : the  value of the attribute ALW_BUD_FL as boolean.
   */
   public boolean   getALW_BUD_FL() 
   {
      return getData(miALW_BUD_FL).getboolean();
   }

   /**     
   * <br>
   * method to set the ALW_BUD_FL attribute for the R_DEPT
   * @param boolean : value of the attribute ALW_BUD_FL as boolean.
   * @return nothing
   */
   public void   setALW_BUD_FL(boolean value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miALW_BUD_FL);
      dataVal.setboolean(value);
   }

   /**     
   * <br>
   * method to get the old ALW_BUD_FL attribute for the R_DEPT
   * @return boolean : the  value of the old attribute ALW_BUD_FL as boolean.
   */
   public boolean   getOldALW_BUD_FL()
   {
      return getData(miALW_BUD_FL).getPreviousboolean();
   }

   /**     
   * <br>
   * method to get the CNTAC_CD attribute for the R_DEPT
   * @return long : the  value of the attribute CNTAC_CD as long.
   */
   public long   getCNTAC_CD() 
   {
      return getData(miCNTAC_CD).getlong();
   }

   /**     
   * <br>
   * method to set the CNTAC_CD attribute for the R_DEPT
   * @param long : value of the attribute CNTAC_CD as long.
   * @return nothing
   */
   public void   setCNTAC_CD(long value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miCNTAC_CD);
      dataVal.setlong(value);
   }

   /**     
   * <br>
   * method to get the old CNTAC_CD attribute for the R_DEPT
   * @return long : the  value of the old attribute CNTAC_CD as long.
   */
   public long   getOldCNTAC_CD()
   {
      return getData(miCNTAC_CD).getPreviouslong();
   }

   /**     
   * <br>
   * method to get the TRVL_POL attribute for the R_DEPT
   * @return String : the  value of the attribute TRVL_POL as String.
   */
   public String   getTRVL_POL() 
   {
      return getData(miTRVL_POL).getString();
   }

   /**     
   * <br>
   * method to set the TRVL_POL attribute for the R_DEPT
   * @param String : value of the attribute TRVL_POL as String.
   * @return nothing
   */
   public void   setTRVL_POL(String value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miTRVL_POL);
      dataVal.setString(value);
   }

   /**     
   * <br>
   * method to get the old TRVL_POL attribute for the R_DEPT
   * @return String : the  value of the old attribute TRVL_POL as String.
   */
   public String   getOldTRVL_POL()
   {
      return getData(miTRVL_POL).getPreviousString();
   }

   /**     
   * <br>
   * method to get the EFBGN_DT attribute for the R_DEPT
   * @return VSDate : the  value of the attribute EFBGN_DT as VSDate.
   */
   public VSDate   getEFBGN_DT() 
   {
      return getData(miEFBGN_DT).getVSDate();
   }

   /**     
   * <br>
   * method to set the EFBGN_DT attribute for the R_DEPT
   * @param VSDate : value of the attribute EFBGN_DT as VSDate.
   * @return nothing
   */
   public void   setEFBGN_DT(VSDate value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miEFBGN_DT);
      dataVal.setVSDate(value);
   }

   /**     
   * <br>
   * method to get the old EFBGN_DT attribute for the R_DEPT
   * @return VSDate : the  value of the old attribute EFBGN_DT as VSDate.
   */
   public VSDate   getOldEFBGN_DT()
   {
      return getData(miEFBGN_DT).getPreviousVSDate();
   }

   /**     
   * <br>
   * method to get the DSCR_EXT attribute for the R_DEPT
   * @return String : the  value of the attribute DSCR_EXT as String.
   */
   public String   getDSCR_EXT() 
   {
      return getData(miDSCR_EXT).getString();
   }

   /**     
   * <br>
   * method to set the DSCR_EXT attribute for the R_DEPT
   * @param String : value of the attribute DSCR_EXT as String.
   * @return nothing
   */
   public void   setDSCR_EXT(String value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miDSCR_EXT);
      dataVal.setString(value);
   }

   /**     
   * <br>
   * method to get the old DSCR_EXT attribute for the R_DEPT
   * @return String : the  value of the old attribute DSCR_EXT as String.
   */
   public String   getOldDSCR_EXT()
   {
      return getData(miDSCR_EXT).getPreviousString();
   }

   /**     
   * <br>
   * method to get the AR_UNIT_INFR attribute for the R_DEPT
   * @return int : the  value of the attribute AR_UNIT_INFR as int.
   */
   public int   getAR_UNIT_INFR() 
   {
      return getData(miAR_UNIT_INFR).getint();
   }

   /**     
   * <br>
   * method to set the AR_UNIT_INFR attribute for the R_DEPT
   * @param int : value of the attribute AR_UNIT_INFR as int.
   * @return nothing
   */
   public void   setAR_UNIT_INFR(int value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miAR_UNIT_INFR);
      dataVal.setint(value);
   }

   /**     
   * <br>
   * method to get the old AR_UNIT_INFR attribute for the R_DEPT
   * @return int : the  value of the old attribute AR_UNIT_INFR as int.
   */
   public int   getOldAR_UNIT_INFR()
   {
      return getData(miAR_UNIT_INFR).getPreviousint();
   }

   /**     
   * <br>
   * method to get the DLGTD_TEAM_ID attribute for the R_DEPT
   * @return String : the  value of the attribute DLGTD_TEAM_ID as String.
   */
   public String   getDLGTD_TEAM_ID() 
   {
      return getData(miDLGTD_TEAM_ID).getString();
   }

   /**     
   * <br>
   * method to set the DLGTD_TEAM_ID attribute for the R_DEPT
   * @param String : value of the attribute DLGTD_TEAM_ID as String.
   * @return nothing
   */
   public void   setDLGTD_TEAM_ID(String value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miDLGTD_TEAM_ID);
      dataVal.setString(value);
   }

   /**     
   * <br>
   * method to get the old DLGTD_TEAM_ID attribute for the R_DEPT
   * @return String : the  value of the old attribute DLGTD_TEAM_ID as String.
   */
   public String   getOldDLGTD_TEAM_ID()
   {
      return getData(miDLGTD_TEAM_ID).getPreviousString();
   }





   /**     
   * <br>
   * method to get the DEPT_NM_UP attribute for the R_DEPT
   * @return String : the  value of the attribute DEPT_NM_UP as String.
   */
   public String   getDEPT_NM_UP() 
   {
         Data dataVal = null;
         
         
         dataVal = getData(miDEPT_NM_UP);
         
         return dataVal.getString();
   }

      /**     
      * <br>
      * method to get the old DEPT_NM_UP attribute for the R_DEPT
      * @return String : the  value of the old attribute DEPT_NM_UP as String.
      */
      public String   getOldDEPT_NM_UP()
      {
         return getData(miDEPT_NM_UP).getPreviousString();
         
      }

   /**     
   * <br>
   * method to set the DEPT_NM_UP attribute for the R_DEPT
   * @param String : value of the attribute DEPT_NM_UP as String.
   * @return nothing
   */
   public void setDEPT_NM_UP(String value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miDEPT_NM_UP);
      dataVal.setString(value);
   }

   /**     
   * <br>
   * method to get the DEPT_SH_NM_UP attribute for the R_DEPT
   * @return String : the  value of the attribute DEPT_SH_NM_UP as String.
   */
   public String   getDEPT_SH_NM_UP() 
   {
         Data dataVal = null;
         
         
         dataVal = getData(miDEPT_SH_NM_UP);
         
         return dataVal.getString();
   }

      /**     
      * <br>
      * method to get the old DEPT_SH_NM_UP attribute for the R_DEPT
      * @return String : the  value of the old attribute DEPT_SH_NM_UP as String.
      */
      public String   getOldDEPT_SH_NM_UP()
      {
         return getData(miDEPT_SH_NM_UP).getPreviousString();
         
      }

   /**     
   * <br>
   * method to set the DEPT_SH_NM_UP attribute for the R_DEPT
   * @param String : value of the attribute DEPT_SH_NM_UP as String.
   * @return nothing
   */
   public void setDEPT_SH_NM_UP(String value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miDEPT_SH_NM_UP);
      dataVal.setString(value);
   }

   /**     
   * <br>
   * method to get the DEPT_DSCR_UP attribute for the R_DEPT
   * @return String : the  value of the attribute DEPT_DSCR_UP as String.
   */
   public String   getDEPT_DSCR_UP() 
   {
         Data dataVal = null;
         
         
         dataVal = getData(miDEPT_DSCR_UP);
         
         return dataVal.getString();
   }

      /**     
      * <br>
      * method to get the old DEPT_DSCR_UP attribute for the R_DEPT
      * @return String : the  value of the old attribute DEPT_DSCR_UP as String.
      */
      public String   getOldDEPT_DSCR_UP()
      {
         return getData(miDEPT_DSCR_UP).getPreviousString();
         
      }

   /**     
   * <br>
   * method to set the DEPT_DSCR_UP attribute for the R_DEPT
   * @param String : value of the attribute DEPT_DSCR_UP as String.
   * @return nothing
   */
   public void setDEPT_DSCR_UP(String value)
   {
      // The code to do conversion from the primitive data
      // to the one which can be stored goes here.
      Data dataVal = getData(miDEPT_DSCR_UP);
      dataVal.setString(value);
   }


      /**     
      * <br>
      * method to get the replicated attribute DLGTD_TEAM_NM for the R_DEPT
      * @return String : the  value of the replicated attribute DLGTD_TEAM_NM as String.
      */
      public String   getDLGTD_TEAM_NM() 
      {      
            Data dataVal = null;
            boolean security = ((VSORBSessionImpl)session).getSecurityCheck();
            try
            {
               ((VSORBSessionImpl)session).setSecurityCheck(false);
               dataVal = getData(miDLGTD_TEAM_NM);
            
               if (!(dataVal.isInitialized()) )
               {   
                  R_WRKLD_TEAMSImpl parent = this.getDelegatedTeam();
                  if (parent != null)
                  {
     dataVal.initString((parent.getTEAM_NM()));
                  }
                  else
                  {
                        dataVal.setValue(null);
                  }
                  dataVal.setInitialized(true);
                  dataVal.setPushPending(false);
               }
            }
            finally
            {
               ((VSORBSessionImpl)session).setSecurityCheck(security);
            }
            return dataVal.getString();
      }

         

      /**     
      * <br>
      * method to set the value of the replicated attribute DLGTD_TEAM_NM in the data object R_DEPT
      * @param String : value of the attribute DLGTD_TEAM_NM as String.
      * @return nothing
      */
      public void   setDLGTD_TEAM_NM(String value)
      {
         // The code to do conversion from the primitive data
         // to the one which can be stored goes here.
         Data dataVal = getData(miDLGTD_TEAM_NM);
         dataVal.setString(value);
         dataVal.setInitialized(true);
      }

      /**     
      * <br>
      * method to get the replicated attribute TEAM_NM for the R_DEPT
      * @return String : the  value of the replicated attribute TEAM_NM as String.
      */
      public String   getTEAM_NM() 
      {      
            Data dataVal = null;
            boolean security = ((VSORBSessionImpl)session).getSecurityCheck();
            try
            {
               ((VSORBSessionImpl)session).setSecurityCheck(false);
               dataVal = getData(miTEAM_NM);
            
               if (!(dataVal.isInitialized()) )
               {   
                  R_WRKLD_TEAMSImpl parent = this.getBuyerTeam();
                  if (parent != null)
                  {
     dataVal.initString((parent.getTEAM_NM()));
                  }
                  else
                  {
                        dataVal.setValue(null);
                  }
                  dataVal.setInitialized(true);
                  dataVal.setPushPending(false);
               }
            }
            finally
            {
               ((VSORBSessionImpl)session).setSecurityCheck(security);
            }
            return dataVal.getString();
      }

         

      /**     
      * <br>
      * method to set the value of the replicated attribute TEAM_NM in the data object R_DEPT
      * @param String : value of the attribute TEAM_NM as String.
      * @return nothing
      */
      public void   setTEAM_NM(String value)
      {
         // The code to do conversion from the primitive data
         // to the one which can be stored goes here.
         Data dataVal = getData(miTEAM_NM);
         dataVal.setString(value);
         dataVal.setInitialized(true);
      }

      /**     
      * <br>
      * method to get the replicated attribute CNTAC_PH_NO for the R_DEPT
      * @return String : the  value of the replicated attribute CNTAC_PH_NO as String.
      */
      public String   getCNTAC_PH_NO() 
      {      
            Data dataVal = null;
            boolean security = ((VSORBSessionImpl)session).getSecurityCheck();
            try
            {
               ((VSORBSessionImpl)session).setSecurityCheck(false);
               dataVal = getData(miCNTAC_PH_NO);
            
               if (!(dataVal.isInitialized()) )
               {   
                  R_CNTACImpl parent = this.getR_CNTAC28();
                  if (parent != null)
                  {
     dataVal.initString((parent.getPH_NO()));
                  }
                  else
                  {
                        dataVal.setValue(null);
                  }
                  dataVal.setInitialized(true);
                  dataVal.setPushPending(false);
               }
            }
            finally
            {
               ((VSORBSessionImpl)session).setSecurityCheck(security);
            }
            return dataVal.getString();
      }

         

      /**     
      * <br>
      * method to set the value of the replicated attribute CNTAC_PH_NO in the data object R_DEPT
      * @param String : value of the attribute CNTAC_PH_NO as String.
      * @return nothing
      */
      public void   setCNTAC_PH_NO(String value)
      {
         // The code to do conversion from the primitive data
         // to the one which can be stored goes here.
         Data dataVal = getData(miCNTAC_PH_NO);
         dataVal.setString(value);
         dataVal.setInitialized(true);
      }

      /**     
      * <br>
      * method to get the replicated attribute CNTAC_PERSN for the R_DEPT
      * @return String : the  value of the replicated attribute CNTAC_PERSN as String.
      */
      public String   getCNTAC_PERSN() 
      {      
            Data dataVal = null;
            boolean security = ((VSORBSessionImpl)session).getSecurityCheck();
            try
            {
               ((VSORBSessionImpl)session).setSecurityCheck(false);
               dataVal = getData(miCNTAC_PERSN);
            
               if (!(dataVal.isInitialized()) )
               {   
                  R_CNTACImpl parent = this.getR_CNTAC28();
                  if (parent != null)
                  {
     dataVal.initString((parent.getCNTAC_PERSN()));
                  }
                  else
                  {
                        dataVal.setValue(null);
                  }
                  dataVal.setInitialized(true);
                  dataVal.setPushPending(false);
               }
            }
            finally
            {
               ((VSORBSessionImpl)session).setSecurityCheck(security);
            }
            return dataVal.getString();
      }

         

      /**     
      * <br>
      * method to set the value of the replicated attribute CNTAC_PERSN in the data object R_DEPT
      * @param String : value of the attribute CNTAC_PERSN as String.
      * @return nothing
      */
      public void   setCNTAC_PERSN(String value)
      {
         // The code to do conversion from the primitive data
         // to the one which can be stored goes here.
         Data dataVal = getData(miCNTAC_PERSN);
         dataVal.setString(value);
         dataVal.setInitialized(true);
      }

      /**     
      * <br>
      * method to get the replicated attribute CNTAC_PH_EXT for the R_DEPT
      * @return String : the  value of the replicated attribute CNTAC_PH_EXT as String.
      */
      public String   getCNTAC_PH_EXT() 
      {      
            Data dataVal = null;
            boolean security = ((VSORBSessionImpl)session).getSecurityCheck();
            try
            {
               ((VSORBSessionImpl)session).setSecurityCheck(false);
               dataVal = getData(miCNTAC_PH_EXT);
            
               if (!(dataVal.isInitialized()) )
               {   
                  R_CNTACImpl parent = this.getR_CNTAC28();
                  if (parent != null)
                  {
     dataVal.initString((parent.getPH_EXT()));
                  }
                  else
                  {
                        dataVal.setValue(null);
                  }
                  dataVal.setInitialized(true);
                  dataVal.setPushPending(false);
               }
            }
            finally
            {
               ((VSORBSessionImpl)session).setSecurityCheck(security);
            }
            return dataVal.getString();
      }

         

      /**     
      * <br>
      * method to set the value of the replicated attribute CNTAC_PH_EXT in the data object R_DEPT
      * @param String : value of the attribute CNTAC_PH_EXT as String.
      * @return nothing
      */
      public void   setCNTAC_PH_EXT(String value)
      {
         // The code to do conversion from the primitive data
         // to the one which can be stored goes here.
         Data dataVal = getData(miCNTAC_PH_EXT);
         dataVal.setString(value);
         dataVal.setInitialized(true);
      }

      /**     
      * <br>
      * method to get the replicated attribute CNTAC_EMAIL for the R_DEPT
      * @return String : the  value of the replicated attribute CNTAC_EMAIL as String.
      */
      public String   getCNTAC_EMAIL() 
      {      
            Data dataVal = null;
            boolean security = ((VSORBSessionImpl)session).getSecurityCheck();
            try
            {
               ((VSORBSessionImpl)session).setSecurityCheck(false);
               dataVal = getData(miCNTAC_EMAIL);
            
               if (!(dataVal.isInitialized()) )
               {   
                  R_CNTACImpl parent = this.getR_CNTAC28();
                  if (parent != null)
                  {
     dataVal.initString((parent.getEMAIL_AD()));
                  }
                  else
                  {
                        dataVal.setValue(null);
                  }
                  dataVal.setInitialized(true);
                  dataVal.setPushPending(false);
               }
            }
            finally
            {
               ((VSORBSessionImpl)session).setSecurityCheck(security);
            }
            return dataVal.getString();
      }

         

      /**     
      * <br>
      * method to set the value of the replicated attribute CNTAC_EMAIL in the data object R_DEPT
      * @param String : value of the attribute CNTAC_EMAIL as String.
      * @return nothing
      */
      public void   setCNTAC_EMAIL(String value)
      {
         // The code to do conversion from the primitive data
         // to the one which can be stored goes here.
         Data dataVal = getData(miCNTAC_EMAIL);
         dataVal.setString(value);
         dataVal.setInitialized(true);
      }

      /**     
      * <br>
      * method to get the replicated attribute DLGTD_BUYR_NM for the R_DEPT
      * @return String : the  value of the replicated attribute DLGTD_BUYR_NM as String.
      */
      public String   getDLGTD_BUYR_NM() 
      {      
            Data dataVal = null;
            boolean security = ((VSORBSessionImpl)session).getSecurityCheck();
            try
            {
               ((VSORBSessionImpl)session).setSecurityCheck(false);
               dataVal = getData(miDLGTD_BUYR_NM);
            
               if (!(dataVal.isInitialized()) )
               {   
                  R_BUYRImpl parent = this.getDelegatedBuyer();
                  if (parent != null)
                  {
     dataVal.initString((parent.getBUYR_NM()));
                  }
                  else
                  {
                        dataVal.setValue(null);
                  }
                  dataVal.setInitialized(true);
                  dataVal.setPushPending(false);
               }
            }
            finally
            {
               ((VSORBSessionImpl)session).setSecurityCheck(security);
            }
            return dataVal.getString();
      }

         

      /**     
      * <br>
      * method to set the value of the replicated attribute DLGTD_BUYR_NM in the data object R_DEPT
      * @param String : value of the attribute DLGTD_BUYR_NM as String.
      * @return nothing
      */
      public void   setDLGTD_BUYR_NM(String value)
      {
         // The code to do conversion from the primitive data
         // to the one which can be stored goes here.
         Data dataVal = getData(miDLGTD_BUYR_NM);
         dataVal.setString(value);
         dataVal.setInitialized(true);
      }

      /**     
      * <br>
      * method to get the replicated attribute BUYR_NM for the R_DEPT
      * @return String : the  value of the replicated attribute BUYR_NM as String.
      */
      public String   getBUYR_NM() 
      {      
            Data dataVal = null;
            boolean security = ((VSORBSessionImpl)session).getSecurityCheck();
            try
            {
               ((VSORBSessionImpl)session).setSecurityCheck(false);
               dataVal = getData(miBUYR_NM);
            
               if (!(dataVal.isInitialized()) )
               {   
                  R_BUYRImpl parent = this.getBuyer();
                  if (parent != null)
                  {
     dataVal.initString((parent.getBUYR_NM()));
                  }
                  else
                  {
                        dataVal.setValue(null);
                  }
                  dataVal.setInitialized(true);
                  dataVal.setPushPending(false);
               }
            }
            finally
            {
               ((VSORBSessionImpl)session).setSecurityCheck(security);
            }
            return dataVal.getString();
      }

         

      /**     
      * <br>
      * method to set the value of the replicated attribute BUYR_NM in the data object R_DEPT
      * @param String : value of the attribute BUYR_NM as String.
      * @return nothing
      */
      public void   setBUYR_NM(String value)
      {
         // The code to do conversion from the primitive data
         // to the one which can be stored goes here.
         Data dataVal = getData(miBUYR_NM);
         dataVal.setString(value);
         dataVal.setInitialized(true);
      }

      /**     
      * <br>
      * method to get the replicated attribute DISB_CNTAC_NM for the R_DEPT
      * @return String : the  value of the replicated attribute DISB_CNTAC_NM as String.
      */
      public String   getDISB_CNTAC_NM() 
      {      
            Data dataVal = null;
            boolean security = ((VSORBSessionImpl)session).getSecurityCheck();
            try
            {
               ((VSORBSessionImpl)session).setSecurityCheck(false);
               dataVal = getData(miDISB_CNTAC_NM);
            
               if (!(dataVal.isInitialized()) )
               {   
                  R_CNTACImpl parent = this.getContactToDepartment();
                  if (parent != null)
                  {
     dataVal.initString((parent.getCNTAC_PERSN()));
                  }
                  else
                  {
                        dataVal.setValue(null);
                  }
                  dataVal.setInitialized(true);
                  dataVal.setPushPending(false);
               }
            }
            finally
            {
               ((VSORBSessionImpl)session).setSecurityCheck(security);
            }
            return dataVal.getString();
      }

         

      /**     
      * <br>
      * method to set the value of the replicated attribute DISB_CNTAC_NM in the data object R_DEPT
      * @param String : value of the attribute DISB_CNTAC_NM as String.
      * @return nothing
      */
      public void   setDISB_CNTAC_NM(String value)
      {
         // The code to do conversion from the primitive data
         // to the one which can be stored goes here.
         Data dataVal = getData(miDISB_CNTAC_NM);
         dataVal.setString(value);
         dataVal.setInitialized(true);
      }


   




/**     
* <br>
* a factory method to get the rowcount on the objects satisfying the criterion.
* @param SearchRequest : the criterion for the selection
* @param Session : Session object on which the operation is performed.
* @return int : the count of objects satistying the condition.
*/
public static int getObjectCount( SearchRequest searchReq , Session aSession )
throws ServerException
    {
   XDAConnector xdac = createXDAConnector(aSession);
   Connection con = null;
   int count = 0;

   if ( aSession.isTransactionInProgress())
      count = aSession.getTransactionInfo().getObjectsCount(R_DEPTBaseImpl.getMetaQuery(), xdac, searchReq);
   else
   {
      con = aSession.getConnection( xdac, true );
          count = xdac.getRowCount( R_DEPTBaseImpl.getMetaQuery(), searchReq, con );
   }

     return count;
  
}


public void debugMe( String debugID)
{
   addTrace( "debugMe (1 of 2) at " + debugID );
   addTrace( "debugMe (2 of 2) at " + debugID,
     "defaultBehavior="         + this.defaultBehavior.toString() + ", " 
   + "myBehavior="              + this.myBehavior.toString()      + ", " 
        + "current globalNestLevel=" + this.getGlobalNestLevel() + ","
   + "<END DEBUGME>",
      Session.INFO_EVENT);
}

//
// Public getters/setters for behaviors
//
public static boolean isBehaviorEnabled( int fiBehavior )
{
   boolean lboolBitsetVal = myBehavior.get(fiBehavior);
   
   if (fiBehavior==AMSDataObject.AMSBEHAVIOR_EFFECTIVE_DATED)
   {
      String lsEffDt = q.getProperty(AMSDataObject.EFFECTIVE_DATING_ENABLED);  
      
      /*
       * effective dating enabled iff both query property and bitset value
       * indicate that
       */       
      if (lsEffDt !=null && lsEffDt.equals(AMSCommonConstants.SESSION_DOC_YES) &&
          lboolBitsetVal)
      {
         return true;      
      }
      else
      {
         return false;      
      }
   }
   // AMS BEGIN : TIMELINE
   else if (fiBehavior==AMSDataObject.AMSBEHAVIOR_TIMELINE)
   {
      String lsTimeline = q.getProperty(AMSTimelineMaintenance.TIMELINE_DATA);  
      
      /*
       * Timeline is enabled iff both query property and bitset value
       * indicate that
       */       
      if (lsTimeline !=null && lsTimeline.equals(AMSCommonConstants.SESSION_DOC_YES) &&
          lboolBitsetVal)
      {
         return true;      
      }
      else
      {
         return false;      
      }
   }
   // AMS END : TIMELINE
   else
   { 
      return  lboolBitsetVal;   
   }
   
}// of isBehaviorEnabled


public static void enableBehavior( int fiBehavior )
{
   myBehavior.set(fiBehavior);
   
   if (fiBehavior==AMSDataObject.AMSBEHAVIOR_EFFECTIVE_DATED)
   {
      q.addProperty(AMSDataObject.EFFECTIVE_DATING_ENABLED,
                   AMSCommonConstants.SESSION_DOC_YES );    
   }
   // AMS BEGIN : TIMELINE
   else if (fiBehavior==AMSDataObject.AMSBEHAVIOR_TIMELINE)
   {
      q.addProperty(AMSTimelineMaintenance.TIMELINE_DATA,
                   AMSCommonConstants.SESSION_DOC_YES );
   }
   // AMS END : TIMELINE
} // of enableBehavior

public static void disableBehavior( int fiBehavior )
{
   myBehavior.clear(fiBehavior);
   
   if (fiBehavior==AMSDataObject.AMSBEHAVIOR_EFFECTIVE_DATED)
   {
      q.addProperty(AMSDataObject.EFFECTIVE_DATING_ENABLED,
                   AMSCommonConstants.SESSION_DOC_NO );    
   }  
   // AMS BEGIN : TIMELINE
   else if (fiBehavior==AMSDataObject.AMSBEHAVIOR_TIMELINE)
   {
      q.addProperty(AMSTimelineMaintenance.TIMELINE_DATA,
         AMSCommonConstants.SESSION_DOC_NO );
   }
   // AMS END : TIMELINE
} // of disableBehavior


public static BitSet getBehaviors()
{
   return(myBehavior);
}

public BitSet getBehaviorsNotStatic()
{
   return(myBehavior);
}

public static int getType()
{
    if(myBehavior.get(AMSBEHAVIOR_INFERENCE))
    {
        return AMSPARENTTYPE_INFERENCE;
    }
    if(myBehavior.get(AMSBEHAVIOR_COMBO))
    {
        if(myBehavior.get(AMSBEHAVIOR_REVERSE_CHILD_PREVENT))
        {
            return AMSPARENTTYPE_COMBO_EX;
        }
        else
        {
            return AMSPARENTTYPE_COMBO_IN;
        }
    }
    if(myBehavior.get(AMSBEHAVIOR_REQUIRED_ELEMENTS))
    {
        return AMSPARENTTYPE_REQUIRED_ELEMENTS;
    }
    return(AMSPARENTTYPE_OTHER);
}

public DataObject getObjectByKeyNotStatic( SearchRequest key, Session aSession )
   throws ServerException
{
   return getObjectByKey(key,aSession);
}

public Enumeration getObjectsNotStatic( SearchRequest searchReq, Session aSession )
   throws ServerException
{
   return getObjects(searchReq,aSession);
}

public Enumeration getObjectsSortedNotStatic( SearchRequest searchReq, Session aSession,
                                              Vector fvAttributes, int fiAscDscMode )
   throws ServerException
{
   return getObjectsSorted(searchReq,aSession,fvAttributes,fiAscDscMode);
}

public int getObjectCountNotStatic( SearchRequest searchReq , Session aSession )
   throws ServerException
{
   return getObjectCount( searchReq, aSession ) ;
}

public VSMetaQuery getMetaQueryNotStatic()
{
   return getMetaQuery();
}



public char getOrgLevelSecurityTypeNotStatic()
{
   return mcOrgLvlSecType ;
}

public static char getOrgLevelSecurityType()
{
   return mcOrgLvlSecType ;
}

/**     
* This method returns the value extended property 'ObjAttType'. 
*
* @return Object Attachment type 'R' for reference table and 'A' for
* alternate view, otherwise returns null.
*/
public String getObjectAttType()
{
   return msObjAttType ;
}

/**     
 * <br>
 * Method to return the logger object for use with this
 * class/object
 * @return Log the logger object for this class/object
 */
protected static Log getAMSLog()
{
   return moAMSLog ;
}

/**
 * A factory method to connect to the database using the XDAConnector object for this class.
 *
 * @return XDAConnector If succcessful returns an instance of the XDA Connector.
 */
public static XDAConnector createXDAConnector()
{ 
   XDAConnector loXDA = null ;
   
   try
   {
      VSMetaTable loMetaTable = R_DEPTBaseImpl.getMetaQuery().getChildMostTable() ;

      if ( useCustom == ' ' )
      {
         if ( loMetaTable != null )
         {
            if ( loMetaTable.getXDAConnectorClassName().equalsIgnoreCase( defaultSQLXDA ) ) 
            {
               useCustom = 'Y' ;
            }
            else
            {
               useCustom = 'N' ;  
            }  
         } 
         else
         {
            useCustom = 'Y' ;
         }
      }
      if ( useCustom == 'Y' )
      {
         loXDA = (XDAConnector)GenericComponentFactory.getClassObject(
                       R_DEPTBaseImpl.getMetaQuery().getPackageName(), "XDASQLCustom" ) ;
      }
      else
      {
         if ( loMetaTable != null )
         {
            loXDA = (XDAConnector)Class.forName( loMetaTable.getXDAConnectorClassName() ).newInstance() ;
         }
         else
         {
            loXDA = (XDAConnector)Class.forName( defaultSQLXDA ).newInstance() ;
         }
      }
   }
   catch( ServerException foExp )
   {
      Util.logWarning(logger, foExp);   
      throw foExp ;
   }
   catch ( Exception foExp )
   {
      Util.logWarning(logger, foExp);

      throw new ServerException( "Unable to create XDA connector. " + foExp.getMessage() ) ;
   }

   return loXDA;
}

/**
 * A factory method to connect to the database using the XDAConnector object for this class for a
 * particular session.
 *
 * @param foSession Session object with which to associate the XDA Connector.
 * @return XDAConnector If succcessful returns an instance of the XDA Connector.
 */
public  static XDAConnector createXDAConnector( Session foSession )
      throws ServerException
{ 
   XDAConnector loXDA = null ;
   
   try
   {
      VSMetaTable loMetaTable = R_DEPTBaseImpl.getMetaQuery().getChildMostTable() ;

      if ( moMRTObject == null )
      {
         /*
          * Save off a local copy of the MRT object to
          * avoid calling getMrtObject() unecessarily
          * because that method is synchronized
          */
         moMRTObject = MrtSingleton.getMrtObject() ;
      }

      if ( inMrt == ' ' )
      {
         inMrt = moMRTObject.isInMRT( loMetaTable.getName() ) ? 'Y' : 'N' ;
      }
      if ( inMrt == 'Y' )
      {
         String lsMaint = foSession.getProperty(AMSCommonConstants.MAINTENANCE_STR) ;

         if ( ( lsMaint != null ) &&
              ( ( lsMaint.equals( "G" ) ) ||
                ( ( lsMaint.equals( "Y" ) ) && ( mboolAllowMRTUpdate ) ) ) )
         {
            loXDA = getDBConnector( foSession ) ;
         }
         else
         {
            Properties loProps ;
            
            loXDA = (XDAConnector)Class.forName(
                  getMetaQuery().getPackageName() + ".XDAMRTCustom" ).newInstance() ;
            loProps = ((VSORBSessionImpl)foSession).getMyDataServiceLoginForObject("R_DEPT") ;
            loXDA.setProperties( loProps ) ;
         }
      }
      else
      {
         loXDA = getDBConnector( foSession ) ;
      }
   }
   catch( ServerException foExp )
   {
      Util.logWarning(logger, foExp);
   
      throw foExp ;
   }
   catch ( Exception foExp )
   {   
      Util.logWarning(logger, foExp);

      throw new ServerException( "Unable to create XDA connector. " + foExp.getMessage() ) ;
   }
   return loXDA ;
}  


/**
 * A factory method to connect to the database using the XDAConnector object for this class for a
 * particular session.
 *
 * @param foSession Session object with which to associate the XDA Connector.
 * @return XDAConnector If succcessful returns an instance of the XDA Connector.
 */
public static XDAConnector getDBConnector( Session foSession )
      throws ServerException
{
   XDAConnector loXDA   = null ;
   Properties   loProps ;

   try
   {
      VSMetaTable loMetaTable = getMetaQuery().getChildMostTable() ;

      if ( useCustom == ' ' )
      {
         if ( loMetaTable != null )
         {
            if ( loMetaTable.getXDAConnectorClassName().equalsIgnoreCase( defaultSQLXDA ) )
            {
               useCustom = 'Y' ;
            }
            else
            {
               useCustom = 'N' ;
            }
         }
         else
         {
            useCustom = 'Y' ;
         }
      }
      if ( useCustom == 'Y' )
      {
         loXDA = (XDAConnector)GenericComponentFactory.getClassObject(
                       getMetaQuery().getPackageName(), "XDASQLCustom" ) ;
      }
      else
      {
         if ( loMetaTable != null )
         {
            loXDA = (XDAConnector)Class.forName( loMetaTable.getXDAConnectorClassName() ).newInstance() ;
         }
         else
         {
            loXDA = ( XDAConnector)Class.forName( defaultSQLXDA ).newInstance() ;
         }
      }
   }
   catch( ServerException foExp )
   {
      throw foExp ;
   }
   catch ( Exception foExp )
   {
      foExp.printStackTrace() ;
      throw new ServerException( "Unable to create XDA connector. " + foExp.getMessage() ) ;
   }
   loProps = ((VSORBSessionImpl)foSession).getMyDataServiceLoginForObject("R_DEPT") ;
   loXDA.setProperties( loProps ) ;
   return loXDA ;
}

/**     
 * Returns the current XDA Connector for this object if one
 * is already created. Otherwise a new instance of the XDA
 * Connector is created and returned.
 *
 * @return XDAConnector If succcessful returns an instance of the XDA Connector
 */
public XDAConnector getXDAConnector()
{
   if ( xdac == null )
   {
      xdac = createXDAConnector( session ) ;
   }
   return xdac ;
}

/**     
 * Performs row level security for the given ResultSet.  This method
 * should not be defined in the R_DEPTImpl class.  Instead,
 * use the beforeResultSetFillBeforeSecurityCheck and
 * beforeResultSetFillAfterSecurityCheck methods.  To reject a row
 * from the result set, the rejection must be done in the
 * beforeResultSetFillBeforeSecurityCheck method.  Doing so in the
 * beforeResultSetFillAfterSecurityCheck method will have no effect.
 *
 * @param foRowToBeAdded The data row to be added to the result set
 * @param foResponse The response object using which the fill can be rejected
 */
public static void beforeResultsetFill( DataRow foRowToBeAdded, Response foResponse )
{
   //
   // Call application hook that developers can customize, if required
   //
   R_DEPTImpl.beforeResultSetFillBeforeSecurityCheck( foRowToBeAdded, foResponse ) ;

   if ( foResponse.rejected() )
   {
      return ;
   }
   
   /* Limit the number of rows to be searched if set */
   if ( AMSParams.mlMaxRowsRetrieved != -1 )
   { 
      if ( AMSDataObject.hasRowCountExceeded( foRowToBeAdded ) )
      {
        foResponse.reject() ;
        return ;
      }  
   } /* end if ( AMSParams.mlMaxRowsRetrieved != -1 ) */
   
   //
   // First, check if we need to lookup the value of the row security flag
   // for this data object resource to see if we even need to check row security
   //
   if ( !mboolMrtLkupForRowSecurityFlag )
   {      
      if ( moMRTObject == null )
      {
         // Save off a local copy of the MRT object to
         // avoid calling getMrtObject() unecessarily
         // because that method is synchronized
         moMRTObject = MrtSingleton.getMrtObject();
      }

      if ( AMSDataObject.isRowSecurityEnabled( "R_DEPT", foRowToBeAdded, moMRTObject ) )
      {
         mboolMrtLkupForRowSecurityFlag = true ;
         mboolRowSecFlgValue            = true ;
      }
      else
      {
         mboolMrtLkupForRowSecurityFlag = true ;
         mboolRowSecFlgValue            = false ;
      }
   }/* end if ( !mboolMrtLkupForRowSecurityFlag ) */

   if ( ( mboolMrtLkupForRowSecurityFlag ) && ( mboolRowSecFlgValue ) )
   {
      //
      // Call security to authorize this row's data for viewing
      //
      if ( AMSDataObject.isDataRowAuthorized( foRowToBeAdded ) )
      {
         // Success
         foResponse.accept() ;
      }
      else
      {
         // Failed
         foResponse.reject() ;
         return ;
      }
   }
   else
   {
      // Success
      foResponse.accept() ;
   }

   //
   // Call application hook that developers can customize, if required
   //
   R_DEPTImpl.beforeResultSetFillAfterSecurityCheck( foRowToBeAdded, foResponse ) ;
} /* end beforeResultsetFill */

/**     
* <br>
* @RECOMPUTE: This routine forces recalculation of formulaes.
*/
public void RecomputeDerivations()
{
         R_WRKLD_TEAMSBaseImpl DelegatedTeam = (R_WRKLD_TEAMSBaseImpl) this.getDelegatedTeam();

         R_WRKLD_TEAMSBaseImpl BuyerTeam = (R_WRKLD_TEAMSBaseImpl) this.getBuyerTeam();

         R_CNTACBaseImpl R_CNTAC28 = (R_CNTACBaseImpl) this.getR_CNTAC28();




         R_BUYRBaseImpl DelegatedBuyer = (R_BUYRBaseImpl) this.getDelegatedBuyer();

         R_BUYRBaseImpl Buyer = (R_BUYRBaseImpl) this.getBuyer();

         R_CNTACBaseImpl ContactToDepartment = (R_CNTACBaseImpl) this.getContactToDepartment();


   if (isFormulaRequired())
   {
      this.setFormulaValues();
   }
}

/**
 * This method allows the data object to be removed from the cache and 
 * the associate CacheManager. A call to getObjects or getObjectbyKey 
 * would mean the data object will be reloaded into the cache, which 
 * could negatively impact performance. An example of when it would be
 * beneficial to call this method may be when the tables being loaded 
 * into the cache are only required for job processing - so that once
 * the jobs have been run, the tables can be safely removed from the 
 * cache. 
 */
public static void clearGlobalCache()
{   
   if ( cacheSize!=0 ) 
   {
      CacheAgent.getCacheAgent().removeCache( R_DEPTBaseImpl.getMetaQuery() );      
   } /* end if ( cacheSize!=0 ) */  
}  /* end clearGlobalCache() */

/**
 * This method returns an array of the names of all related 
 * parent data objects
 */
public static String[] getParentDataObjectNames()
{   
      String lsParentArr[] = {                   "R_WRKLD_TEAMS"
                  ,  "R_WRKLD_TEAMS"
                  ,  "R_CNTAC"
                  ,  "R_BUYR"
                  ,  "R_BUYR"
                  ,  "R_TRVL_POL"
                  ,  "R_CNTAC"
 };
      return lsParentArr ;
}

/**
 * This method returns an array of the names of all related 
 * child data objects
 */
public static String[] getChildDataObjectNames()
{  
      String lsParentArr[] = {                   "ARRA_DOC_ONGOING"
                  ,  "CAM_DOC_MJRPROG"
                  ,  "CAS_DOC_MJRPROG"
                  ,  "CVEX_FUND_DEPT"
                  ,  "CVIN_FUND_DEPT"
                  ,  "CVIN_STRU44L3_REQ"
                  ,  "CVIN_STRU45L3_REQ"
                  ,  "CVIN_UNIT_PROG"
                  ,  "DOC_COA"
                  ,  "DOC_INT_COA"
                  ,  "GT_DOC_COMN"
                  ,  "GT_DOC_NOTIFUSR"
                  ,  "GT_DOC_OPTY"
                  ,  "GT_DOC_RESP"
                  ,  "INF_APPR_FUNC_OTYP"
                  ,  "INF_APPR_RSRC"
                  ,  "INF_BFY"
                  ,  "INF_DEPT_UNIT"
                  ,  "INF_FPI_6"
                  ,  "INF_FPRL_1"
                  ,  "INF_FPRL_2"
                  ,  "INF_FPRL_3"
                  ,  "INF_FPRL_4"
                  ,  "INF_FPRL_5"
                  ,  "INF_FPRL_O"
                  ,  "INF_FPRL_ACTV_LOC"
                  ,  "INF_FUNC_FUND_PROG"
                  ,  "INF_FUND_FUNC_ACTV"
                  ,  "INF_GRNT_FP"
                  ,  "INF_OBJ_OTYP"
                  ,  "INF_PHASE_PROG"
                  ,  "INF_PROJ_FP"
                  ,  "INF_REV_SRC"
                  ,  "INF_UNIT"
                  ,  "MA_DOC_AUTHDEPT"
                  ,  "R_ACTG_PRFL"
                  ,  "R_ACTG_TMPL"
                  ,  "R_ALT_ORG_STRUCT"
                  ,  "R_AP_CW_HDR"
                  ,  "R_AP_INCT_RQST"
                  ,  "R_APD_DEPT"
                  ,  "R_CITED_AUTH"
                  ,  "R_CNTAC"
                  ,  "R_COMM_FA_THLD"
                  ,  "R_COMM_OBJ"
                  ,  "R_DEPT_FY"
                  ,  "R_DEPT_OBJ_PYCTRL"
                  ,  "R_DISCIV"
                  ,  "R_DRWDWN_GRP"
                  ,  "R_ESCROW_DEF"
                  ,  "R_FESREQ"
                  ,  "R_FNDG_ALLOC"
                  ,  "R_FY_DEPT"
                  ,  "R_GRNT_APPL"
                  ,  "R_GRNT_DT_TMPL"
                  ,  "R_GRNT_OPTY"
                  ,  "R_GRNT_RESP"
                  ,  "R_GRNT_USER"
                  ,  "R_INTG_CTRL"
                  ,  "R_MJR_PROG"
                  ,  "R_ONGOING_AWD_INFO"
                  ,  "R_PE_EVALR"
                  ,  "R_PRCU_ST"
                  ,  "R_PYMT_HLD_TYP_DPT"
                  ,  "R_STPF"
                  ,  "R_UR_CTRL"
                  ,  "R_USER_GRP_TMPL"
                  ,  "R_VEND_LST"
                  ,  "REQ_ACTV_SACTV"
                  ,  "REQ_DEPT_OBJ_REV"
                  ,  "REQ_FUND_DEPT"
                  ,  "REQ_FUND_UNIT_OBJ"
                  ,  "REQ_FUND_UNIT_RSRC"
                  ,  "REQ_UNIT"
                  ,  "REQ_UNIT_PROG"
                  ,  "REQ_UNIT_SUNIT"
                  ,  "R_OTPT_PARM_DET"
                  ,  "R_GRNTR_EVNT_SCHED"
                  ,  "R_FARO_PARM"
                  ,  "R_CLMTRK"
                  ,  "GT_DOC_PMGMTUSR"
                  ,  "ACRL_CLR_EXCL"
                  ,  "RQ_DOC_CMPSHT"
                  ,  "R_MJR_PGRP"
                  ,  "R_INTR_ACTG_CRSWLK"
                  ,  "R_FACPAT"
                  ,  "R_FACPAD"
                  ,  "R_DOCAT"
                  ,  "R_BFY_STPF_SPND"
                  ,  "R_AP_DISB_PARM"
                  ,  "MMR_DOC_HDR"
                  ,  "MA_DOC_SRTYINS"
                  ,  "FNDC_DOC_FNDC"
                  ,  "CMR_DOC_HDR"
                  ,  "R_TASK"
                  ,  "R_PYMT_HLD_TIN"
                  ,  "R_FSC"
                  ,  "R_FIN_CHRG_SETP"
                  ,  "R_FARO_PARM"
                  ,  "R_CNTRC_GOAL_LN"
                  ,  "R_BFY_STPF_BSA"
                  ,  "R_ADC_PARM"
                  ,  "GT_DOC_PRTNRUSR"
                  ,  "CSAL_PROC_PARM"
                  ,  "VCM_DOC_PRVNT"
                  ,  "R_UTLY_ACTG_PRFL"
                  ,  "R_UNIT"
                  ,  "R_TASK_ORD"
                  ,  "R_RGN"
                  ,  "R_PGRP"
                  ,  "R_PART_USG"
                  ,  "R_MJR_PTYP"
                  ,  "R_DSTC"
                  ,  "R_CNTRC_GOAL_LN"
                  ,  "R_CASH_SW_SETP"
                  ,  "R_AP_CLM_ACCT"
                  ,  "R_ALT_ORG_STRUCT"
                  ,  "ONLN_PRN_BAT_PARM"
                  ,  "INF_APPR"
                  ,  "GT_DOC_RPTUSER"
                  ,  "DOC_HDR"
                  ,  "VCM_DOC_AUTHDEPT"
                  ,  "R_PRVNT_SPND"
                  ,  "R_PART_RF"
                  ,  "R_GRNTR_RPT"
                  ,  "R_DEBT_AUTH"
                  ,  "R_CSAL_SRCTR_SETP"
                  ,  "R_AP_UPROC_PRCU_AL"
                  ,  "R_AP_CW_CHK_NO"
                  ,  "R_ADC_PARM"
                  ,  "MD_DOC_HDR"
                  ,  "CAM_PROC_PARM"
                  ,  "R_STAT_UNIT_SETP"
                  ,  "R_PROG_STA"
                  ,  "R_PROG"
                  ,  "R_ONGOING_AWD_INFO"
                  ,  "R_NEG_DRW_EXCP_DTL"
                  ,  "R_LCLS"
                  ,  "R_GRNT_NOTIFUSR"
                  ,  "R_ADC_PARM"
                  ,  "R_ACAT"
                  ,  "LIC_RNEW_DT_STRG"
                  ,  "LIC_RNEW_DT_STRG"
                  ,  "ARRA_DOC_SRCPQTR"
                  ,  "ACRL_CLR_MGMT"
                  ,  "TRVL_COA_OVRD"
                  ,  "R_SRC_OF_FUND"
                  ,  "R_REIM_GEN_PARAM"
                  ,  "R_REIM_EXP_ADJ"
                  ,  "R_FA_INTN_EXCEPT"
                  ,  "R_DEBT_HIST"
                  ,  "R_CORSPD"
                  ,  "R_AP_CWCAN_PARM"
                  ,  "AUTO_CA_NO"
                  ,  "TRVL_COA_OVRD"
                  ,  "R_TASK_ORD_BUYR_LN"
                  ,  "R_TASK_ORD_BUYR_LN"
                  ,  "R_SYS_CROSWALK"
                  ,  "R_PTYP"
                  ,  "R_PLBS_OFST_REQ"
                  ,  "R_PLBS_DIST"
                  ,  "R_GRNTR_RPT"
                  ,  "R_FNCAT"
                  ,  "R_CSAL_STPCTR_SETP"
                  ,  "R_BUR"
                  ,  "R_BFY_STPF_NACTG"
                  ,  "AUTO_DOC_NO"
                  ,  "VCC_DOC_VCUST"
                  ,  "VCC_DOC_AUTHDEPT"
                  ,  "RQ_DOC_HDR"
                  ,  "R_REIMRQD_RCYCSEL"
                  ,  "R_PRTST"
                  ,  "R_LOC_TBL"
                  ,  "R_INT_CST_PARM"
                  ,  "R_GRNTR_EVNT_SCHED"
                  ,  "R_ESCROW_HIST"
                  ,  "R_DISB_MGMT_RSTR"
                  ,  "DEBT_DOC_DEBTINST"
                  ,  "SO_DOC_HDR"
                  ,  "R_EQUIP"
                  ,  "R_DRSCLS"
                  ,  "R_DIV"
                  ,  "PHM_DOC_LINE"
                  ,  "INF_APBY2"
                  ,  "AP_EDI_HDR"
                  ,  "R_REIM_EXP_ADJ"
                  ,  "R_PROG_DOC_CRSREF"
                  ,  "R_PHASE"
                  ,  "R_LOC"
                  ,  "R_GRNT_DT_DET"
                  ,  "R_GRNTR_EVNT_SCHED"
                  ,  "R_FDT_OPT"
                  ,  "R_DRSRC"
                  ,  "R_DOCLS"
                  ,  "R_CSAL_CTRL_SETP"
                  ,  "R_BUYR_FLINE"
                  ,  "R_ALW_PYMT_DBTYP"
                  ,  "GN_BUD_RULE"
                  ,  "R_RSTR_USE"
                  ,  "R_FACC"
                  ,  "R_EXTR_CASH_RECT"
                  ,  "R_DOGRP"
                  ,  "R_CLMTRK"
                  ,  "R_CA_DOC_HIST"
                  ,  "R_AP_DISB_EXCP"
                  ,  "R_ACLS"
                  ,  "ELEC_FED_TAXP_SYS"
                  ,  "ACRL_CLR_MGMT"
                  ,  "R_SECT"
                  ,  "R_PROG_DOC_CRSREF"
                  ,  "R_INTR_ACTG_CRSWLK"
                  ,  "R_DOTYP"
                  ,  "MA_DOC_HDR"
                  ,  "INF_APPR2"
                  ,  "GR_DOC_HDR"
                  ,  "DEBT_DOC_AUTH"
                  ,  "AUTO_PART_NO"
                  ,  "AD_DOC_HDR"
                  ,  "RCLS_PARM_DTL"
                  ,  "R_VEND_CUST"
                  ,  "R_MSMALS"
                  ,  "R_INT_CST_PARM"
                  ,  "R_FUNC"
                  ,  "R_FAC"
                  ,  "R_EMP_INFO"
                  ,  "R_DEPT_TRVLXP_POL"
                  ,  "R_DEBT_DEBTINST"
                  ,  "R_CNTRC_GOAL_HDR"
                  ,  "ACRL_CLR_MGMT"
                  ,  "ABS_DOC_HDR"
                  ,  "TRVL_DOC_VEND"
                  ,  "R_REIM_FREQ_DT"
                  ,  "R_OTPT_PARM_DET"
                  ,  "R_MGR"
                  ,  "R_GP"
                  ,  "R_EMPL_BEN_MULTI"
                  ,  "R_DRSGRP"
                  ,  "R_DOBJ"
                  ,  "PO_DOC_HDR"
                  ,  "VCC_DOC_PRVNT"
                  ,  "R_PROG_GIS_LOC"
                  ,  "R_PART_TYP"
                  ,  "R_LCAT"
                  ,  "R_GRNT_ALRT_USER"
                  ,  "R_FNDG_GRP"
                  ,  "R_FGC"
                  ,  "R_FAR_HDR"
                  ,  "R_DRSTYP"
                  ,  "R_DRSCAT"
                  ,  "R_ACTV"
                  ,  "PO_DOC_SRTYINS"
                  ,  "ONLN_PRN_PARM_DFLT"
                  ,  "INF_APBY"
                  ,  "GT_DOC_ALRTUSER"
                  ,  "FA_DOC_HDR"
                  ,  "ARRA_DOC_ONGOING"
                  ,  "R_SRCPNT_QTRLY_AWD"
                  ,  "R_PLBS_SETP"
                  ,  "R_OTPT_PARM_DET"
                  ,  "R_INT_CST_OT_MULTI"
                  ,  "R_FNCLS"
                  ,  "R_DISB_MGMT_RSTR"
                  ,  "R_DISB_MGMT_RSTR"
                  ,  "R_CMIA_INTR_PARM"
                  ,  "R_BFY_STPF_REV"
                  ,  "ICT_DOC_HDR"
 };
      return lsParentArr ;
}

/**
 * This method returns an array of the names of all related 
 * parent data objects
 */
public String[] getParentDataObjectNamesNotStatic()
{   
  return getParentDataObjectNames() ;
}

/**
 * This method returns an array of the names of all related 
 * child data objects
 */
public String[] getChildDataObjectNamesNotStatic()
{  
  return getChildDataObjectNames() ;
}


public static boolean isRelationshipEnabledfor_DelegatedTeam(Session foSession)
{
   if (((getBehaviors().get(AMSBEHAVIOR_CHILD_OF_INFERENCE)) &&
        (R_WRKLD_TEAMSImpl.getBehaviors().get(AMSBEHAVIOR_INFERENCE))) ||
       (R_WRKLD_TEAMSImpl.getBehaviors().get(AMSBEHAVIOR_COMBO)))
   {
      return R_WRKLD_TEAMSImpl.isInferenceEnabled(foSession);
   }

   return true;
}
public static boolean isRelationshipEnabledfor_BuyerTeam(Session foSession)
{
   if (((getBehaviors().get(AMSBEHAVIOR_CHILD_OF_INFERENCE)) &&
        (R_WRKLD_TEAMSImpl.getBehaviors().get(AMSBEHAVIOR_INFERENCE))) ||
       (R_WRKLD_TEAMSImpl.getBehaviors().get(AMSBEHAVIOR_COMBO)))
   {
      return R_WRKLD_TEAMSImpl.isInferenceEnabled(foSession);
   }

   return true;
}
public static boolean isRelationshipEnabledfor_R_CNTAC28(Session foSession)
{
   if (((getBehaviors().get(AMSBEHAVIOR_CHILD_OF_INFERENCE)) &&
        (R_CNTACImpl.getBehaviors().get(AMSBEHAVIOR_INFERENCE))) ||
       (R_CNTACImpl.getBehaviors().get(AMSBEHAVIOR_COMBO)))
   {
      return R_CNTACImpl.isInferenceEnabled(foSession);
   }

   return true;
}
public static boolean isRelationshipEnabledfor_DelegatedBuyer(Session foSession)
{
   if (((getBehaviors().get(AMSBEHAVIOR_CHILD_OF_INFERENCE)) &&
        (R_BUYRImpl.getBehaviors().get(AMSBEHAVIOR_INFERENCE))) ||
       (R_BUYRImpl.getBehaviors().get(AMSBEHAVIOR_COMBO)))
   {
      return R_BUYRImpl.isInferenceEnabled(foSession);
   }

   return true;
}
public static boolean isRelationshipEnabledfor_Buyer(Session foSession)
{
   if (((getBehaviors().get(AMSBEHAVIOR_CHILD_OF_INFERENCE)) &&
        (R_BUYRImpl.getBehaviors().get(AMSBEHAVIOR_INFERENCE))) ||
       (R_BUYRImpl.getBehaviors().get(AMSBEHAVIOR_COMBO)))
   {
      return R_BUYRImpl.isInferenceEnabled(foSession);
   }

   return true;
}
public static boolean isRelationshipEnabledfor_RdeptToRtrvlPol(Session foSession)
{
   if (((getBehaviors().get(AMSBEHAVIOR_CHILD_OF_INFERENCE)) &&
        (R_TRVL_POLImpl.getBehaviors().get(AMSBEHAVIOR_INFERENCE))) ||
       (R_TRVL_POLImpl.getBehaviors().get(AMSBEHAVIOR_COMBO)))
   {
      return R_TRVL_POLImpl.isInferenceEnabled(foSession);
   }

   return true;
}
public static boolean isRelationshipEnabledfor_ContactToDepartment(Session foSession)
{
   if (((getBehaviors().get(AMSBEHAVIOR_CHILD_OF_INFERENCE)) &&
        (R_CNTACImpl.getBehaviors().get(AMSBEHAVIOR_INFERENCE))) ||
       (R_CNTACImpl.getBehaviors().get(AMSBEHAVIOR_COMBO)))
   {
      return R_CNTACImpl.isInferenceEnabled(foSession);
   }

   return true;
}

public static boolean isInferenceEnabled(Session foSession)
{
   if(!mboolInferenceValidationLookup)
   {
      mboolInferenceValidationActive = R_INFR_VALD_STPImpl.isInferenceActive("R_DEPT",foSession);
      mboolInferenceValidationLookup = true;
   }
   return mboolInferenceValidationActive ;
}

	//END_COMPONENT_RULES}}	

	abstract protected void addListeners();
	//{{ABSTRACT_CUSTOM_METHODS
	/**
	* User defined methods used in a rule, are defined in the Impl class,
	* have corresponding abstract methods in BaseImpl.
	* Please add @SuppressAbstract as comment after Method Declaration in Impl Source file
	* to avoid abstract declaration of any Method.
	**/
	abstract public void afterInsert( DataObject obj );
	abstract public void afterUpdate( DataObject obj );
	abstract public void afterDelete( DataObject obj );
	abstract public boolean isBuyerTeamValidOnWorkloadTable( );
	abstract public void myInitializations( );
	abstract protected boolean validateBaseDepartmentValue( );

	//END_ABSTRACT_CUSTOM_METHODS}}
}

